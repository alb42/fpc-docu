<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="morphunits">

<!--
  ====================================================================
    amigados
  ====================================================================
-->

<module name="amigados">
<short>File and directory handling routines and types (dos.library)</short>
<descr>The DOS-Library has functions and types to work with files and directories on floppy discs, hard discs and ram discs.
</descr>

<!-- constant Visibility: default -->
<element name="DOSTRUE">
<short>=1 as True Value for some Amiga functions.</short>
<descr>Some DOS functions can not handle the freepascal representation of True as -1. This functions expect a 1 as boolean True, for this purpose two constants are defined for True and False
</descr>
<seealso>
<link id="DOSFALSE"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOSFALSE">
<short>=0 as False Value for some Amiga functions.</short>
<descr>Some DOS functions can not handle the freepascal representation of True as -1. This functions expect a 1 as boolean True, for this purpose two constants are defined for True and False
</descr>
<seealso>
<link id="DOSTRUE"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MODE_OLDFILE">
<short>Parameter for <link id="DosOpen"/> Open existing file read/write </short>
<descr>Open existing file read/write and set file position to beginning of file.
Other programs can still access this file. (e.g. shared reading)
</descr>
<seealso>
<link id="DosOpen"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MODE_NEWFILE">
<short>Parameter for <link id="DosOpen"/> Create new file</short>
<descr>Create a new file an open it, if the file already exists it will be deleted and a new empty file is created.
</descr>
<seealso>
<link id="DosOpen"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MODE_READWRITE">
<short>Parameter for <link id="DosOpen"/> Exclusive read/write file</short>
<descr>Open old file and lock it that noone else can open it as long as it is open.
</descr>
<seealso>
<link id="DosOpen"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OFFSET_BEGINNING">
<short>Parameter for <link id="DosSeek"/> Start seek from the beginning of file</short>
<descr>
</descr>
<seealso>
<link id="DosSeek"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OFFSET_CURRENT">
<short>Parameter for <link id="DosSeek"/> Start the seek from the current position</short>
<descr>
</descr>
<seealso>
<link id="DosSeek"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OFFSET_END">
<short>Parameter for <link id="DosSeek"/> Start the seek from the end of file</short>
<descr>
</descr>
<seealso>
<link id="DosSeek"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BITSPERBYTE">
<short>Numbers of Bits per Byte</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BYTESPERLONG">
<short>Number of Bytes per LongWord</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BITSPERLONG">
<short>Number of Bits per LongWord</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAXINT">
<short>Biggest number useable as Integer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MININT">
<short>smallest number useable as Integer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHARED_LOCK">
<short>Parameter for <link id="Lock"/> File is readable by others</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACCESS_READ">
<short>Parameter for <link id="Lock"/> File is readable by others</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXCLUSIVE_LOCK">
<short>Parameter for <link id="Lock"/> Exclusive lock, so other access allowed</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACCESS_WRITE">
<short>Parameter for <link id="Lock"/> Exclusive lock, so other access allowed</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="FileHandle">
<short>File handle needed dor all File actions</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="FileLock">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="pDateStamp">
<short>Pointer to a Date and Time representation</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tDateStamp">
<short>Date and Time representation</short>
<descr>
</descr>
<seealso>
<link id="TICKS_PER_SECOND"/>
<link id="DateStamp"/>
<link id="CompareDates"/>
<link id="SetFileDate"/>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DateStamp.Result">
<short>Returns the supplied pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="tDateStamp.ds_Days">
<short>Number of days since 1. Jan. 1978</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tDateStamp.ds_Minute">
<short>Number of minutes of the day</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tDateStamp.ds_Tick">
<short>Number of ticks since past minute. Use <link id="TICKS_PER_SECOND"/> to calculate the seconds.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TICKS_PER_SECOND">
<short>Number of ticks per second. Defines the acuracy of your time</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PFileInfoBlock">
<short>Pointer to a file information structure</short>
<descr>
</descr>
<seealso>
<link id="Examine"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TFileInfoBlock">
<short>File information structure</short>
<descr>Provides many informations about a file without a need to open it.
</descr>
<seealso>
<link id="Examine"/>
<link id="FIBF_DELETE"/>
<link id="FIBF_EXECUTE"/>
<link id="FIBF_WRITE"/>
<link id="FIBF_READ"/>
<link id="FIBF_ARCHIVE"/>
<link id="FIBF_PURE"/>
<link id="FIBF_SCRIPT"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_DiskKey">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_DirEntryType">
<short>Type of File. &lt; 0 plain file,  &gt; 0 a directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_FileName">
<short>Name of the File or Directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_Protection">
<short>Protection bits (FIBF_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_EntryType">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_Size">
<short>Size of file in Bytes</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_NumBlocks">
<short>Size of File in blocks</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_Date">
<short>Last change Date of File</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_Comment">
<short>Comment of File</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_OwnerUID">
<short>Owners User ID (0 = no user id)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_OwnerGID">
<short>Owners Group ID (0 = no group ID)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileInfoBlock.fib_Reserved">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_OTR_READ">
<short>Protection Bit Other: file is readable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_OTR_WRITE">
<short>Protection Bit Other: file is writable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_OTR_EXECUTE">
<short>Protection Bit Other: file is executable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_OTR_DELETE">
<short>Protection Bit Other: prevent file from being deleted</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_GRP_READ">
<short>Protection Bit Group: file is readable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_GRP_WRITE">
<short>Protection Bit Group: file is writable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_GRP_EXECUTE">
<short>Protection Bit Group: file is executable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_GRP_DELETE">
<short>Protection Bit Group: prevent file from being deleted</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_SCRIPT">
<short>Protection Bit File can run as script</short>
<descr>File is a shell script file can be executed.
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_PURE">
<short>Protection Bit program is reentrant and rexecutable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_ARCHIVE">
<short>Protection Bit: Set as archive</short>
<descr>Cleared whenever file is changed
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_READ">
<short>Protection Bit: file is readable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_WRITE">
<short>Protection Bit: file is writeable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_EXECUTE">
<short>Protection Bit: file is executable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBB_DELETE">
<short>Protection Bit: file can be deleted</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_OTR_READ">
<short>Protection Value Other Readable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_OTR_WRITE">
<short>Protection Value Other writeable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_OTR_EXECUTE">
<short>Protection Value: Other executeable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_OTR_DELETE">
<short>Protection Value Other Deleteable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_GRP_READ">
<short>Protection Value Group Readable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_GRP_WRITE">
<short>Protection Value Group Writeable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_GRP_EXECUTE">
<short>Protection Value: Group Executeable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_GRP_DELETE">
<short>Protection Value Group: Deleteable</short>
<descr>Only on filesystems support users and groups
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_SCRIPT">
<short>Protection Value: File is a script</short>
<descr>File is a shell script and can be executed
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_PURE">
<short>Protection Value program is reentrant and rexecutable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_ARCHIVE">
<short>Protection Value File is marked as archived</short>
<descr>Is cleared on every filechange
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_READ">
<short>Protection Value: File is readable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_WRITE">
<short>Protection Value file is writeable</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_EXECUTE">
<short>Protection Value file can be exceuted</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FIBF_DELETE">
<short>Protection Value file can be deleted</short>
<descr>
</descr>
<seealso>
<link id="TFileInfoBlock"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FAULT_MAX">
<short>Max Length for error string</short>
<descr>Standard maximum length for an error string from fault.  However, most
error strings should be kept under 60 characters if possible.  Don't
forget space for the header you pass in.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PInfoData">
<short>General Disk informatons from <link id="Info"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TInfoData">
<short>General Disk informatons from <link id="Info"/></short>
<descr>
</descr>
<seealso>
<link id="Info"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_NumSoftErrors">
<short>Number of soft errors on disk</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_UnitNumber">
<short>Which unit disk is (was) mounted on</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_DiskState">
<short>Disk State (ID_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_NumBlocks">
<short>Number of blocks on disk</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_NumBlocksUsed">
<short>Number of block in use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_BytesPerBlock">
<short>Number of bytes per block</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_DiskType">
<short>Disk type code (ID_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_VolumeNode">
<short>Pointer to volume node</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TInfoData.id_InUse">
<short>If not it use = 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_WRITE_PROTECTED">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> Device is write protected</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_VALIDATING">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> Device is currently validating status</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_VALIDATED">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> Device validated and writeable</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_NO_DISK_PRESENT">
<short>Flag for <link id="Info"/><var>.id_DiskType</var> No Disk Present</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_UNREADABLE_DISK">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> BAD#0 Disk defective</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_DOS_DISK">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> DOS#0 OFS disk</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_FFS_DISK">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> DOS#1 FFS disk</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_NOT_REALLY_DOS">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> NDOS not a dos disk </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_KICKSTART_DISK">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> KICK Kickstart Disk</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ID_MSDOS_DISK">
<short>Flag for <link id="Info"/><var>.id_Diskstate</var> MSD#0 MSDos Disk </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NO_FREE_STORE">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_TASK_TABLE_FULL">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_BAD_TEMPLATE">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_BAD_NUMBER">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_REQUIRED_ARG_MISSING">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_KEY_NEEDS_ARG">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_TOO_MANY_ARGS">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_UNMATCHED_QUOTES">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_LINE_TOO_LONG">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_FILE_NOT_OBJECT">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_INVALID_RESIDENT_LIBRARY">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NO_DEFAULT_DIR">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_OBJECT_IN_USE">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_OBJECT_EXISTS">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DIR_NOT_FOUND">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_OBJECT_NOT_FOUND">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_BAD_STREAM_NAME">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_OBJECT_TOO_LARGE">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_ACTION_NOT_KNOWN">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_INVALID_COMPONENT_NAME">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_INVALID_LOCK">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_OBJECT_WRONG_TYPE">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DISK_NOT_VALIDATED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DISK_WRITE_PROTECTED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_RENAME_ACROSS_DEVICES">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DIRECTORY_NOT_EMPTY">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_TOO_MANY_LEVELS">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DEVICE_NOT_MOUNTED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_SEEK_ERROR">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_COMMENT_TOO_BIG">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DISK_FULL">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_DELETE_PROTECTED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_WRITE_PROTECTED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_READ_PROTECTED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NOT_A_DOS_DISK">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NO_DISK">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NO_MORE_ENTRIES">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_IS_SOFT_LINK">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_OBJECT_LINKED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_BAD_HUNK">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NOT_IMPLEMENTED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_RECORD_NOT_LOCKED">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_LOCK_COLLISION">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_LOCK_TIMEOUT">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_UNLOCK_ERROR">
<short>Errorcode of <link id="IoErr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RETURN_OK">
<short>Return Level OK = no Problem, success</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RETURN_WARN">
<short>Return level warn: some warnings appear</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RETURN_ERROR">
<short>Return Level error: errors occour can not finish</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RETURN_FAIL">
<short>Return level Fail: something really bad happend</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKB_CTRL_C">
<short>Bit numbers that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKB_CTRL_D">
<short>Bit numbers that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKB_CTRL_E">
<short>Bit numbers that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKB_CTRL_F">
<short>Bit numbers that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKF_CTRL_C">
<short>Value that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKF_CTRL_D">
<short>Value that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKF_CTRL_E">
<short>Value that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIGBREAKF_CTRL_F">
<short>Value that signal you that a user has issued a break</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOCK_SAME">
<short>Value returned by <link id="SameLock"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOCK_SAME_HANDLER">
<short>Value returned by <link id="SameLock"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOCK_DIFFERENT">
<short>Value returned by <link id="SameLock"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CHANGE_LOCK">
<short>Type for <link id="ChangeMode"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CHANGE_FH">
<short>Type for <link id="ChangeMode"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LINK_HARD">
<short>Value for <link id="MakeLink"/> Hard link</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LINK_SOFT">
<short>Value for <link id="MakeLink"/> Soft link</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEM_EQUAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEM_ERROR">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEM_NOTHING">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEM_UNQUOTED">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEM_QUOTED">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOS_FILEHANDLE">
<short>Type for <link id="AllocDosObject"/>/<link id="FreeDosObject"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOS_EXALLCONTROL">
<short>Type for <link id="AllocDosObject"/>/<link id="FreeDosObject"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOS_FIB">
<short>Type for <link id="AllocDosObject"/>/<link id="FreeDosObject"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOS_STDPKT">
<short>Type for <link id="AllocDosObject"/>/<link id="FreeDosObject"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOS_CLI">
<short>Type for <link id="AllocDosObject"/>/<link id="FreeDosObject"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOS_RDARGS">
<short>Type for <link id="AllocDosObject"/>/<link id="FreeDosObject"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PAChain">
<short></short>
<descr>

</descr>
<seealso>

</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TAChain">
<short></short>
<descr>
</descr>
<seealso>

</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAChain.an_Child">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAChain.an_Parent">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAChain.an_Lock">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAChain.an_Info">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAChain.an_Flags">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAChain.an_String">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PAnchorPath">
<short>Structure expected by MatchFirst, MatchNext to find Files.</short>
<descr><p> To search for files call <link id="MatchFirst">MatchFirst()</link> and then afterwards, <link id="MatchNext">MatchNext()</link> with this structure.
  You should check the return value each time and take the
  appropriate action, ultimately calling <link id="MatchEnd">MatchEnd()</link> when there are
  no more files and you are done.  You can tell when you are done by
  checking for the normal DOS return code <link id="ERROR_NO_MORE_ENTRIES"/>.</p>
</descr>
<seealso>
<link id="MatchFirst"/>
<link id="MatchNext"/>
<link id="MatchEnd"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TAnchorPath">
<short>Structure expected by MatchFirst, MatchNext to find Files.</short>
<descr><p>
  Allocate this structure and initialize it as follows:</p>
<p>
  Set <var>ap_BreakBits</var> to the signal bits (DDB) that you want to take a
 break on, or <var>nil</var>, if you don't want to convenience the user.</p>
<p>
  If you want to have the full path name of the files you found,
  allocate a buffer at the end of this structure, and put the size of
  it into <var>ap_Strlen</var>.  If you don't want the full path name, make sure
  you set <var>ap_Strlen</var> to 0. In this case, the name of the file, and stats
  are available in the <var>ap_Info</var>, as per usual.</p>
<p>
  Then call <link id="MatchFirst">MatchFirst()</link> and then afterwards, <link id="MatchNext">MatchNext()</link> with this structure.
  You should check the return value each time and take the
  appropriate action, ultimately calling <link id="MatchEnd">MatchEnd()</link> when there are
  no more files and you are done.  You can tell when you are done by
  checking for the normal DOS return code <link id="ERROR_NO_MORE_ENTRIES"/>.</p>
</descr>
<seealso>
<link id="MatchFirst"/>
<link id="MatchNext"/>
<link id="MatchEnd"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_First">
<short>Pointer to first anchor</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Last">
<short>Pointer to last anchor</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Base">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Current">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_BreakBits">
<short>Bits we want to break on (DDF_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_FoundBreak">
<short>Bits we broke on. Also returns <link id="ERROR_BREAK"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Flags">
<short>Extra flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Reserved">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Strlen">
<short>This is what <var>ap_Length</var> used to be</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Info">
<short>Info block of the found file</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAnchorPath.ap_Buf">
<short>Buffer start for full path output</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_DOWILD">
<short>User option ALL</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_DOWILD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_ITSWILD">
<short>Flag Bit for <link id="TAnchorPath">ap_Flags</link>. Set by MatchFirst, used by MatchNext</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_ITSWILD">
<short>Flag Value for <link id="TAnchorPath">ap_Flags</link>. Set by MatchFirst, used by MatchNext</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_DODIR">
<short>Flag Bit for <link id="TAnchorPath">ap_Flags</link>. Marks a Directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_DODIR">
<short>Flag Value for <link id="TAnchorPath">ap_Flags</link>. Marks a Directories</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_DIDDIR">
<short>Flag Bit for <link id="TAnchorPath">ap_Flags</link>. Marks an an "expired" dir node.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_DIDDIR">
<short>Flag Value for <link id="TAnchorPath">ap_Flags</link>. Marks an "expired" dir node.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_NOMEMERR">
<short>Flag Bit for <link id="TAnchorPath">ap_Flags</link>. Set on memory error</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_NOMEMERR">
<short>Flag Value for <link id="TAnchorPath">ap_Flags</link>. Set on memory error</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_DODOT">
<short>Flag Bit for <link id="TAnchorPath">ap_Flags</link>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_DODOT">
<short>Flag Value for <link id="TAnchorPath">ap_Flags</link>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APB_DirChanged">
<short>Flag Bit for <link id="TAnchorPath">ap_Flags</link>. Allow conversion of '.' to CurrentDir</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="APF_DirChanged">
<short>Flag Value for <link id="TAnchorPath">ap_Flags</link>. Allow conversion of '.' to CurrentDir</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDB_PatternBit">
<short>Bit for ap_Current->an_Lock changed since last MatchNext call</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDF_PatternBit">
<short>Value for ap_Current->an_Lock changed since last MatchNext call</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDB_ExaminedBit">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDF_ExaminedBit">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDB_Completed">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDF_Completed">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDB_AllBit">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDF_AllBit">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDB_Single">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DDF_Single">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_ANY">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_SINGLE">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_ORSTART">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_ORNEXT">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_OREND">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_NOT">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_NOTEND">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_NOTCLASS">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_CLASS">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_REPBEG">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_REPEND">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="P_STOP">
<short>Internal constants used by wildcard routines of <link id="MatchFirst"/> and <link id="MatchNext"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="COMPLEX_BIT">
<short>Values for <link id="TAnchorPath"/><var>.an_Status</var>, NOTE: These are the actual bit numbers</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXAMINE_BIT">
<short>Values for <link id="TAnchorPath"/><var>.an_Status</var>, NOTE: These are the actual bit numbers</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_BUFFER_OVERFLOW">
<short>Returns from <link id="MatchFirst"/>, <link id="MatchNext"/>: User OR internal buffer overflow</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_BREAK">
<short>Returns from <link id="MatchFirst"/>, <link id="MatchNext"/>: A break character was received</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_NOT_EXECUTABLE">
<short>Returns from <link id="MatchFirst"/>, <link id="MatchNext"/>:  A file has E bit cleared</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_UNIT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_NAME">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_CODE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_DATA">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_BSS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_RELOC32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_RELOC16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_RELOC8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_EXT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_SYMBOL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_DEBUG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_END">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_HEADER">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_OVERLAY">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_BREAK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_DREL32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_DREL16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_DREL8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_LIB">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HUNK_INDEX">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_SYMB">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_DEF">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_ABS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_RES">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_REF32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_COMMON">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_REF16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_REF8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_DEXT32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_DEXT16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EXT_DEXT8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="pProcess">
<short>All DOS processes have this structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tProcess">
<short>All DOS processes have this structure</short>
<descr>Create and Device Proc returns pointer to the MsgPort in this structure dev_proc = Address(SmallInt(DeviceProc()) - SizeOf(Task))
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_Task">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_MsgPort">
<short>This is address from DOS functions</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_Pad">
<short>Remaining variables on 4 byte boundaries</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_SegList">
<short>Array of seg lists used by this process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_StackSize">
<short>Size of process stack in bytes</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_GlobVec">
<short>Global vector for this process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_TaskNum">
<short>CLI task number of zero if not a CLI</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_StackBase">
<short>Pointer to high memory end of process stack</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_Result2">
<short>Value of secondary result from last call</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_CurrentDir">
<short>Lock associated with current directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_CIS">
<short>Current CLI Input Stream</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_COS">
<short>Current CLI Output Stream</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_ConsoleTask">
<short>Console handler process for current window</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_FileSystemTask">
<short>File handler process for current drive</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_CLI">
<short>pointer to TConsoleLineInterpreter</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_ReturnAddr">
<short>Pointer to previous stack frame</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_PktWait">
<short>Function to be called when awaiting msg</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_WindowPtr">
<short>Window for error printing</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_HomeDir">
<short>Home directory of executing program</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_Flags">
<short>Flags telling dos about process (PRF_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_ExitCode">
<short>Code to call on exit of program or <var>nil</var></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_ExitData">
<short>Passed as an argument to pr_ExitCode.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_Arguments">
<short>Arguments passed to the process at start</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_LocalVars">
<short>Local environment variables</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_ShellPrivate">
<short>for the use of the current shell</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tProcess.pr_CES">
<short>Error stream - if <var>nil</var>, use pr_COS</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRB_FREESEGLIST">
<short>Flag bit for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRF_FREESEGLIST">
<short>Flag value for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRB_FREECURRDIR">
<short>Flag bit for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRF_FREECURRDIR">
<short>Flag value for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRB_FREECLI">
<short>Flag bit for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRF_FREECLI">
<short>Flag value for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRB_CLOSEINPUT">
<short>Flag bit for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRF_CLOSEINPUT">
<short>Flag value for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRB_CLOSEOUTPUT">
<short>Flag bit for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRF_CLOSEOUTPUT">
<short>Flag value for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRB_FREEARGS">
<short>Flag bit for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PRF_FREEARGS">
<short>Flag value for <link id="tProcess"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PFileHandle">
<short>This pointer is returned by
 <link id="DosOpen">DosOpen()</link> and other routines that return a file. You need only worry
  about this struct to do async io's via <link id="exec.PutMsg">PutMsg()</link> instead of
  standard file system calls</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TFileHandle">
<short>The pointer of this structure is returned by
 <link id="DosOpen">DosOpen()</link> and other routines that return a file. You need only worry
  about this struct to do async io's via <link id="exec.PutMsg">PutMsg()</link> instead of
  standard file system calls</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Link">
<short>Exec message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Port">
<short>Reply port for the packet</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Type">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Buf">
<short>Port to do ReplyMsg()</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Pos">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_End">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Func1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Func2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Func3">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Arg1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Arg2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDosPacket">
<short>This is the extension to EXEC Messages used by DOS</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDosPacket">
<short>This is the extension to EXEC Messages used by DOS</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Link">
<short>Exec Message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Port">
<short>Reply port for the packet. Must be filled in each send.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Action">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Status">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Status2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_BufAddr">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Type">
<short>Type of access =Ord('W') write = Ord('R') read (ACTION_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Res1">
<short></short>
<descr>For file system calls this is the result
that would have been returned by the
function, e.g. Write Ord('W') returns actual
length written
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Res2">
<short></short>
<descr>For file system calls this is what would
have been returned by IoErr()
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg3">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg4">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg5">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg6">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosPacket.dp_Arg7">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PStandardPacket">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TStandardPacket">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStandardPacket.sp_Msg">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStandardPacket.sp_Pkt">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_NIL">
<short>Action for <link id="TDosPacket"/>.dp_Type </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_GET_BLOCK">
<short>Action for <link id="TDosPacket"/>.dp_Type Obsolete</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SET_MAP">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_DIE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_EVENT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_CURRENT_VOLUME">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_LOCATE_OBJECT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_RENAME_DISK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_WRITE">
<short>Action for <link id="TDosPacket"/>.dp_Type = Ord('W') write to Filesystem</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_READ">
<short>Action for <link id="TDosPacket"/>.dp_Type = Ord('R') read from Filesystem</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FREE_LOCK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_DELETE_OBJECT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_RENAME_OBJECT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_MORE_CACHE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_COPY_DIR">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_WAIT_CHAR">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SET_PROTECT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_CREATE_DIR">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_EXAMINE_OBJECT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_EXAMINE_NEXT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_DISK_INFO">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_INFO">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FLUSH">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SET_COMMENT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_PARENT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_TIMER">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_INHIBIT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_DISK_TYPE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_DISK_CHANGE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SET_DATE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SCREEN_MODE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_READ_RETURN">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_WRITE_RETURN">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SEEK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FINDUPDATE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FINDINPUT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FINDOUTPUT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_END">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_TRUNCATE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_WRITE_PROTECT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SAME_LOCK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_CHANGE_SIGNAL">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FORMAT">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_MAKE_LINK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_READ_LINK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FH_FROM_LOCK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_IS_FILESYSTEM">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_CHANGE_MODE">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_COPY_DIR_FH">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_PARENT_FH">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_EXAMINE_ALL">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_EXAMINE_FH">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_LOCK_RECORD">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_FREE_RECORD">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_ADD_NOTIFY">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_REMOVE_NOTIFY">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_EXAMINE_ALL_END">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SET_OWNER">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ACTION_SERIALIZE_DISK">
<short>Action for <link id="TDosPacket"/>.dp_Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PErrorString">
<short>A structure for holding error messages - stored as array with error = 0
 for the last entry.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TErrorString">
<short>A structure for holding error messages - stored as array with error = 0
  for the last entry.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TErrorString.estr_Nums">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TErrorString.estr_Strings">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PRootNode">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRootNode">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_TaskArray">
<short>[0] is max number of CLI's [1] is APTR to process id of CLI 1 [n] is APTR to process id of CLI n</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_ConsoleSegment">
<short>SegList for the CLI</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_Time">
<short>Current time</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_RestartSeg">
<short>SegList for the disk validator process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_Info">
<short>Pointer ot the Info structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_FileHandlerSegment">
<short>Segment for a file handler</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_CliList">
<short>New list of all CLI processes the first <var>cpl_Array</var> is also <var>rn_TaskArray</var> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_BootProc">
<short>Private pointer to msgport of boot file system</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_ShellSegment">
<short>Seglist for Shell (for NewShell) </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_Flags">
<short>dos flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RNB_WILDSTAR">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RNF_WILDSTAR">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RNB_PRIVATE1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RNF_PRIVATE1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDosInfo">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDosInfo">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_ResList">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_McName">
<short>Network name of this machine; currently 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_DevInfo">
<short>Device List</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_Devices">
<short>Currently 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_Handlers">
<short>Currently 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_NetHand">
<short>Network handler processid; currently 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_DevLock">
<short>do NOT access directly!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_EntryLock">
<short>do NOT access directly!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosInfo.di_DeleteLock">
<short>do NOT access directly!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PCliProcList">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TCliProcList">
<short>Only to be allocated by DOS!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCliProcList.cpl_Node">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCliProcList.cpl_First">
<short>number of first entry in array</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCliProcList.cpl_Array">
<short>[0] is max number of CLI's in this entry (n), [1] is CPTR to process id of CLI cpl_First, [n] is CPTR to process id of CLI cpl_First+n-1</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PSegment">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TSegment">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TSegment.seg_Next">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TSegment.seg_UC">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TSegment.seg_Seg">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TSegment.seg_Name">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CMD_SYSTEM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CMD_INTERNAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CMD_DISABLED">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PCommandLineInterface">
<short>DOS Processes started from the CLI via RUN or NEWCLI have this additional
 set to data associated with them</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TCommandLineInterface">
<short>DOS Processes started from the CLI via RUN or NEWCLI have this additional
 set to data associated with them</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_Result2">
<short>Value of IoErr from last command</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_SetName">
<short>Name of current directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_CommandDir">
<short>Lock associated with command directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_ReturnCode">
<short>Return code from last command</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_CommandName">
<short>Name of current command</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_FailLevel">
<short>Fail level (set by FAILAT)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_Prompt">
<short>Current prompt (set by PROMPT)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_StandardInput">
<short>Default (terminal) CLI input</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_CurrentInput">
<short>Current CLI input</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_CommandFile">
<short>Name of EXECUTE command file</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_Interactive">
<short>Boolean; True if prompts required</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_Background">
<short>Boolean; True if CLI created by RUN</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_CurrentOutput">
<short>Current CLI output</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_DefaultStack">
<short>Stack size to be obtained in long words</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_StandardOutput">
<short>Default (terminal) CLI output</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCommandLineInterface.cli_Module">
<short>SegList of currently loaded command</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDeviceList">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDeviceList">
<short>This structure can take on different values depending on whether it is
 a device, an assigned directory, or a volume. This structure representing a volume. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_Next">
<short>Pointer to next device list</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_Type">
<short>Type of record (DLT_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_Task">
<short>Pointer to handler task</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_Lock">
<short>not for volumes</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_VolumeDate">
<short>Creation date</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_LockList">
<short>Outstanding locks</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_DiskType">
<short>'DOS', etc</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_unused">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceList.dl_Name">
<short>Name of device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDevInfo">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDevInfo">
<short>This structure can take on different values depending on whether it is
 a device, an assigned directory, or a volume. This structure representing a device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Next">
<short>Pointer to next device list</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Type">
<short>Type of record (DLT_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Task">
<short>Pointer to handler task</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Lock">
<short>Lock to Device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Handler">
<short>Handler for device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_StackSize">
<short>Stacksize</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Priority">
<short>Priority in list</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Startup">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_SegList">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_GlobVec">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevInfo.dvi_Name">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PAssignList">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TAssignList">
<short>This structure can take on different values depending on whether it is
 a device, an assigned directory, or a volume. This structure used for multi-directory assigns.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAssignList.al_Next">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TAssignList.al_Lock">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDosList">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDosList">
<short>This structure can take on different values depending on whether it is
 a device, an assigned directory, or a volume. This structure combined structure for devices, assigned directories, volumes.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Next">
<short>Pointer to next device on list</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Type">
<short>Type of record (DLT_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Task">
<short>Pointer to handler task</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Lock">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Handler">
<short>file name to load if seglist is <var>nil</var></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_StackSize">
<short>stacksize to use when starting process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Priority">
<short>task priority when starting process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Startup">
<short>Startup msg: FileSysStartupMsg for disks</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_SegList">
<short>Already loaded code for new task</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_GlobVec">
<short>global vector to use when starting a process. -1 indicates a C/Assembler program.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_VolumeDate">
<short>creation date</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_LockList">
<short>outstanding locks</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_DiskType">
<short>'DOS', etc. (ID_*) </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Volume">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_AssignName">
<short>name for non-OR-late-binding assign</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_List">
<short>for multi-directory assigns (regular)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_assign">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Name">
<short>Name of Entry</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DLT_DEVICE">
<short>Type for <link id="TDosList"/>.dol_Type identifiers a device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DLT_DIRECTORY">
<short>Type for <link id="TDosList"/>.dol_Type identifiers a directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DLT_VOLUME">
<short>Type for <link id="TDosList"/>.dol_Type identifiers a volume</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DLT_LATE">
<short>Type for <link id="TDosList"/>.dol_Type identifiers a late binding assign</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DLT_NONBINDING">
<short>Type for <link id="TDosList"/>.dol_Type identifiers a non binding assign</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DLT_PRIVATE">
<short>Type for <link id="TDosList"/>.dol_Type for internal use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDevProc">
<short>Structure return by <link id="GetDeviceProc">GetDeviceProc()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDevProc">
<short>Structure return by <link id="GetDeviceProc">GetDeviceProc()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevProc.dvp_Port">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevProc.dvp_Lock">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevProc.dvp_Flags">
<short>Flags (DVPF_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDevProc.dvp_DevNode">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DVPB_UNLOCK">
<short>Flag Bit for <link id="TDevProc"/>.dvp_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DVPF_UNLOCK">
<short>Flag Value for <link id="TDevProc"/>.dvp_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DVPB_ASSIGN">
<short>Flag Bit for <link id="TDevProc"/>.dvp_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DVPF_ASSIGN">
<short>Flag Value for <link id="TDevProc"/>.dvp_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_DEVICES">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_DEVICES">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_VOLUMES">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_VOLUMES">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_ASSIGNS">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_ASSIGNS">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_ENTRY">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_ENTRY">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_DELETE">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_DELETE">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_READ">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_READ">
<short>Flag valuepassed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDB_WRITE">
<short>Flag bit passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_WRITE">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LDF_ALL">
<short>Flag value passed to <link id="LockDosList">LockDosList()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REPORT_STREAM">
<short>Error report stream at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REPORT_TASK">
<short>Error report task at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REPORT_LOCK">
<short>Error report Lock at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REPORT_VOLUME">
<short>Error report volume at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REPORT_INSERT">
<short>Error report ""please inser volume" at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ABORT_DISK_ERROR">
<short>Error report Read write error at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ABORT_BUSY">
<short>Error report busy at <link id="ErrorReport">ErrorReport()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RUN_EXECUTE">
<short>Type for initial packets to shells from run/newcli/execute/system.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RUN_SYSTEM">
<short>Type for initial packets to shells from run/newcli/execute/system.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RUN_SYSTEM_ASYNCH">
<short>Type for initial packets to shells from run/newcli/execute/system.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_ROOT">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType root directory of a device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_USERDIR">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_SOFTLINK">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType looks like a dir, but may point to a file</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_LINKDIR">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType hard link to directory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_FILE">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType ordinary file</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_LINKFILE">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType hard link to file</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ST_PIPEFILE">
<short>Type for <link id="TFileInfoBlock"/>.fib_DirEntryType pipes support ExamineFH</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PFileLock">
<short>Lock structure, as returned by <link id="Lock">Lock()</link> or <link id="DupLock">DupLock()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TFileLock">
<short>Lock structure, as returned by <link id="Lock">Lock()</link> or <link id="DupLock">DupLock()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileLock.fl_Link">
<short>Pointer to next lock</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileLock.fl_Key">
<short>Disk block number</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileLock.fl_Access">
<short>Exclusive or share</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileLock.fl_Task">
<short>Handler task's port</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileLock.fl_Volume">
<short>Pointer to a DeviceList</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_NAME">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_TYPE">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_SIZE">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_PROTECTION">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_DATE">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_COMMENT">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ED_OWNER">
<short>Parameter for <link id="ExAll">ExAll()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PExAllData">
<short>Structure in which exall results are returned in.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExAllData">
<short>Structure in which exall results are returned in. Note that only the fields asked for will exist!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Next">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Name">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Type">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Size">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Prot">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Days">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Mins">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Ticks">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_Comment">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_OwnerUID">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllData.ed_OwnerGID">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PExAllControl">
<short>Control structure passed to <link id="ExAll">ExAll()</link>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExAllControl">
<short>Control structure passed to <link id="ExAll">ExAll()</link>.</short>
<descr><p>Unused fields <b>must</b> be initialized to 0, expecially <var>eac_LastKey</var>.</p>
 <p><var>eac_MatchFunc</var> is a hook (see utility.library documentation for usage)
    It should return True if the entry is to returned, False if it is to be
    ignored.</p>
 <p>This structure <b>must</b> be allocated by <link id="AllocDosObject">AllocDosObject()</link>!</p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllControl.eac_Entries">
<short>Number of entries returned in buffer </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllControl.eac_LastKey">
<short>Don't touch inbetween linked ExAll calls!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllControl.eac_MatchString">
<short>Wildcard string for pattern match or <var>nil</var></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExAllControl.eac_MatchFunc">
<short>optional private wildcard function pointer </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDosEnvec">
<short>Describes the disk geometry</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDosEnvec">
<short>Describes the disk geometry</short>
<descr>Here are the constants for a standard geometry.
if you treat it as an array you can use the DE_* constants
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_TableSize">
<short>Size of Environment vector</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_SizeBlock">
<short>in longwords: standard value is 128</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_SecOrg">
<short>not used; must be 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_Surfaces">
<short># of heads (surfaces). drive specific</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_SectorPerBlock">
<short>not used; must be 1</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_BlocksPerTrack">
<short>blocks per track. drive specific</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_Reserved">
<short>DOS reserved blocks at start of partition.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_PreAlloc">
<short>DOS reserved blocks at end of partition</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_Interleave">
<short>usually 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_LowCyl">
<short>starting cylinder. typically 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_HighCyl">
<short>max cylinder. drive specific</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_NumBuffers">
<short>Initial # DOS of buffers. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_BufMemType">
<short>Type of mem to allocate for buffers</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_MaxTransfer">
<short>Max number of bytes to transfer at a time</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_Mask">
<short>Address Mask to block out certain memory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_BootPri">
<short>Boot priority for autoboot</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_DosType">
<short>ASCII (HEX) string showing filesystem type; $444F5300 OFS, $444F5301 FFS</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_Baud">
<short>Baud rate for serial handler</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_Control">
<short>Control SmallInt for handler/filesystem</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosEnvec.de_BootBlocks">
<short>Number of blocks containing boot code</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_TABLESIZE">
<short>Offset <link id="TDosEnvec"/>: standard value is 11</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_SIZEBLOCK">
<short>Offset <link id="TDosEnvec"/>: in longwords: standard value is 128 </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_SECORG">
<short>Offset <link id="TDosEnvec"/>: in longwords: not used; must be 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_NUMHEADS">
<short>Offset <link id="TDosEnvec"/>: in longwords: # of heads (surfaces). drive specific</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_SECSPERBLK">
<short>Offset <link id="TDosEnvec"/>: in longwords: not used; must be 1</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_BLKSPERTRACK">
<short>Offset <link id="TDosEnvec"/>: in longwords: blocks per track. drive specific</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_RESERVEDBLKS">
<short>Offset <link id="TDosEnvec"/>: in longwords: unavailable blocks at start.   usually 2</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_PREFAC">
<short>Offset <link id="TDosEnvec"/>: in longwords: not used; must be 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_INTERLEAVE">
<short>Offset <link id="TDosEnvec"/>: in longwords: usually 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_LOWCYL">
<short>Offset <link id="TDosEnvec"/>: in longwords: starting cylinder. typically 0 </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_UPPERCYL">
<short>Offset <link id="TDosEnvec"/>: in longwords: max cylinder.  drive specific</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_NUMBUFFERS">
<short>Offset <link id="TDosEnvec"/>: in longwords: starting # of buffers.  typically 5</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_MEMBUFTYPE">
<short>Offset <link id="TDosEnvec"/>: in longwords: type of mem to allocate for buffers.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_BUFMEMTYPE">
<short>Offset <link id="TDosEnvec"/>: in longwords: type of mem to allocate for buffers.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_MAXTRANSFER">
<short>Offset <link id="TDosEnvec"/>: in longwords: Max number bytes to transfer at a time</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_MASK">
<short>Offset <link id="TDosEnvec"/>: in longwords: Address Mask to block out certain memory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_BOOTPRI">
<short>Offset <link id="TDosEnvec"/>: in longwords: Boot priority for autoboot</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_DOSTYPE">
<short>Offset <link id="TDosEnvec"/>: in longwords: ASCII (HEX) string showing filesystem type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_BAUD">
<short>Offset <link id="TDosEnvec"/>: in longwords: Baud rate for serial handler</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_CONTROL">
<short>Offset <link id="TDosEnvec"/>: in longwords: Control SmallInt for handler/filesystem</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DE_BOOTBLOCKS">
<short>Offset <link id="TDosEnvec"/>: in longwords: Number of blocks containing boot code</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PFileSysStartupMsg">
<short>Pointer to filesystem startup message for a device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TFileSysStartupMsg">
<short>Filesystem startup message for a device</short>
<descr>The file system startup message is linked into a device node's startup
 field.  It contains a pointer to the <link id="TDosEnvec">Dos environment table</link> and the
 information needed to do an <link id="exec.OpenDevice">OpenDevice()</link>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileSysStartupMsg.fssm_Unit">
<short>Exec unit number for this device</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileSysStartupMsg.fssm_Device">
<short>Device Name</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileSysStartupMsg.fssm_Environ">
<short>Pointer to <link id="TDosEnvec">Dos environment table</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileSysStartupMsg.fssm_Flags">
<short>Flags for <link id="exec.OpenDevice">OpenDevice()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDeviceNode">
<short>Pointer to Device node list</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDeviceNode">
<short>Device node list <link id="DLT_DEVICE"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Next">
<short>Link to next node</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Type">
<short>Always 0 for dos "devices"</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Task">
<short>standard dos "task" field.  If this is <var>nil</var>
when the node is accesses, a task will be started up</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Lock">
<short>Not used for devices, leave <var>nil</var></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Handler">
<short>Filename to loadseg (if seglist is <var>nil</var>)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_StackSize">
<short>Stacksize to use when starting task</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Priority">
<short>Task priority when starting task</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Startup">
<short>Pointer to <link id="TFileSysStartupMsg"/> for disks</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_SegList">
<short>code to run to start new task (if necessary). if <var>nil</var> then <var>dn_Handler</var> will be loaded.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_GlobalVec">
<short>Global vector to use when starting a task.-1 means that <var>dn_SegList</var> is not
 for a bcpl program, so the dos won't try and construct one. 0 tell the
dos that you obey BCPL linkage rules, and that it should construct a global
vector for you.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDeviceNode.dn_Name">
<short>the node name, e.g. '\3','D','F','3' for DF3:</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOTIFY_CLASS">
<short>NotifyMessage Class</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOTIFY_CODE">
<short>NotifyMessage Code</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PNotifyRequest">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TNotifyRequest">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Name">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_FullName">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_UserData">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Flags">
<short>Flags for Notify Requesr (NRF_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Port">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Msg">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Task">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_SignalNum">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_pad">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Signal">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_stuff">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Reserved">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_MsgCount">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyRequest.nr_Handler">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PNotifyMessage">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TNotifyMessage">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyMessage.nm_ExecMessage">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyMessage.nm_Class">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyMessage.nm_Code">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyMessage.nm_NReq">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyMessage.nm_DoNotTouch">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNotifyMessage.nm_DoNotTouch2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRF_SEND_MESSAGE">
<short>Flag for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRF_SEND_SIGNAL">
<short>Flag for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRF_WAIT_REPLY">
<short>Flag for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRF_NOTIFY_INITIAL">
<short>Flag for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRF_MAGIC">
<short>Flag for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRB_SEND_MESSAGE">
<short>Flag bit for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRB_SEND_SIGNAL">
<short>Flag bit for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRB_WAIT_REPLY">
<short>Flag bit for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRB_NOTIFY_INITIAL">
<short>Flag bit for <link id="TNotifyRequest"/>.nr_Flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NRB_MAGIC">
<short>Flag bit for <link id="TNotifyRequest"/>.nr_Flags do <b>not</b> set or remove it!  Only for use by handlers! </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NR_HANDLER_FLAGS">
<short>Flag for <link id="TNotifyRequest"/>.nr_Flags reserved for private use by the handler</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PCSource">
<short>Pointer to Input structure for <link id="ReadItem"/> and <link id="ReadArgs"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TCSource">
<short>Input structure for <link id="ReadItem"/> and <link id="ReadArgs"/></short>
<descr><p>
 The TCSource data structure defines the input source for <link id="ReadItem"/>
 as well as the <link id="ReadArgs"/> call. It is a publicly defined structure
 which may be used by applications which use code that follows the
 conventions defined for access.</p>
<p>
  To initialize a <var>TCSource</var>, you set <var>TCSource.CS_Buffer</var> to
  a string which is used as the data source, and set <var>CS_Length</var> to
  the number of characters in the string.  Normally <var>CS_CurChr</var> should
  be initialized to 0, or left as it was from prior use as a TCSource.</p>
<p>
 When passed to the dos.library functions, the value passed as
 <link id="PCSource"/> is defined as follows:</p>
<code>
if PCSource = nil then
  // Use buffered IO <link id="ReadItem"/> as data source
else
  // Use PCSource for input character stream
</code>

</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCSource.CS_Buffer">
<short>Data source</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCSource.CS_Length">
<short>Length of string</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TCSource.CS_CurChr">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PRDArgs">
<short>Input parameter <link id="ReadArgs">ReadArgs()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRDArgs">
<short>Input parameter structure used in <link id="ReadArgs">ReadArgs()</link></short>
<descr><p>
  if <link id="TCSource">RDA_Source.CS_Buffer</link> is not <var>nil</var>,
  <var>RDA_Source</var> is used as the input
  character stream to parse, else the input comes from the buffered STDIN</p>
 <p>
  <var>RDA_DAList</var> is a private address which is used internally to track
  allocations which are freed by <link id="FreeArgs">FreeArgs()</link>.  This <b>must</b> be initialized
  to <var>nil</var> prior to the first call to <link id="ReadArgs">ReadArgs()</link>.</p>
 <p>
  The <var>RDA_Buffer</var> and <var>RDA_BufSiz</var> fields allow the application to supply
  a fixed-size buffer in which to store the parsed data.  This allows
  the application to pre-allocate a buffer rather than requiring buffer
  space to be allocated.  If either <var>RDA_Buffer</var> or <var>RDA_BufSiz</var> is <var>nil</var> or 0,
  the application has not supplied a buffer.</p>
 <p>
  <var>RDA_ExtHelp</var> is a text string which will be displayed instead of the
  template string, if the user is prompted for input.</p>
 <p>
  <var>RDA_Flags</var> bits control how <link id="ReadArgs">ReadArgs()</link> works.  The flag bits are
  defined with (RDAF_*).  Defaults are initialized to 0.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRDArgs.RDA_Source">
<short>Select input source</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRDArgs.RDA_DAList">
<short>private field do not touch.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRDArgs.RDA_Buffer">
<short>Optional string parsing space.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRDArgs.RDA_BufSiz">
<short>Size of RDA_Buffer (0..n)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRDArgs.RDA_ExtHelp">
<short>Optional extended help</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRDArgs.RDA_Flags">
<short>Flags for any required control (RDAF_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RDAB_STDIN">
<short>Flag bit for <link id="TRDArgs"/>.RDA_Flags use StdIn rather than command line</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RDAF_STDIN">
<short>Flag value for <link id="TRDArgs"/>.RDA_Flags use StdIn rather than command line</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RDAB_NOALLOC">
<short>Flag bit for <link id="TRDArgs"/>.RDA_Flags If set, do not allocate extra string space.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RDAF_NOALLOC">
<short>Flag value for <link id="TRDArgs"/>.RDA_Flags If set, do not allocate extra string space.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RDAB_NOPROMPT">
<short>Flag bit for <link id="TRDArgs"/>.RDA_Flags Disable reprompting for string input.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RDAF_NOPROMPT">
<short>Flag value for <link id="TRDArgs"/>.RDA_Flags Disable reprompting for string input.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAX_TEMPLATE_ITEMS">
<short>Maximum number of template keywords which can be in a template passed
 to <link id="ReadArgs">ReadArgs()</link>. Note: must be a multiple of 4.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAX_MULTIARGS">
<short>Maximum number of MULTIARG items returned by <link id="ReadArgs">ReadArgs()</link>, before
 an <link id="ERROR_LINE_TOO_LONG"/>.  These two limitations are due to stack
 usage.
 Applications should allow "a lot" of stack to use <link id="ReadArgs">ReadArgs()</link>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REC_EXCLUSIVE">
<short>Mode for <link id="TRecordLock"/>.rec_Mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REC_EXCLUSIVE_IMMED">
<short>Mode for <link id="TRecordLock"/>.rec_Mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REC_SHARED">
<short>Mode for <link id="TRecordLock"/>.rec_Mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REC_SHARED_IMMED">
<short>Mode for <link id="TRecordLock"/>.rec_Mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PRecordLock">
<short>Parameter for <link id="TRecordLock"/>.rec_Mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRecordLock">
<short>Parameter struct for <link id="TRecordLock"/>.rec_Mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRecordLock.rec_FH">
<short>Filehandle</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRecordLock.rec_Offset">
<short>Offset in file</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRecordLock.rec_Length">
<short>Length of file to be locked</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRecordLock.rec_Mode">
<short>Type of lock (REC_*)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PLocalVar">
<short>Pointer to a Localvars list</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TLocalVar">
<short>The structure in the <link id="TProcess"/>.pr_LocalVars list</short>
<descr>Do <b>not</b> allocate yourself, use <link id="SetVar">SetVar()</link>!
       This structure may grow in future releases.
       The list should be left in alphabetical order, and
       may have multiple entries with the same name but different types.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TLocalVar.lv_Node">
<short>Node of the entry. the <var>.ln_Type</var> (LV_*) </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TLocalVar.lv_Flags">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TLocalVar.lv_Value">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TLocalVar.lv_Len">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LV_VAR">
<short>Bit Definition for <link id="TLocalVar"/>.lv_Node.ln_Type defines a Variable</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LV_ALIAS">
<short>Bit Definition for <link id="TLocalVar"/>.lv_Node.ln_Type defines an alias</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LVB_IGNORE">
<short>Bit Definition for <link id="TLocalVar"/>.lv_Node.ln_Type ignore on <link id="GetVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LVF_IGNORE">
<short>Definition for <link id="TLocalVar"/>.lv_Node.ln_Type ignore on <link id="GetVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVB_GLOBAL_ONLY">
<short>Flag bit passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVF_GLOBAL_ONLY">
<short>Flag value passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVB_LOCAL_ONLY">
<short>Flag bit passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVF_LOCAL_ONLY">
<short>Flag value passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVB_BINARY_VAR">
<short>Flag bit passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVF_BINARY_VAR">
<short>Flag value passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVB_DONT_NULL_TERM">
<short>Flag bit passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVF_DONT_NULL_TERM">
<short>Flag value passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVB_SAVE_VAR">
<short>Flag bit passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GVF_SAVE_VAR">
<short>Flag value passed to <link id="GetVar"/>/<link id="SetVar"/>/<link id="DeleteVar"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYS_Dummy">
<short>Tag for <link id="SystemTagList"/> start of Tag range </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYS_Input">
<short>Tag for <link id="SystemTagList"/> specifies an input file handle</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYS_Output">
<short>Tag for <link id="SystemTagList"/> specifies an output file handle</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYS_Asynch">
<short>Tag for <link id="SystemTagList"/> run the process asynchron, closes the input/output on exit</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYS_UserShell">
<short>Tag for <link id="SystemTagList"/> send to user shell instead of boot shell</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYS_CustomShell">
<short>Tag for <link id="SystemTagList"/> send to a specific shell (name)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Dummy">
<short>Tag for <link id="CreateNewProc"/> start of tag range</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Seglist">
<short>Tag for <link id="CreateNewProc"/> seglist of code to run for the process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_FreeSeglist">
<short>Tag for <link id="CreateNewProc"/> free the seglist when program finished. (Default True)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Entry">
<short>Tag for <link id="CreateNewProc"/> Entry point to run - mutually exclusive with <link id="NP_Seglist"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Input">
<short>Tag for <link id="CreateNewProc"/> input file handle (Default NIL:)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Output">
<short>Tag for <link id="CreateNewProc"/> output filehandle (Default NIL:)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_CloseInput">
<short>Tag for <link id="CreateNewProc"/> Close Input on exit (Default True)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_CloseOutput">
<short>Tag for <link id="CreateNewProc"/> Close Output on ext (Default True)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Error">
<short>Tag for <link id="CreateNewProc"/> error filehandle (Default NIL:)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_CloseError">
<short>Tag for <link id="CreateNewProc"/> close error output on exit (Default True)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_CurrentDir">
<short>Tag for <link id="CreateNewProc"/> Lock (default is host's current dir)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_StackSize">
<short>Tag for <link id="CreateNewProc"/> Stacksize for the programm (Default 4000)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Name">
<short>Tag for <link id="CreateNewProc"/> Name for the process (Default New Process)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Priority">
<short>Tag for <link id="CreateNewProc"/> Priority for the new process (Default same as host application)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_ConsoleTask">
<short>Tag for <link id="CreateNewProc"/> Pointer to console task (default same as host)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_WindowPtr">
<short>Tag for <link id="CreateNewProc"/> Window pointer (default same as host)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_HomeDir">
<short>Tag for <link id="CreateNewProc"/> home directory (Default current directory)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_CopyVars">
<short>Tag for <link id="CreateNewProc"/> boolean to copy local vars to new process (Default True)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Cli">
<short>Tag for <link id="CreateNewProc"/> create a CLI structure for new process (Default False)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Path">
<short>Tag for <link id="CreateNewProc"/> Path, only valid if an CLI process (default copy of host's)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_CommandName">
<short>Tag for <link id="CreateNewProc"/> command name, valid only for CLI process</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Arguments">
<short>Tag for <link id="CreateNewProc"/> pointer to argument string (Default empty string)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_NotifyOnDeath">
<short>Tag for <link id="CreateNewProc"/> Inform the host when prcess died (Default False) (not working?)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_Synchronous">
<short>Tag for <link id="CreateNewProc"/> Do not return until process finished (Default False) (not working?)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_ExitCode">
<short>Tag for <link id="CreateNewProc"/> code to be called on process exit.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NP_ExitData">
<short>Tag for <link id="CreateNewProc"/> argument for <link id="NP_ExitCode"/> (default <var>nil</var>)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ADO_Dummy">
<short>Tag for <link id="AllocDosObject"/> start of Tag range </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ADO_FH_Mode">
<short>Tag for <link id="AllocDosObject"/> sets up FH for mode</short>
<descr>for type DOS_FILEHANDLE only, sets up FH for mode specified.
This can make a big difference for buffered files
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ADO_DirLen">
<short>Tag for <link id="AllocDosObject"/> size in bytes for current dir buffer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ADO_CommNameLen">
<short>Tag for <link id="AllocDosObject"/> size in bytes for command name buffer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ADO_CommFileLen">
<short>Tag for <link id="AllocDosObject"/> size in bytes for command file buffer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ADO_PromptLen">
<short>Tag for <link id="AllocDosObject"/> size in bytes for the prompt buffer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AbortPkt">
<short>Aborts an asynchronous packet, if possible.</short>
<descr><p>This function does currently nothing. You can use WaitForChar()
to poll for characters from an interactive handler.</p>
<p>
The planned purpose of this function is:
Tries to abort an asynchronous packet. There is no guarantee
that this succeeds. You must wait with WaitPkt() for the packet
to return before you can reuse or deallocate it.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="AbortPkt.Port">
<short>The message port to where the packet was sent.</short>
</element>

<!-- argument Visibility: default -->
<element name="AbortPkt.Pkt">
<short>The packet to be aborted.</short>
</element>

<!-- function Visibility: default -->
<element name="AddBuffers">
<short>Changes the number of buffers for a filesystem</short>
<descr><p>Add or remove cache memory to/from a filesystem. The amount of memory
per cache buffer and the limit depends on the filesystem.</p>
<ul>
<li><link id="DosTrue"/> on success (<link id="IoErr">IoErr()</link> gives the actual number of buffers).</li>
<li><link id="DosFalse"/> on error (<link id="IoErr">IoErr()</link> gives the error code).</li>
</ul><p>
Some old filesystems return the actual buffer size. See the example
for a workaround for that case.</p>
<p><b>Example:</b></p>
<code>
Res1 := AddBuffers('df0:', 10);
Res2 := IoErr();
if (res1 &lt;&gt; DosFalse) and (res1 &lt;&gt; DosTrue) then
begin
  Res2 := Res1;
  Res1 := DosTrue;
end;
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="IoErr"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddBuffers.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AddBuffers.DeviceName">
<short>DOS device name (with trailing ':').</short>
</element>

<!-- argument Visibility: default -->
<element name="AddBuffers.NumbBuffers">
<short>Number of buffers to add. May be negative for decreasing.</short>
</element>

<!-- function Visibility: default -->
<element name="AddDosEntry">
<short>Add a Dos List entry to the lists</short>
<descr>Adds a given dos list entry to the DOS list. Automatically
locks the list for writing. There may be not more than one device
or assign node of the same name. There are no restrictions on
volume nodes except that the time stamps must differ.
</descr>
<errors>
</errors>
<seealso>
<link id="RemDosEntry"/>
<link id="FindDosEntry"/>
<link id="NextDosEntry"/>
<link id="MakeDosEntry"/>
<link id="FreeDosEntry"/>
<link id="LockDosList"/>
<link id="AttemptLockDosList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddDosEntry.Result">
<short><link id="DosTrue"/> if all went well.
<link id="DosFalse"/>for errors; <link id="IoErr">IoErr()</link> will return additional error code.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddDosEntry.DList">
<short>Pointer to DOS list entry.</short>
</element>

<!-- function Visibility: default -->
<element name="AddPart">
<short>Appends a file/dir to the end of a path</short>
<descr>This functions adds a file, directory or other path name to a
directory path. It will take into account any pre-existing
separator characters (':','/'). If filename is an absolute path it will replace
the current value of dirname.
</descr>
<errors>
</errors>
<seealso>
<link id="FilePart"/>
<link id="PathPart"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddPart.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AddPart.dirname">
<short>The path to add a file/directory name to.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddPart.filename">
<short>The filename or directory name to add. May be a relative
       pathname from the current directory. (example: foo/bar).
       Can deal with leading '/'(s), indicating one directory up
       per '/', or with a ':', indicating it's relative to the
       root of the appropriate volume.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddPart.size">
<short>size in bytes of the space allocated for dirname. Must <b>not</b> be 0.</short>
</element>

<!-- function Visibility: default -->
<element name="AddSegment">
<short>Adds a resident segment to the resident list</short>
<descr><p>
Adds a program segment to the system resident list. You can later
use these segments to run programs.</p>
<p>
The type field determines the type of resident
program. Normal programs should have type >= 0, system segments
should have type = <link id="CMD_SYSTEM"/>.</p>
<p>
Note that all other values of type are reserved.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FindSegment"/>
<link id="RemSegment"/>
<link id="LoadSeg"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddSegment.Result">
<short>&lt;&gt; 0 = success, 0 = Error</short>
</element>

<!-- argument Visibility: default -->
<element name="AddSegment.Name">
<short>Name of the segment. This is used by <link id="FindSegment">FindSegment()</link>. Will be copied.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddSegment.seg">
<short>Segment to add.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddSegment.Type_">
<short>What type of segment (initial use count). (CMD_*)</short>
</element>

<!-- function Visibility: default -->
<element name="AllocDosObject">
<short>Creates a dos object</short>
<descr><p>
  Create a dos objects of a given type, initializes it, and returns it
  to you.  Note the DOS_STDPKT returns a pointer to the sp_Pkt of the
  structure.This memory has to be freed with <link id="FreeDosObject">FreeDosObject()</link>.</p>
<p>
  This function may be called by a task for all types and tags DOS_* and ADO_*.
  Any future types or tags will be documented as to whether a task may use them.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeDosObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AllocDosObject.Result">
<short>Pointer to the object or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObject.Type_">
<short>Type of object requested</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObject.Tags">
<short>Pointer to taglist with additional information (DOS_* and ADO_*)</short>
</element>

<!-- function Visibility: default -->
<element name="AssignAdd">
<short>Adds a lock to an assign for multi-directory assigns</short>
<descr><p>
  Adds a lock to an assign, making or adding to a multi-directory
  assign.  Note that this only will succeed on an assign created with
  <link id="AssignLock">AssignLock()</link>, or an assign created with
  <link id="AssignLate">AssignLate()</link> which has been
  resolved (converted into a <link id="AssignLock">AssignLock()</link>-assign).</p>
<p>
  NOTE: you should not use the lock in any way after making this call
  successfully.  It becomes the part of the assign, and will be unlocked
  by the system when the assign is removed.  If you need to keep the
  lock, pass a lock from <link id="DupLock">DupLock()</link> to <link id="AssignLock">AssignLock()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="AssignLock"/>
<link id="AssignPath"/>
<link id="AssignLate"/>
<link id="DupLock"/>
<link id="RemAssignList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AssignAdd.Result">
<short>If False the adding failed, lock is not unlocked. <link id="IoErr">IoErr()</link> gives more information.</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignAdd.Name">
<short>Name of the assign (without trailing ':').</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignAdd.Lock">
<short>Lock associated with the assigned name</short>
</element>

<!-- function Visibility: default -->
<element name="AssignLate">
<short>Creates an assignment to a specified path later</short>
<descr>Create an assign for the given name, which will be resolved upon the
first reference to it. If this succeeds (i.e. the path exists and
can be locked) it will be turned into an <link id="AssignLock">AssignLock()</link> type assign.
This way you can create assigns to unmounted volumes which will only
be requested when accessed.
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="AssignAdd"/>
<link id="AssignPath"/>
<link id="AssignLock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AssignLate.Result">
<short><link id="IoErr">IoErr()</link> gives more information of fail</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignLate.Name">
<short>Name of device to be assigned (without trailing ':')</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignLate.Path">
<short>Name of late assignment to be resolved on the first reference.
</short>
</element>

<!-- function Visibility: default -->
<element name="AssignLock">
<short>Creates an assignment to a locked object</short>
<descr><p>
  Sets up an assign of a name to a given lock.  Passing <var>nil</var> for a lock
  cancels any outstanding assign to that name.  If an assign entry of
  that name is already on the list, this routine replaces that entry.  If
  an entry is on the list that conflicts with the new assign, then a
  failure code is returned.</p>
<p>
  NOTE: you should not use the lock in any way after making this call
  successfully.  It becomes the part of the assign, and will be unlocked
  by the system when the assign is removed.  If you need to keep the
  lock, pass a lock from <link id="DupLock">DupLock()</link> to <link id="AssignLock">AssignLock()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="AssignAdd"/>
<link id="AssignPath"/>
<link id="AssignLate"/>
<link id="DupLock"/>
<link id="RemAssignList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AssignLock.Result">
<short>On failure, the lock is not unlocked. <link id="IoErr">IoErr()</link> gives more information.</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignLock.Name">
<short>Name of device to assign lock to (without trailing ':')</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignLock.Lock">
<short>Lock associated with the assigned name</short>
</element>

<!-- function Visibility: default -->
<element name="AssignPath">
<short>Creates an assignment to a specified path</short>
<descr><p>
  Sets up a assignment that is expanded upon EACH reference to the name.
  This is implemented through a new device list type.
  The path (a string) would be attached to the node. When
  the name is referenced (<link id="DosOpen"/>("FOO:xyzzy"...), the string will be used
  to determine where to do the open.  No permanent lock will be part of
  it.  For example, you could <var>AssignPath()</var> c2: to df2:c, and references
  to c2: would go to df2:c, even if you change disks.</p>
<p>
  The other major advantage is assigning things to unmounted volumes,
  which will be requested upon access (useful in startup sequences).</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AssignPath.Result">
<short><link id="IoErr">IoErr()</link> gives more information of fail</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignPath.Name">
<short>Name of device to be assigned (without trailing ':')</short>
</element>

<!-- argument Visibility: default -->
<element name="AssignPath.Path">
<short>Name of late assignment to be resolved at each reference</short>
</element>

<!-- function Visibility: default -->
<element name="AttemptLockDosList">
<short>Attempt to lock the Dos Lists for use</short>
<descr>Tries to get a lock on some of the dos lists. If all went
well a handle is returned that can be used for <link id="FindDosEntry">FindDosEntry()</link>.
Don't try to busy wait until the lock can be granted - use
<link id="LockDosList">LockDosList()</link> instead.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AttemptLockDosList.Result">
<short>Pointer to the beginning of the list or <var>nil</var>.  Not a valid node its a pseudo element!</short>
</element>

<!-- argument Visibility: default -->
<element name="AttemptLockDosList.Flags">
<short>Flags stating which types of nodes you want to lock. (LDF_*)</short>
</element>

<!-- function Visibility: default -->
<element name="ChangeMode">
<short>Change the current mode of a lock or filehandle</short>
<descr>This allows you to attempt to change the mode in use by a lock or
  filehandle.  For example, you could attempt to turn a shared lock
  into an exclusive lock.  The handler may well reject this request.
  Warning: if you use the wrong type for the object, the system may
  crash.
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ChangeMode.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeMode.Type_">
<short>Either <link id="CHANGE_FH"/> or <link id="CHANGE_LOCK"/></short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeMode.Object_">
<short>A lock or filehandle</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeMode.NewMode">
<short>The new mode you want</short>
</element>

<!-- function Visibility: default -->
<element name="CheckSignal">
<short>Checks for break signals</short>
<descr>Checks the current task to see if any of the signals specified in
the mask have been set. The mask of all signals which were set is
returned. The signals specified in the mask will be cleared.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CheckSignal.Result">
<short>The mask of all signals which were set. (SIGBREAKF_*)
</short>
</element>

<!-- argument Visibility: default -->
<element name="CheckSignal.Mask">
<short>The signal mask to check. ()SIGBREAKF_*)</short>
</element>

<!-- function Visibility: default -->
<element name="Cli">
<short>Returns a pointer to the CLI structure of the process</short>
<descr><p>Returns a pointer to the CLI structure of the current process, or <var>nil</var>
if the process has no CLI structure.  </p>
<p>
Note: There is no CLI structure if started from WB, but also in shell it can be that it has no CLI structure, for example if it is started by an other program which didn't set the structure (famous example "make")
</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Cli.Result">
<short>Pointer to the CLI structure, or <var>nil</var> </short>
</element>

<!-- function Visibility: default -->
<element name="CliInitNewcli">
<short>Set up a process to be a shell using a startup packet.</short>
<descr><p>
  This function initializes a process and CLI structure for a new
  shell, from parameters in an initial packet passed by the system
  (NewShell or NewCLI, etc).  The format of the data in the packet
  is purposely not defined.  The setup includes all the normal fields
  in the structures that are required for proper operation (current
  directory, paths, input streams, etc).</p>
<p>
  It returns a set of flags containing information about what type
  of shell invocation this is.</p>
<p>
  Definitions for the values of fn:</p>
<dl>
  <dt>Bit 31</dt><dd>Set to indicate flags are valid</dd>
  <dt>Bit  3</dt><dd>Set to indicate asynch system call</dd>
  <dt>Bit  2</dt><dd>Set if this is a <link id="SystemTagList">SystemTagList()</link> call</dd>
  <dt>Bit  1</dt><dd>Set if user provided input stream</dd>
  <dt>Bit  0</dt><dd>Set if RUN provided output stream</dd>
</dl>
<p>
  If Bit 31 is 0, then you must check <link id="IoErr">IoErr()</link> to determine if an error
  occurred.  If <link id="IoErr">IoErr()</link> returns a pointer to your process, there has
  been an error, and you should clean up and exit.  The packet will
  have already been returned by <var>CliInitNewcli()</var>.  If it isn't a pointer
  to your process and Bit 31 is 0, reply the packet immediately.
  (Note: this is different from what you do for <link id="CliInitRun">CliInitRun()</link>.)</p>
<p>
  This function is very similar to <link id="CliInitRun">CliInitRun()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CliInitRun"/>
<link id="ReplyPkt"/>
<link id="WaitPkt"/>
<link id="IoErr"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CliInitNewcli.Result">
<short>Flags or a Pointer</short>
</element>

<!-- argument Visibility: default -->
<element name="CliInitNewcli.dp">
<short>startup arguments that were passed to the shell
            If NULL, defaults will be used</short>
</element>

<!-- function Visibility: default -->
<element name="CliInitRun">
<short>Set up a process to be a shell from initial packet
</short>
<descr><p>
  This function initializes a process and CLI structure for a new
  shell, from parameters in an initial packet passed by the system
  (Run, <link id="SystemTagList">SystemTagList()</link>, <link id="Execute">Execute()</link>)).  The format of the data in the packet
  is purposely not defined.  The setup includes all the normal fields
  in the structures that are required for proper operation (current
  directory, paths, input streams, etc).</p>
<p>
  It returns a set of flags containing information about what type
  of shell invocation this is.</p>
<p>
  Definitions for the values of fn:</p>
<dl>
  <dt>Bit 31</dt><dd>Set to indicate flags are valid</dd>
  <dt>Bit  3</dt><dd>Set to indicate asynch system call</dd>
  <dt>Bit  2</dt><dd>Set if this is a <link id="SystemTagList">SystemTagList()</link> call</dd>
  <dt>Bit  1</dt><dd>Set if user provided input stream</dd>
  <dt>Bit  0</dt><dd>Set if RUN provided output stream</dd>
</dl>
<p>
  If Bit 31 is 0, then you must check <link id="IoErr">IoErr()</link> to determine if an error
  occurred.  If <link id="IoErr">IoErr()</link> returns a pointer to your process, there has
  been an error, and you should clean up and exit. The packet will
  have already been returned by <link id="CliInitNewcli">CliInitNewcli()</link>.  If it isn't a pointer
  to your process and Bit 31 is 0, you should wait before replying
  the packet until after you've loaded the first command (or when you
  exit).  This helps avoid disk "gronking" with the Run command.
  (Note: this is different from what you do for <link id="CliInitNewcli">CliInitNewcli()</link>).)</p>
<p>
  If Bit 31 is 1, then if Bit 3 is one, ReplyPkt() the packet
  immediately (Asynch <link id="SystemTagList">SystemTagList()</link>), otherwise wait until your shell exits
  (Sync <link id="SystemTagList">SystemTagList()</link>, <link id="Execute">Execute()</link>).
  (Note: this is different from what you do for <link id="CliInitNewcli">CliInitNewcli()</link>.)</p>
<p>
  This function is very similar to <link id="CliInitNewcli">CliInitNewcli()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CliInitNewcli"/>
<link id="ReplyPkt"/>
<link id="WaitPkt"/>
<link id="IoErr"/>
<link id="SystemTagList"/>
<link id="Execute"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CliInitRun.Result">
<short>Flags or a Pointer</short>
</element>

<!-- argument Visibility: default -->
<element name="CliInitRun.dp">
<short>startup arguments specified as a packet</short>
</element>

<!-- function Visibility: default -->
<element name="CompareDates">
<short>Compares two datestamps</short>
<descr>Compares two times for relative magnitide.  &lt;0 is returned if date1 is
  later than date2, 0 if they are equal, or &gt;0 if date2 is later than
  date1.  NOTE: this is <b>not</b> the same ordering as strcmp!
</descr>
<errors>
</errors>
<seealso>
<link id="DateStamp"/>
<link id="DOSStrToDate"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CompareDates.Result">
<short>&lt;0, 0, or &gt;0 based on comparison of two date stamps</short>
</element>

<!-- argument Visibility: default -->
<element name="CompareDates.date1">
<short>DateStamps to compare</short>
</element>

<!-- argument Visibility: default -->
<element name="CompareDates.date2">
<short>DateStamps to compare</short>
</element>

<!-- function Visibility: default -->
<element name="DOSCreateDir">
<short>Create a new directory</short>
<descr>CreateDir() creates a new directory with the specified name. An error
  is returned if it fails.  Directories can only be created on
  devices which support them, e.g. disks.  Returns an
  exclusive lock on the new directory if it succeeds.
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="UnLock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSCreateDir.Result">
<short>Pointer to a lock if success, if not <var>nil</var> <link id="IoErr">IoErr()</link> gives additional information in that case.
</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSCreateDir.Name">
<short>Name of new directory</short>
</element>

<!-- function Visibility: default -->
<element name="CreateNewProc">
<short>Create a new process from taglist</short>
<descr>
  <p>
  You must specify one of NP_Seglist or NP_Entry.  NP_Seglist takes a
  seglist (as returned by <link id="LoadSeg">LoadSeg()</link>).  <link id="NP_Entry"/> takes a function
  pointer for the routine to call.</p>
<p>
  There are many options, as you can see by examining dos/dostags.h.
  The defaults are for a non-CLI process, with copies of your
  CurrentDir, HomeDir (used for PROGDIR:), priority, consoletask,
  windowptr, and variables.  The input and output filehandles default
  to opens of NIL:, stack to 4000, and others as shown in dostags.h.
  This is a fairly reasonable default setting for creating threads,
  though you may wish to modify it (for example, to give a descriptive
  name to the process.)</p>
<p>
  <var>CreateNewProc()</var> is callable from a task, though any actions that
  require doing Dos I/O (<link id="DupLock">DupLock()</link> of currentdir, for example) will not
  occur.</p>
<p>
  NOTE: if you call <var>CreateNewProc()</var> with both <link id="NP_Arguments"/>, you must
  not specify an <link id="NP_Input"/> of <var>nil</var>.  When <link id="NP_Arguments"/> is specified, it
  needs to modify the input filehandle to make <link id="ReadArgs">ReadArgs()</link> work properly.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CreateNewProc.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="CreateNewProc.Tags">
<short>Information on the new process as tags (NP_*).
</short>
</element>

<!-- function Visibility: default -->
<element name="CreateProc">
<short>Create a new process</short>
<descr><p>
  <var>CreateProc()</var> creates a new process of name 'name'.
  Processes are a superset of exec tasks.</p>
<p>
  A seglist, as returned by <link id="LoadSeg">LoadSeg()</link>, is passed as 'seglist'.
  This represents a section of code which is to be run as a new
  process. The code is entered at the first hunk in the segment list,
  which should contain suitable initialization code or a jump to
  such.  A process control structure is allocated from memory and
  initialized.</p>
<p>
  The size of the root stack upon activation is passed as
  'stackSize'.  'pri' specifies the required priority of the new
  process.  The result will be the process msgport address of the new
  process, or <var>nil</var> if the routine failed.  The argument 'name'
  specifies the new process name.  A <var>nil</var> return code indicates
  error.</p>
<p>
  The seglist passed to <var>CreateProc()</var> is not freed when it exits; it
  is up to the parent process to free it, or for the code to unload itself.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CreateNewProc"/>
<link id="LoadSeg"/>
<link id="UnLoadSeg"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CreateProc.Result">
<short>Pointer to the new Process messageport or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="CreateProc.Name">
<short>Name of Process</short>
</element>

<!-- argument Visibility: default -->
<element name="CreateProc.pri">
<short>Priority for the process</short>
</element>

<!-- argument Visibility: default -->
<element name="CreateProc.segList">
<short>Pointer to a seglist to run</short>
</element>

<!-- argument Visibility: default -->
<element name="CreateProc.stackSize">
<short>Initial Stacksize for the process</short>
</element>

<!-- function Visibility: default -->
<element name="CurrentDir">
<short>Make a directory lock the current directory</short>
<descr><p>
  <var>CurrentDir()</var> causes a directory associated with a lock to be made
  the current directory.  The old current directory lock is returned.</p>
<p>
  A value of <var>nil</var> is a valid result here, this <var>nil</var> lock represents the
  root of file system that you booted from.</p>
<p>
  Any call that has to <link id="DosOpen">DosOpen()</link> or <link id="Lock">Lock()</link> files (etc.) requires that  the current directory be a valid lock or <var>nil</var>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="UnLock"/>
<link id="DosOpen"/>
<link id="DupLock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CurrentDir.Result">
<short>Pointer to a lock</short>
</element>

<!-- argument Visibility: default -->
<element name="CurrentDir.Lock">
<short>Lock to directory should become new current directory</short>
</element>

<!-- procedure Visibility: default -->
<element name="DateStamp">
<short>Fills the structure with the current time. Time is measured from
1. Jan. 1978.</short>
<descr>
  <var>DateStamp()</var> takes a structure of three longwords that is set to the
  current time.  The first element in the vector is a count of the
  number of days.  The second element is the number of minutes elapsed
  in the day.  The third is the number of ticks elapsed in the current
  minute.  A tick happens 50 times a second. <var>DateStamp()</var> ensures that
  the day and minute are consistent.  All three elements are zero if
  the date is unset.
</descr>
<errors>
</errors>
<seealso>
<link id="DOSStrToDate"/>
<link id="SetFileDate"/>
<link id="CompareDates"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DateStamp.date">
<short>Pointer to recieve the timing information.</short>
</element>

<!-- function Visibility: default -->
<element name="DOSDeleteFile">
<short>Delete a file or directory
</short>
<descr>This attempts to delete the file or directory specified by <var>name</var>.
  An error is returned if the deletion fails. Note that all the files
  within a directory must be deleted before the directory itself can
  be deleted.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSDeleteFile.Result">
<short>If failed <link id="ioErr">IoErr()</link> gives detailed error message.</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSDeleteFile.Name">
<short>Name of file or directory to delete.</short>
</element>

<!-- function Visibility: default -->
<element name="DeleteVar">
<short>Deletes a local or environment variable</short>
<descr><p>
Deletes a local or environment variable.</p>
<p>
The default is to delete a local variable if one was found,
or to delete a global environmental variable otherwise.</p>
<p>
A global environmental variable will only be deleted for the
type <link id="LV_VAR"/>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetVar"/>
<link id="SetVar"/>
<link id="FindVar"/>
<link id="DOSDeleteFile"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DeleteVar.Result">
<short>If not 0, the variable was sucessfully deleted, 0 indicates failure.</short>
</element>

<!-- argument Visibility: default -->
<element name="DeleteVar.Name">
<short>Pointer to an variable name. Note variable names follow filesystem syntax and semantics.</short>
</element>

<!-- argument Visibility: default -->
<element name="DeleteVar.Flags">
<short>combination of type of var to delete (low 8 bits), and
     flags to control the behavior of this routine.  Currently
     defined flags include: <link id="GVF_LOCAL_ONLY"/>  - delete a local (to your process) variable.
     <link id="GVF_GLOBAL_ONLY"/> - delete a global environment variable.
     The default is to delete a local variable if found, otherwise
     a global environment variable if found (only for <link id="LV_VAR"/>).</short>
</element>

<!-- function Visibility: default -->
<element name="DeviceProc">
<short>Return the process MsgPort of specific I/O handler</short>
<descr><p>
<var>DeviceProc()</var> is an obsolete function that returns the
MsgPort responsible for a DOS device.</p>
<p>
<var>DeviceProc()</var> will fail if you ask for the MsgPort of a device
created with <link id="AssignPath">AssignPath()</link> as there is no process to return.
If the device requested is an assign, the <link id="IoErr">IoErr()</link> will contain
the Lock to the directory (the function will return the device
on which the lock is set).</p>
<p>
You should really use <link id="GetDeviceProc">GetDeviceProc()</link>, as that function
returns a more useful structure (TDevProc), that will
persist until <link id="FreeDeviceProc">FreeDeviceProc()</link> is called on it.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetDeviceProc"/>
<link id="FreeDeviceProc"/>
<link id="DupLock"/>
<link id="UnLock"/>
<link id="Examine"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DeviceProc.Result">
<short>A message port or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="DeviceProc.Name">
<short>The name of the DOS device, INCLUDING the ':'</short>
</element>

<!-- function Visibility: default -->
<element name="DoPkt">
<short>Send a dos packet and wait for reply</short>
<descr>Send a dos packet to a filesystem and wait for the action to complete.
Callable from a task.
This function should NOT be used; it's only here for AmigaOS compatibility.
</descr>
<errors>
</errors>
<seealso>
<link id="AllocDosObject"/>
<link id="FreeDosObject"/>
<link id="SendPkt"/>
<link id="WaitPkt"/>
<link id="CreateNewProc"/>
<link id="AbortPkt"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoPkt.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.Port">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.action">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.arg1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.arg2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.arg3">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.arg4">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt.arg5">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="DOSClose">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSClose.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSClose.file_">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="DOSDelay">
<short>Delay a process for a specified time
</short>
<descr>The argument <var>ticks</var> specifies how many ticks (50 per second) to
  wait before returning control.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DOSDelay.timeout">
<short>The minimum time to wait in ticks (1/50 seconds)</short>
</element>

<!-- procedure Visibility: default -->
<element name="DOSExit">
<short>Instantly terminate the program.
</short>
<descr>Calling this function bypasses normal termination sequence of your program.
Automatically opened libraries will not be closed, destructors will not be
called, etc. Do this only if you really know what are you doing. It's not
advised to use this function at all.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DOSExit.returnCode">
<short>Process' return code.</short>
</element>

<!-- function Visibility: default -->
<element name="DOSFlush">
<short>Flushes buffers for a buffered filehandle</short>
<descr><p>
Flushes any pending writes on the file. If the file was used
for input and there is still some data to read it tries to
seek back to the expected position.</p>
<p>On Amiga calling <var>DosFlush()</var> from different tasks on the same file handle
is serialised. This means that most of the time it is possible to
do I/O in one task to a file handle where <var>DosFlush()</var> is being called
in another task on that file handle.
No multi-thread safety is guaranteed though and data may be lost if
I/O is done in parallel from different tasks on the same file handle.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSFlush.Result">
<short>0 on error. <link id="IoErr">IoErr()</link> gives additional information
in that case.</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSFlush.File_">
<short>Filehandle to flush.</short>
</element>

<!-- function Visibility: default -->
<element name="DOSInput">
<short>Identify the program's initial input file handle</short>
<descr><var>Input()</var> is used to identify the initial input stream allocated when
  the program was initiated.  Never close the filehandle returned by Input!
</descr>
<errors>
</errors>
<seealso>
<link id="DosOutput"/>
<link id="SelectInput"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSInput.Result">
<short><var>Nil</var> if no current input stream defined.</short>
</element>

<!-- function Visibility: default -->
<element name="DOSOpen">
<short>Open a file for input or output</short>
<descr><p>
  The named file is opened and a file handle returned.  If the
  <var>accessMode</var> is <link id="MODE_OLDFILE"/>, an existing file is opened for reading
  or writing. If the value is <link id="MODE_NEWFILE"/>, a new file is created for
  writing. <link id="MODE_READWRITE"/> opens a file with an shared lock, but
  creates it if it didn't exist.</p>
<p>
  The <var>name</var> can be a filename (optionally prefaced by a device
  name), a simple device such as 'NIL:', a window specification such as
  'CON:' or 'RAW:' followed by window parameters, or '*', representing the
  current window.</p>
<p>
  If the file cannot be opened for any reason, the value returned
  will be zero, and a secondary error code will be available by
  calling the routine <link id="IoErr">IoErr()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DosClose"/>
<link id="ChangeMode"/>
<link id="NameFromFH"/>
<link id="ParentOfFH"/>
<link id="ExamineFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSOpen.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSOpen.Name">
<short>Name of file to opem</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSOpen.accessMode">
<short>Access mode for file (MODE_*)</short>
</element>

<!-- function Visibility: default -->
<element name="DOSOutput">
<short>Identify the programs' initial output file handle
</short>
<descr><var>Output()</var> is used to identify the initial output stream allocated
  when the program was initiated.  Never close the filehandle returned
  by <var>Output()</var>.
</descr>
<errors>
</errors>
<seealso>
<link id="DosInput"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSOutput.Result">
<short><var>Nil</var> if no current output stream defined.</short>
</element>

<!-- function Visibility: default -->
<element name="DOSRead">
<short>Read bytes of data from a file</short>
<descr><p>
  Data can be copied using a combination of <var>DOSRead()</var> and <link id="DosWrite">DOSWrite()</link>.
  <var>DosRead()</var> reads bytes of information from an opened file (represented
  here by the argument <var>file</var>) into the buffer given. The argument
  <var>length</var> is the length of the buffer given.</p>
<p>
  The value returned is the length of the information actually read.
  So, when <var>result</var> is greater than 0, the value of
  <var>result</var> is the the number of characters read. Usually <var>DosRead()</var>
  will try to fill up your buffer before returning. A value of 0
  means that end-of-file has been reached. Errors are indicated by a
  value of -1.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DosOpen"/>
<link id="DosClose"/>
<link id="DosWrite"/>
<link id="DosSeek"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSRead.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSRead.file_">
<short>File handle</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSRead.buffer">
<short>Pointer to the buffer for the data</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSRead.length">
<short>number of bytes to read. The filesystem is
advised to try to fulfill the request as good as possible.
</short>
</element>

<!-- function Visibility: default -->
<element name="DOSRename">
<short>Rename a directory or file</short>
<descr><p>
  Rename() attempts to rename the file or directory specified as
  <var>oldName</var> with the name <var>newName</var>. If the file or directory
  <var>newName</var> exists, <var>Rename()</var> fails and returns an error. Both
  <var>oldName</var> and the <var>newName</var> can contain a directory specification.
  In this case, the file will be moved from one directory to another.</p>
<p>
  Note: it is impossible to <var>Rename()</var> a file from one volume to
  another.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSRename.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSRename.oldName">
<short>File to rename.</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSRename.newName">
<short>New name for the file.</short>
</element>

<!-- function Visibility: default -->
<element name="DOSSeek">
<short>Set the current position for reading and writing</short>
<descr><p>
  <var>DosSeek()</var> sets the read/write cursor for the file <var>file</var> to the
  position 'position'. This position is used by both <link id="DosRead">DosRead()</link> and
  <link id="DosWrite">DosWrite()</link> as a place to start reading or writing. The result is the
  current absolute position in the file, or -1 if an error occurs, in
  which case IoErr() can be used to find more information. <var>mode</var> can
  be <link id="OFFSET_BEGINNING"/> (Start seek from file start), <link id="OFFSET_CURRENT"/> (start seek from current position) or <link id="OFFSET_END"/> (start seek from end of file). It is used to
  specify the relative start position. For example, 20 from current
  is a position 20 bytes forward from current, -20 is 20 bytes back
  from current.</p>
<p>
  So that to find out where you are, seek 0 from current. The end
  of the file is a <var>Seek()</var> positioned by 0 from end. You cannot
  <var>Seek()</var> beyond the end of a file.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DosRead"/>
<link id="DosWrite"/>
<link id="SetFileSize"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSSeek.Result">
<short>Returns the position before the seek.</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSSeek.file_">
<short>Pointer to file handle.</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSSeek.position">
<short>Value to seek (can be also negative for <link id="OFFSET_CURRENT"/> or <link id="OFFSET_END"/>)</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSSeek.Mode">
<short>Start of Seek (OFFSET_*)</short>
</element>

<!-- function Visibility: default -->
<element name="DOSWrite">
<short>Write bytes of data to a file</short>
<descr><var>DosWrite()</var> writes bytes of data to the opened file <var>file</var>. <var>length</var>
  indicates the length of data to be transferred; <var>buffer</var> is a
  pointer to the buffer. The value returned is the length of
  information actually written. So, when <var>length</var> is greater than
  zero, the result is the number of characters written.
  Errors are indicated by a value of -1.
</descr>
<errors>
</errors>
<seealso>
<link id="DosRead"/>
<link id="DosSeek"/>
<link id="DosOpen"/>
<link id="DosClose"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSWrite.Result">
<short>Number of bytes written, -1 for error.</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSWrite.file_">
<short>File handle</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSWrite.buffer">
<short>Pointer to a buffer to write to file</short>
</element>

<!-- argument Visibility: default -->
<element name="DOSWrite.length">
<short>Number of bytes to write. The filesystem is
advised to try to fulfill the request as good as possible.</short>
</element>

<!-- function Visibility: default -->
<element name="DupLock">
<short>Duplicate a lock</short>
<descr><p>
  <var>DupLock()</var> is passed a shared filing system lock.  This is the <b>only</b>
  way to obtain a duplicate of a lock... simply copying is not
  allowed.</p>
<p>
  Another lock to the same object is then returned.  It is not
  possible to create a copy of a exclusive lock.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="UnLock"/>
<link id="DupLockFromFH"/>
<link id="ParentOfFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DupLock.Result">
<short>Result 0 indicates an error.</short>
</element>

<!-- argument Visibility: default -->
<element name="DupLock.Lock">
<short>Lock to copy</short>
</element>

<!-- function Visibility: default -->
<element name="DupLockFromFH">
<short>Gets a lock on an open file</short>
<descr>Obtain a lock on the object associated with fh.  Only works if the
  file was opened using a non-exclusive mode.  Other restrictions may be
  placed on success by the filesystem.
</descr>
<errors>
</errors>
<seealso>
<link id="DupLock"/>
<link id="Lock"/>
<link id="UnLock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DupLockFromFH.Result">
<short>Obtained lock or 0 for failure</short>
</element>

<!-- argument Visibility: default -->
<element name="DupLockFromFH.Lock">
<short>Opened file for which to obtain the lock
</short>
</element>



<!-- procedure Visibility: default -->
<element name="EndNotify">
<short>Ends a notification request</short>
<descr>Removes a notification request.  Safe to call even if <link id="StartNotify">StartNotify()</link>
  failed.  For <link id="NRF_SEND_MESSAGE"/>, it searches your port for any messages
  about the object in question and removes and replies them before
  returning.
</descr>
<errors>
</errors>
<seealso>
<link id="StartNotify"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="EndNotify.notify">
<short>a structure passed to <link id="StartNotify">StartNotify()</link>
</short>
</element>

<!-- function Visibility: default -->
<element name="ErrorReport">
<short>Displays a Retry/Cancel requester for an error </short>
<descr><p>
  Based on the request type, this routine formats the appropriate
  requester to be displayed.  If the code is not understood, it returns
  <link id="DOSTRUE"/> immediately.  Returns <link id="DOSTRUE"/> if the user selects CANCEL or
  if the attempt to put up the requester fails, or if the process
  <link id="TProcess">pr_WindowPtr</link> is -1.  Returns <link id="DOSFALSE"/> if the user selects Retry.  The
  routine will retry on DISKINSERTED for appropriate error codes.
  These return values are the opposite of what AutoRequest returns.</p>
<p>
  Note: this routine sets <link id="IoErr">IoErr()</link> to code before returning.</p>
<p>
  Error codes to put a requester up for. Current valid error codes are:
    <link id="ERROR_DISK_NOT_VALIDATED"/>,
    <link id="ERROR_DISK_WRITE_PROTECTED"/>,
    <link id="ERROR_DISK_FULL"/>,
    <link id="ERROR_DEVICE_NOT_MOUNTED"/>,
    <link id="ERROR_NOT_A_DOS_DISK"/>,
    <link id="ERROR_NO_DISK"/>,
    <link id="ABORT_DISK_ERROR"/>,
    <link id="ABORT_BUSY"/></p>
<p>
   Valid Request types:</p>
   <dl>
   <dt><link id="REPORT_LOCK"/></dt><dd> arg1 is a lock.</dd>
   <!--dt><link id="REPORT_FH"/></dt><dd> arg1 is a filehandle.</li-->
   <dt><link id="REPORT_VOLUME"/></dt><dd> arg1 is a volumenode.</dd>
   <dt><link id="REPORT_INSERT"/></dt><dd> arg1 is the string for the volumename</dd>
   </dl>
</descr>
<errors>
</errors>
<seealso>
<link id="Fault"/>
<link id="IoErr"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ErrorReport.Result">
<short>Cancel/Retry indicator (0 means Retry)</short>
</element>

<!-- argument Visibility: default -->
<element name="ErrorReport.code">
<short>Error code to put a requester up for.</short>
</element>

<!-- argument Visibility: default -->
<element name="ErrorReport.Type_">
<short>Request type</short>
</element>

<!-- argument Visibility: default -->
<element name="ErrorReport.arg1">
<short>Variable parameter (see type)</short>
</element>

<!-- argument Visibility: default -->
<element name="ErrorReport.device">
<short>Optional handler task address (obsolete!)</short>
</element>

<!-- function Visibility: default -->
<element name="ExAll">
<short>Examine an entire directory</short>
<descr><p>
  Lock must be on a directory.  Size is the size of the buffer supplied.
  The buffer will be filled with (partial) ExAllData structures, as
  specified by the type field.</p>
<p>
  <link id="TExAllData">ed_Type</link> is a value from those shown below that determines which information is
  to be stored in the buffer.  Each higher value adds a new thing to the list
  as described in the table below: </p>
<dl>
  <dt><link id="ED_NAME"/></dt><dd> FileName</dd>
  <dt><link id="ED_TYPE"/></dt><dd> Type</dd>
  <dt><link id="ED_SIZE"/></dt><dd> Size in bytes</dd>
  <dt><link id="ED_PROTECTION"/></dt><dd> Protection bits</dd>
  <dt><link id="ED_DATE"/></dt><dd> 3 longwords of date</dd>
  <dt><link id="ED_COMMENT"/></dt><dd> Comment (will be <var>nil</var> if no comment)</dd>
  <dt><link id="ED_OWNER"/></dt><dd> Owner user-id and Group-id</dd>
</dl>
<p>
 Thus, <link id="ED_OWNER"/> gives only filenames, and <link id="ED_OWNER"/> gives everything.</p>
<p>
 The <link id="TExAllData">ed_Next</link> entry gives a pointer
 to the next entry in the buffer.  The last entry will have <var>nil</var> in <link id="TExAllData">ed_Next</link>.</p>
<p>
This is an incremental list meaning that if you specify <link id="ED_OWNER"/> you
will get <b>all</b> attributes!</p>
<p>
Filesystems that support <var>ExAll()</var> must support at least up to <link id="ED_COMMENT"/>.
If a filesystem doesn't support a particular type, <link id="ERROR_BAD_NUMBER"/> must be returned.
</p>
<dl>

<dt><link id="TExAllData">ed_Next</link></dt><dd> Pointer to the next entry in the buffer. The last entry
has a <var>nil</var> value for ed_Next.</dd>

<dt></dt><dd><b>The control structure have the following fields.</b></dd>

<dt><link id="TExAllControl">eac_Entries</link></dt><dd> the number of entries in the buffer after a call to <var>ExAll()</var>. Make sure that your code handles the case when eac_Entries
is 0 and <var>ExAll()</var> returns True.</dd>

<dt><link id="TExAllControl">eac_LastKey</link></dt><dd> Must be initialized to 0 before calling ExAll() for the first time.</dd>

<dt><link id="TExAllControl">eac_MatchString</link></dt><dd> If <var>nil</var> then information on all files will be returned. If non-<var>nil</var> it's interpreted as a pointer to a string
used for pattern matching which files to return information on. This string must have been parsed by
 <link id="ParsePatternNoCase">ParsePatternNoCase()</link>!</dd>

<dt><link id="TExAllControl">ac_MatchFunc</link></dt><dd> to a hook that will be called to decide if an entry should be included in the buffer. If <var>nil</var>, no
matching function will be called. The hook is called as follows</dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
<link id="ExAllEnd"/>
<link id="AllocDosObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ExAll.Result">
<short>An indicator of if <var>ExAll()</var> is done. If False is returned, either <var>ExAll()</var>
has completed in which case <link id="IoErr">IoErr()</link> is <link id="ERROR_NO_MORE_ENTRIES"/> or an
error occurred. If a True is returned <var>ExAll()</var> must be called
again until it returns False.</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAll.Lock">
<short>Lock on the directory to be examined</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAll.buffer">
<short>Buffer for the data that is returned (must be aligned)
which is filled with (partial) <link id="TExAllData"/> structures</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAll.size">
<short>Size of <var>buffer</var></short>
</element>

<!-- argument Visibility: default -->
<element name="ExAll.data">
<short>Type of the data to be returned</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAll.control">
<short>A control structure allocated by <link id="AllocDosObject">AllocDosObject()</link></short>
</element>

<!-- procedure Visibility: default -->
<element name="ExAllEnd">
<short>Stop an <link id="ExAll">ExAll()</link></short>
<descr>Stops an <link id="ExAll">ExAll()</link> on a directory before it hits
<link id="ERROR_NO_MORE_ENTRIES"/>.
  The full set of arguments that had been passed to <link id="ExAll">ExAll()</link> must be
  passed to <var>ExAllEnd()</var>, so it can handle filesystems that can't abort
  an <link id="ExAll">ExAll()</link> directly.
</descr>
<errors>
</errors>
<seealso>
<link id="ExAll"/>
<link id="AllocDosObject"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ExAllEnd.Lock">
<short>Lock on directory to be examined.</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAllEnd.buffer">
<short>Buffer for data returned (<b>must</b> be at least word-aligned,
      preferably long-word aligned).</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAllEnd.size">
<short>Size in bytes of <var>buffer</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAllEnd.data">
<short>Type of data to be returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="ExAllEnd.control">
<short>Control data structure (see notes above).  MUST have been
      allocated by <link id="AllocDosObject">AllocDosObject()</link>!</short>
</element>

<!-- function Visibility: default -->
<element name="Examine">
<short>Examine a directory or file associated with a lock</short>
<descr><p>
  <var>Examine()</var> fills in information in the <link id="TFileInfoBlock">TFileInfoBlock</link> concerning the file or directory associated with the lock. This information
  includes the name, size, creation date and whether it is a file or
  directory.  FileInfoBlock must be longword aligned. <var>Examine()</var> gives
  a return code of False if it fails.</p>
<p>
  You may make a local copy of the <link id="TFileInfoBlock">TFileInfoBlock</link>, as long as it is
  never passed to <link id="ExNext">ExNext()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="UnLock"/>
<link id="ExNext"/>
<link id="ExamineFH"/>
<link id="ExAll"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Examine.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Examine.Lock">
<short>Pointer to a Lock</short>
</element>

<!-- argument Visibility: default -->
<element name="Examine.fileInfoBlock">
<short>allocated File info Block</short>
</element>

<!-- function Visibility: default -->
<element name="ExamineFH">
<short>Gets information on an open file</short>
<descr>Examines a filehandle and returns information about the file in the
  FileInfoBlock.  There are no guarantees as to whether the fib_Size
  field will reflect any changes made to the file size it was opened,
  though filesystems should attempt to provide up-to-date information
  for it.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ExamineFH.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ExamineFH.fh">
<short>Filehandle you wish to examine</short>
</element>

<!-- argument Visibility: default -->
<element name="ExamineFH.fib">
<short>FileInfoBlock, must be longword aligned.</short>
</element>

<!-- function Visibility: default -->
<element name="Execute">
<short>Execute a CLI command</short>
<descr>
<p>
  This function attempts to execute the string <var>commandString</var> as a
  Shell command and arguments. The string can contain any valid input
  that you could type directly in a Shell, including input and output
  redirection using &lt; and &gt;.  Note that <var>Execute()</var> doesn't return until
  the command(s) in commandstring have returned.</p>
<p>
  The input file handle will normally be zero, and in this case
  <var>Execute()</var> will perform whatever was requested in the <var>commandString</var>
  and then return. If the input file handle is nonzero then after the
  (possibly empty) <var>commandString</var> is performed subsequent input is read
  from the specified input file handle until end of that file is
  reached.</p>
<p>
  In most cases the output file handle must be provided, and is used
  by the Shell commands as their output stream unless output
  redirection was specified. If the output file handle is set to zero
  then the current window, normally specified as *, is used. Note
  that programs running under the Workbench do not normally have a
  current window.</p>
<p>
  <var>Execute()</var> may also be used to create a new interactive Shell process
  just like those created with the NewShell command. In order to do
  this you would call <var>Execute()</var> with an empty <var>commandString</var>, and pass
  a file handle relating to a new window as the input file handle.
  The output file handle would be set to zero. The Shell will read
  commands from the new window, and will use the same window for
  output. This new Shell window can only be terminated by using the
  EndCLI command.</p>
</descr>
<errors>
</errors>
<seealso>
<!--link id="SystemTagList"/-->
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Execute.Result">
<short>Boolean indicating whether Execute was successful
      in finding and starting the specified program.  Note this
      is not the return code of the command(s).</short>
</element>

<!-- argument Visibility: default -->
<element name="Execute.string_">
<short>commandString</short>
</element>

<!-- argument Visibility: default -->
<element name="Execute.Input">
<short>File handle as input stream</short>
</element>

<!-- argument Visibility: default -->
<element name="Execute.Output">
<short>File handle as output stream</short>
</element>

<!-- function Visibility: default -->
<element name="ExNext">
<short>Examine the next entry in a directory</short>
<descr><p>
  This routine is passed a directory lock and a <link id="TFileInfoBlock"/> that
  have been initialized by a previous call to <link id="Examine">Examine()</link>, or updated
  by a previous call to <var>ExNext()</var>.  <var>ExNext()</var> gives a return code of zero
  on failure.  The most common cause of failure is reaching the end
  of the list of files in the owning directory.  In this case, <link id="IoErr">IoErr()</link>
  will return <link id="ERROR_NO_MORE_ENTRIES"/> and a good exit is appropriate.</p>
<p>
  So, follow these steps to examine a directory:</p>
  <ol>
  <li>Pass a Lock and a FileInfoBlock to <link id="Examine">Examine()</link>.  The lock must
     be on the directory you wish to examine.</li>
  <li>Pass <var>ExNext()</var> the same lock and <link id="TFileInfoBlock"/>.</li>
  <li>Do something with the information returned in the <link id="TFileInfoBlock"/>.
     Note that the <link id="TFileInfoBlock">fib_DirEntryType</link> field is positive for directories,
     negative for files.</li>
  <li>Keep calling <var>ExNext()</var> until it returns False. Check <link id="IoErr">IoErr()</link>
     to ensure that the reason for failure was <link id="ERROR_NO_MORE_ENTRIES"/>.</li>
  </ol>
<p>
  Note: if you wish to recursively scan the file tree and you find
  another directory while <var>ExNext()</var>ing you must Lock that directory and
  <link id="Examine">Examine()</link> it using a new FileInfoBlock.  Use of the same
  FileInfoBlock to enter a directory would lose important state
  information such that it will be impossible to continue scanning
  the parent directory.  While it is permissible to <link id="UnLock">UnLock()</link> and <link id="Lock">Lock()</link>
  the parent directory between <var>ExNext()</var> calls, this is <b>not</b> recommended.
  Important state information is associated with the parent lock, so
  if it is freed between <var>ExNext()</var> calls this information has to be
  rebuilt on each new <var>ExNext()</var> call, and will significantly slow down
  directory scanning.</p>
<p>
  It is <b>not</b> legal to <link id="Examine">Examine()</link> a file, and then to <var>ExNext()</var> from that
  <link id="TFileInfoBlock"/>.  You may make a local copy of the <link id="TFileInfoBlock"/>, as
  long as it is never passed back to the operating system.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Examine"/>
<link id="Lock"/>
<link id="UnLock"/>
<link id="IoErr"/>
<link id="ExamineFH"/>
<link id="AllocDosObject"/>
<link id="ExAll"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ExNext.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ExNext.Lock">
<short>Pointer to a lock originally used for the <link id="Examine">Examine()</link> call</short>
</element>

<!-- argument Visibility: default -->
<element name="ExNext.fileInfoBlock">
<short>Pointer to a <link id="TFileInfoBlock"/> used on the previous <link id="Examine">Examine()</link>
        or <var>ExNext()</var> call.</short>
</element>

<!-- function Visibility: default -->
<element name="Fault">
<short>Returns the text associated with a DOS error code</short>
<descr><p>
This routine obtains the error message text for the given error code.
  The header is prepended to the text of the error message, followed
  by a colon.  Puts a null-terminated string for the error message into
  the buffer.  By convention, error messages should be no longer than 80
  characters (+1 for termination), and preferably no more than 60.
  The value returned by <link id="IoErr">IoErr()</link> is set to the code passed in.  If there
  is no message for the error code, the message will be "Error code
  number".</p>
<p>
  The number of characters put into the buffer is returned, which will
  be 0 if the code passed in was 0.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="IoErr"/>
<link id="SetIoErr"/>
<link id="PrintFault"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Fault.Result">
<short>Number of characters put into buffer (may be 0)</short>
</element>

<!-- argument Visibility: default -->
<element name="Fault.code">
<short>Error code</short>
</element>

<!-- argument Visibility: default -->
<element name="Fault.header">
<short>Header to output before error text</short>
</element>

<!-- argument Visibility: default -->
<element name="Fault.buffer">
<short>Buffer to receive error message</short>
</element>

<!-- argument Visibility: default -->
<element name="Fault.len">
<short>Length of buffer</short>
</element>

<!-- function Visibility: default -->
<element name="FGetC">
<short>Read a character from the specified input (buffered)</short>
<descr>Reads the next character from the input stream.  A -1 is
  returned when EOF or an error is encountered.  This call is buffered.
  Use <link id="DosFlush">DosFlush()</link> between buffered and unbuffered I/O on a filehandle.

</descr>
<errors>
</errors>
<seealso>
<link id="FPutC"/>
<link id="UnGetC"/>
<link id="DosFlush"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FGetC.Result">
<short>character read (0-255) or -1</short>
</element>

<!-- argument Visibility: default -->
<element name="FGetC.File_">
<short>filehandle to use for buffered I/O</short>
</element>

<!-- function Visibility: default -->
<element name="FGets">
<short>Reads a line from the specified input (buffered)</short>
<descr><p>
  This routine reads in a single line from the specified input stopping
  at a NEWLINE character or EOF.  In either event, UP TO the number of
  len specified bytes minus 1 will be copied into the buffer.  Hence if
  a length of 50 is passed and the input line is longer than 49 bytes,
  it will return 49 characters.  It returns the buffer pointer normally,
  or NULL if EOF is the first thing read.</p>
<p>
  If terminated by a newline, the newline WILL be the last character in
  the buffer.  This is a buffered read routine.  The string read in IS
  null-terminated.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FRead"/>
<link id="FPuts"/>
<link id="FGetC"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FGets.Result">
<short>Pointer to buffer passed in, or <var>nil</var> for immediate EOF or for
     an error.  If <var>nil</var> is returnd for an EOF, <link id="IoErr">IoErr()</link> will return
     0.
</short>
</element>

<!-- argument Visibility: default -->
<element name="FGets.fh">
<short>filehandle to use for buffered I/O</short>
</element>

<!-- argument Visibility: default -->
<element name="FGets.buf">
<short>Area to read bytes into.</short>
</element>

<!-- argument Visibility: default -->
<element name="FGets.buflen">
<short>Number of bytes to read, must be > 0.</short>
</element>

<!-- function Visibility: default -->
<element name="FilePart">
<short>Returns the last component of a path</short>
<descr>This function returns a pointer to the last component of a string path
  specification, which will normally be the file name.  If there is only
  one component, it returns a pointer to the beginning of the string.
</descr>
<errors>
</errors>
<seealso>
<link id="PathPart"/>
<link id="AddPart"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FilePart.Result">
<short>pointer to the last component of the path.</short>
</element>

<!-- argument Visibility: default -->
<element name="FilePart.Path">
<short>pointer to an path string.  May be relative to the current
         directory or the current disk.</short>
</element>

<!-- function Visibility: default -->
<element name="FindArg">
<short>Find a keyword in a template</short>
<descr>Returns the argument number of the keyword, or -1 if it is not a
  keyword for the template.  Abbreviations are handled.

</descr>
<errors>
</errors>
<seealso>
<link id="ReadArgs"/>
<link id="ReadItem"/>
<link id="FreeArgs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindArg.Result">
<short>Number of entry in template, or -1 if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="FindArg.keyword">
<short>Keyword to search for in template</short>
</element>

<!-- argument Visibility: default -->
<element name="FindArg.Template">
<short>Template string to search
</short>
</element>

<!-- function Visibility: default -->
<element name="FindCliProc">
<short>Returns a pointer to the requested CLI process</short>
<descr>This routine returns a pointer to the CLI process associated with the
  given CLI number.  If the process isn't an active CLI process, <var>nil</var> is
  returned.  NOTE: should normally be called inside a <link id="exec.Forbid">Forbid()</link>, if you
  must use this function at all.
</descr>
<errors>
</errors>
<seealso>
<link id="Cli"/>
<link id="MaxCli"/>
<link id="exec.Forbid"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindCliProc.Result">
<short>Pointer to given CLI process</short>
</element>

<!-- argument Visibility: default -->
<element name="FindCliProc.num">
<short>Task number of CLI process (range 1-N)</short>
</element>

<!-- function Visibility: default -->
<element name="FindDosEntry">
<short>Finds a specific Dos List entry</short>
<descr>Locates an entry on the device list.  Starts with the entry dlist.
  NOTE: must be called with the device list locked, no references may be
  made to dlist after unlocking.
</descr>
<errors>
</errors>
<seealso>
<link id="AddDosEntry"/>
<link id="RemDosEntry"/>
<link id="NextDosEntry"/>
<link id="LockDosList"/>
<link id="MakeDosEntry"/>
<link id="FreeDosEntry"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindDosEntry.Result">
<short>The device entry or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="FindDosEntry.DList">
<short>The device entry to start with.</short>
</element>

<!-- argument Visibility: default -->
<element name="FindDosEntry.Name">
<short> Name of device entry (without ':') to locate.</short>
</element>

<!-- argument Visibility: default -->
<element name="FindDosEntry.Flags">
<short>Search control flags.  Use the flags you passed to
       <link id="LockDosList">LockDosList</link>, or a subset of them.
       <link id="LDF_READ"/>/<link id="LDF_WRITE"/> are
       not required for this call.</short>
</element>

<!-- function Visibility: default -->
<element name="FindSegment">
<short>Finds a segment on the resident list</short>
<descr><p>
  Finds a segment on the Dos resident list by name and type, starting
  at the segment <b>after</b> 'start', or at the beginning if start is <var>nil</var>.
  If system is zero, it will only return nodes with a seg_UC of 0
  or more.  It does <b>not</b> increment the seg_UC, and it does <b>not</b> do any
  locking of the list.  You must <link id="exec.Forbid">Forbid()</link> lock the list to use this
  call.</p>
<p>
  To use an entry you have found, you must: if the <link id="TSegment">seg_UC</link> is 0 or more,
  increment it, and decrement it (under <link id="exec.forbid">Forbid()</link>!) when you're done
  the the seglist.</p>
<p>
  The other values for <link id="TSegment">seg_UC</link> are:</p>
  <dl>
  <dt>  -1   </dt><dd> system module, such as a filesystem or shell</dd>
  <dt>  -2   </dt><dd> resident shell command</dd>
  <dt>  -999 </dt><dd> disabled internal command, ignore</dd>
  </dl>
<p>
  Negative values should never be modified.  All other negative
  values between 0 and -32767 are reserved to AmigaDos and should not
  be used.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AddSegment"/>
<link id="RemSegment"/>
<link id="exec.Forbid"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindSegment.Result">
<short>The Segment found or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="FindSegment.Name">
<short>Name of Segment to find</short>
</element>

<!-- argument Visibility: default -->
<element name="FindSegment.seg">
<short>Segment to start the search after</short>
</element>

<!-- argument Visibility: default -->
<element name="FindSegment.system">
<short>True for system segment. False for normal segments</short>
</element>

<!-- function Visibility: default -->
<element name="FindVar">
<short>Finds a local variable</short>
<descr>Finds a local variable structure.
</descr>
<errors>
</errors>
<seealso>
<link id="DeleteVar"/>
<link id="GetVar"/>
<link id="SetVar"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindVar.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FindVar.Name">
<short>pointer to an variable name.  Note variable names follow
         filesystem syntax and semantics.</short>
</element>

<!-- argument Visibility: default -->
<element name="FindVar.Type_">
<short>Type of variable to be found (GVF_*)</short>
</element>

<!-- function Visibility: default -->
<element name="Format">
<short>Causes a filesystem to initialize itself</short>
<descr><p>
  Interface for initializing new media on a device.  This causes the
  filesystem to write out an empty disk structure to the media, which
  should then be ready for use.  This assumes the media has been low-
  level formatted and verified already.</p>
<p>
  The filesystem should be inhibited before calling <var>Format()</var> to make
  sure you don't get an <link id="ERROR_OBJECT_IN_USE"/>.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Format.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Format.DeviceName">
<short>Name of device to be formatted.  ':' must be supplied.</short>
</element>

<!-- argument Visibility: default -->
<element name="Format.volumename">
<short>Name for volume (if supported).  No ':'.</short>
</element>

<!-- argument Visibility: default -->
<element name="Format.dostype">
<short>Type of format, if filesystem supports multiple types.</short>
</element>

<!-- function Visibility: default -->
<element name="FPutC">
<short>Write a character to the specified output</short>
<descr>Writes a single character to the output stream.  This call is
  buffered.  Use <link id="DosFlush">DosFlush()</link> between buffered and unbuffered I/O on a
  filehandle.  Interactive filehandles are flushed automatically
  on a newline, return, 0, or line feed.
</descr>
<errors>
</errors>
<seealso>
<link id="FGetC"/>
<link id="UnGetC"/>
<link id="DosFlush"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FPutC.Result">
<short>Either the character written, or EOF for an error.
</short>
</element>

<!-- argument Visibility: default -->
<element name="FPutC.File_">
<short>Filehandle to use for buffered I/O</short>
</element>

<!-- argument Visibility: default -->
<element name="FPutC.Character">
<short>Character to write
</short>
</element>

<!-- function Visibility: default -->
<element name="FPuts">
<short>Writes a string the the specified output</short>
<descr>This routine writes an unformatted string to the filehandle.  No
  newline is appended to the string.  This routine is buffered.
</descr>
<errors>
</errors>
<seealso>
<link id="FGets"/>
<link id="FPutC"/>
<link id="FWrite"/>
<link id="PutStr"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FPuts.Result">
<short>0 normally, otherwise -1.  Note that this is opposite of
    most other Dos functions, which return success.
</short>
</element>

<!-- argument Visibility: default -->
<element name="FPuts.File_">
<short>filehandle to use for buffered I/O</short>
</element>

<!-- argument Visibility: default -->
<element name="FPuts.String_">
<short>Null-terminated string to be written to default output</short>
</element>

<!-- function Visibility: default -->
<element name="FRead">
<short>Reads a number of blocks from an input (buffered) </short>
<descr>Attempts to read a number of blocks, each blocklen long, into the
  specified buffer from the input stream.  May return less than
  the number of blocks requested, either due to EOF or read errors.
  This call is buffered.
</descr>
<errors>
</errors>
<seealso>
<link id="FGetC"/>
<link id="FWrite"/>
<link id="FGets"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FRead.Result">
<short> Number of _blocks_ read, or 0 for EOF.  On an error, the
    number of blocks actually read is returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="FRead.fh">
<short>filehandle to use for buffered I/O</short>
</element>

<!-- argument Visibility: default -->
<element name="FRead.block">
<short>Area to read bytes into.</short>
</element>

<!-- argument Visibility: default -->
<element name="FRead.blocklen">
<short>number of bytes per block.  Must be > 0.</short>
</element>

<!-- argument Visibility: default -->
<element name="FRead.Number">
<short>number of blocks to read.  Must be > 0.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeArgs">
<short>Free allocated memory after <link id="ReadArgs">ReadArgs()</link></short>
<descr><var>FreeArgs()</var> will clean up after a call to <link id="ReadArgs">ReadArgs()</link>. If the
<link id="TRDArgs"/> structure was allocated by the system in a call to
<link id="ReadArgs">ReadArgs()</link>, then it will be freed. If however, you allocated
the <link id="TRDArgs"/> structure with <link id="AllocDosObject">AllocDosObject()</link>, then you will
have to free it yourself with <link id="FreeDosObject">FreeDosObject()</link>.
</descr>
<errors>
</errors>
<seealso>
<link id="ReadArgs"/>
<link id="ReadItem"/>
<link id="FindArg"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeArgs.args">
<short>The data used by <link id="ReadArgs">ReadArgs()</link>. May be <var>nil</var>,
                  in which case, <link id="FreeArgs">FreeArgs()</link> does nothing.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeDeviceProc">
<short>Releases port returned by <link id="GetDeviceProc">GetDeviceProc()</link></short>
<descr><p>
  Frees up the structure created by GetDeviceProc(), and any associated
  temporary locks.</p>
<p>
  Decrements the counter incremented by <link id="GetDeviceProc">GetDeviceProc()</link>.  The counter
  is in an extension to the 1.3 process structure.  After calling
  <var>FreeDeviceProc()</var>, do not use the port or lock again!  It is safe to
  call <var>FreeDeviceProc(nil)</var>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetDeviceProc"/>
<link id="AssignLock"/>
<link id="AssignLate"/>
<link id="AssignPath"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeDeviceProc.dp">
<short>A value returned by <link id="GetDeviceProc">GetDeviceProc()</link></short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeDosEntry">
<short>Frees an entry created by <link id="MakeDosEntry">MakeDosEntry</link></short>
<descr>This routine should be
  eliminated and replaced by a value passed to <var>FreeDosObject()</var>!
</descr>
<errors>
</errors>
<seealso>
</seealso>
<link id="AddDosEntry"/>
<link id="RemDosEntry"/>
<link id="FindDosEntry"/>
<link id="LockDosList"/>
<link id="NextDosEntry"/>
<link id="MakeDosEntry"/>
</element>

<!-- argument Visibility: default -->
<element name="FreeDosEntry.DList">
<short>DosList to free.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeDosObject">
<short>Frees an object allocated by <link id="AllocDosObject">AllocDosObject()</link></short>
<descr>Do <b>not</b> call for objects allocated in any other way.
</descr>
<errors>
</errors>
<seealso>
<link id="AllocDosObject"/>
<link id="Exec.FreeVec">FreeVec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeDosObject.Type_">
<short>Type passed to <link id="AllocDosObject">AllocDosObject()</link></short>
</element>

<!-- argument Visibility: default -->
<element name="FreeDosObject.ptr">
<short>Pointer returned by <link id="AllocDosObject">AllocDosObject()</link></short>
</element>

<!-- function Visibility: default -->
<element name="FWrite">
<short>Writes a number of blocks to an output (buffered)</short>
<descr>Attempts to write a number of blocks, each blocklen long, from the
  specified buffer to the output stream.  May return less than the
  number of blocks requested, if there is some error such as a full
  disk or r/w error.  This call is buffered.
</descr>
<errors>
</errors>
<seealso>
<link id="FPutC"/>
<link id="FRead"/>
<link id="FPuts"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FWrite.Result">
<short>Number of _blocks_ written.  On an error, the number of
    blocks actually written is returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="FWrite.fh">
<short>filehandle to use for buffered I/O</short>
</element>

<!-- argument Visibility: default -->
<element name="FWrite.block">
<short>Area to write bytes from.</short>
</element>

<!-- argument Visibility: default -->
<element name="FWrite.blocklen">
<short>Number of blocks to block.  Must be &gt; 0.</short>
</element>

<!-- argument Visibility: default -->
<element name="FWrite.NumBlocks">
<short>Number of bytes per write.  Must be &gt; 0.</short>
</element>

<!-- function Visibility: default -->
<element name="GetArgStr">
<short>Returns the arguments for the process</short>
<descr>Returns a pointer to the (null-terminated) arguments for the program
  (process).  This is the same string passed on startup from CLI.
</descr>
<errors>
</errors>
<seealso>
<link id="SetArgStr"/>
<link id="RunCommand"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetArgStr.Result">
<short>Pointer to arguments</short>
</element>

<!-- function Visibility: default -->
<element name="GetConsoleTask">
<short>Returns the default console for the process</short>
<descr>Returns the default console task's port (<link id="TProcess">pr_ConsoleTask</link>) for the current process.
</descr>
<errors>
</errors>
<seealso>
<link id="SetConsoleTask"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetConsoleTask.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="GetCurrentDirName">
<short>Returns the current directory name</short>
<descr>Extracts the current directory name from the CLI structure and puts it
  into the buffer.  If the buffer is too small, the name is truncated
  appropriately and a failure code returned.  If no CLI structure is
  present, a null string is returned in the buffer, and failure from
  the call (with <link id="IoErr">IoErr()</link> = <link id="ERROR_OBJECT_WRONG_TYPE"/>);
</descr>
<errors>
</errors>
<seealso>
<link id="SetCurrentDirName"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetCurrentDirName.Result">
<short>Buffer to hold extracted name</short>
</element>

<!-- argument Visibility: default -->
<element name="GetCurrentDirName.buf">
<short>Number of bytes of space in buffer</short>
</element>

<!-- argument Visibility: default -->
<element name="GetCurrentDirName.len">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="GetDeviceProc">
<short>Finds a handler to send a message to</short>
<descr><p>
  Finds the handler/filesystem to send packets regarding <var>name</var> to.
  This may involve getting temporary locks.  It returns a structure
  that includes a lock and msgport to send to to attempt your operation.
  It also includes information on how to handle multiple-directory
  assigns (by passing the DevProc back to <var>GetDeviceProc()</var> until it
  returns <var>nil</var>).</p>
<p>
  The initial call to GetDeviceProc() should pass <var>nil</var> for devproc.  If
  after using the returned DevProc, you get an <link id="ERROR_OBJECT_NOT_FOUND"/>,
  and (<link id="TDevProc"/> and <link id="DVPF_ASSIGN"/>) is True, you should call
  <link id="GetDeviceProc">GetDeviceProc()</link> again, passing it the devproc structure.  It will
  either return a modified devproc structure, or <var>nil</var> (with
  <link id="ERROR_NO_MORE_ENTRIES"/> in <link id="IoErr">IoErr()</link>). Continue until it returns <var>nil</var>.</p>
<p>
  This call also increments the counter that locks a handler/fs into
  memory.  After calling <link id="FreeDeviceProc">FreeDeviceProc()</link>, do not use the port or lock
  again!</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeDeviceProc"/>
<link id="AssignLock"/>
<link id="AssignLate"/>
<link id="AssignPath"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetDeviceProc.Result">
<short>a pointer to a DevProc structure or <var>nil</var>
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDeviceProc.Name">
<short>name of the object you wish to access.  This can be a
      relative path ('foo/bar'), relative to the current volume
      (':foo/bar'), or relative to a device/volume/assign
      ('foo:bar').</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDeviceProc.dp">
<short>A value returned by <link id="GetDeviceProc">GetDeviceProc()</link> before, or <var>nil</var>
</short>
</element>

<!-- function Visibility: default -->
<element name="GetFileSysTask">
<short>Returns the default filesystem for the process</short>
<descr>Returns the default filesystem task's port (<link id="TProcess">pr_FileSystemTask</link>) for the current process.
</descr>
<errors>
</errors>
<seealso>
<link id="SetFileSysTask"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetFileSysTask.Result">
<short>The <link id="TProcess">pr_MsgPort</link> of the filesystem, or <var>nil</var>.</short>
</element>

<!-- function Visibility: default -->
<element name="GetProgramDir">
<short>Returns a lock on the directory the program was loaded from</short>
<descr>Returns a shared lock on the directory the program was loaded from.
  This can be used for a program to find data files, etc, that are stored
  with the program, or to find the program file itself.  <var>nil</var> returns are
  valid, and may occur, for example, when running a program from the
  resident list.  You should <b>not</b> unlock the lock.
</descr>
<errors>
</errors>
<seealso>
<link id="SetFileSysTask"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetProgramDir.Result">
<short>A lock on the directory the current program was loaded from,
         or <var>nil</var> if loaded from resident list, etc.</short>
</element>

<!-- function Visibility: default -->
<element name="GetProgramName">
<short>Returns the current program name</short>
<descr>Extracts the program name from the CLI structure and puts it
  into the buffer.  If the buffer is too small, the name is truncated.
  If no CLI structure is present, a null string is returned in the
  buffer, and failure from the call (with <link id="IoErr">IoErr()</link> =
  <link id="ERROR_OBJECT_WRONG_TYPE"/>);
</descr>
<errors>
</errors>
<seealso>
<link id="SetProgramName"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetProgramName.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GetProgramName.buf">
<short>Buffer to hold extracted name</short>
</element>

<!-- argument Visibility: default -->
<element name="GetProgramName.len">
<short>Number of bytes of space in buffer</short>
</element>

<!-- function Visibility: default -->
<element name="GetPrompt">
<short>Returns the prompt for the current process</short>
<descr>Extracts the prompt string from the CLI structure and puts it
  into the buffer.  If the buffer is too small, the string is truncated
  appropriately and a failure code returned.  If no CLI structure is
  present, a null string is returned in the buffer, and failure from
  the call (with <link id="IoErr">IoErr()</link> =
  <link id="ERROR_OBJECT_WRONG_TYPE"/>);
</descr>
<errors>
</errors>
<seealso>
<link id="SetPrompt"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetPrompt.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GetPrompt.buf">
<short>Buffer to hold extracted prompt</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPrompt.len">
<short>Number of bytes of space in buffer</short>
</element>

<!-- function Visibility: default -->
<element name="GetVar">
<short>Returns the value of a local or global variable</short>
<descr><p>
  Gets the value of a local or environment variable.  It is advised to
  only use ASCII strings inside variables, but not required.  This stops
  putting characters into the destination when a n is hit, unless
  <link id="GVF_BINARY_VAR"/> is specified.  (The n is not stored in the buffer.)</p>
<p>
Currently defined flags include:</p>
<dl>
<dt>GVF_GLOBAL_ONLY </dt><dd> tries to get a global env variable.</dd>
<dt>GVF_LOCAL_ONLY  </dt><dd> tries to get a local variable.</dd>
<dt>GVF_BINARY_VAR  </dt><dd> don't stop at n</dd>
<dt>GVF_DONT_NULL_TERM </dt><dd> no null termination (only valid
            for binary variables).</dd>
</dl>
<p>The default is to try to get a local variable first, then
     to try to get a global environment variable.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetVar"/>
<link id="DeleteVar"/>
<link id="FindVar"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetVar.Result">
<short>Size of environment variable.  -1 indicates that the
    variable was not defined.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetVar.Name">
<short>Pointer to a variable name.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetVar.buffer">
<short>A user allocated area which will be used to store
 the value associated with the variable.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetVar.size">
<short>Length of the buffer region in bytes.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetVar.Flags">
<short>combination of type of var to get value of (low 8 bits), and
     flags to control the behavior of this routine.</short>
</element>

<!-- function Visibility: default -->
<element name="Info">
<short>Returns information about the disk</short>
<descr><var>Info()</var> can be used to find information about any disk in use.
  <var>lock</var> refers to the disk, or any file on the disk. The parameter
  block is returned with information about the size of the disk,
  number of free blocks and any soft errors.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Info.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Info.Lock">
<short>A lock on any file on the volume for which information
should be supplied, or 0</short>
</element>

<!-- argument Visibility: default -->
<element name="Info.parameterBlock">
<short>pointer to the info</short>
</element>

<!-- function Visibility: default -->
<element name="Inhibit">
<short>Inhibits access to a filesystem</short>
<descr>Sends an <link id="ACTION_INHIBIT"/> packet to the indicated handler.  This stops
  all activity by the handler until uninhibited.  When uninhibited,
  anything may have happened to the disk in the drive, or there may no
  longer be one.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Inhibit.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Inhibit.Name">
<short>Name of device to inhibit (with ':')</short>
</element>

<!-- argument Visibility: default -->
<element name="Inhibit.onoff">
<short>New status.  <link id="DOSTRUE"/> = inhibited, <link id="DOSFALSE"/> = uninhibited</short>
</element>

<!-- function Visibility: default -->
<element name="InternalLoadSeg">
<short>Low-level load routine</short>
<descr><p>Loads from fh.
  Functionarray is a pointer to an array of functions.</p>
<p>
This function really only tries to load the different file
formats aos, elf and aout.</p>
<dl>
<dt>FuncTable[0] </dt><dd> bytes  = ReadFunc(readhandle, buffer, length), DOSBase</dd>
<dt>FuncTable[1] </dt><dd> Memory = AllocFunc(size,flags), ExecBase</dd>
<dt>FuncTable[2] </dt><dd> FreeFunc(memory, size), ExecBase</dd>
<dt>FuncTable[3] -</dt><dd>pos    = SeekFunc(readhandle, pos, mode), DOSBase</dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
<link id="LoadSeg"/>
<link id="UnLoadSeg"/>
<link id="NewLoadSeg"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="InternalLoadSeg.Result">
<short>Pointer to loaded Seglist or <var>nil</var> in case of failure.</short>
</element>

<!-- argument Visibility: default -->
<element name="InternalLoadSeg.fh">
<short>Filehandle to load from</short>
</element>

<!-- argument Visibility: default -->
<element name="InternalLoadSeg.table">
<short>ignored</short>
</element>

<!-- argument Visibility: default -->
<element name="InternalLoadSeg.funcarray">
<short>array of functions to be used for read, seek, alloc and free</short>
</element>

<!-- argument Visibility: default -->
<element name="InternalLoadSeg.stack">
<short>pointer to storage for stacksize. (currently ignored)</short>
</element>

<!-- function Visibility: default -->
<element name="IoErr">
<short>Return extra information from the system</short>
<descr><p>
  Most I/O routines return zero to indicate an error. When this
  happens (or whatever the defined error return for the routine)
  this routine may be called to determine more information. It is
  also used in some routines to pass back a secondary result.</p>
<p>
  Note: there is no guarantee as to the value returned from <var>IoErr()</var>
  after a successful operation, unless to specified by the routine.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Fault"/>
<link id="PrintFault"/>
<link id="SetIoErr"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IoErr.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="IsFileSystem">
<short>Returns whether a Dos handler is a filesystem</short>
<descr><p>Returns whether the device is a filesystem or not.  A filesystem
  supports seperate files storing information.  It may also support
  sub-directories, but is not required to.  If the filesystem doesn't
  support this new packet, <var>IsFileSystem()</var> will use <link id="Lock">Lock</link>(":",...) as
  an indicator.</p>
<p>DF0:, HD0:, ... are filesystems.
CON:, PIPE:, AUX:, ... are not.
In AmigaOS if devicename contains no ':' then result
is always True. Also volume and assign names return
True.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IsFileSystem.Result">
<short>Flag to indicate if device is a file system</short>
</element>

<!-- argument Visibility: default -->
<element name="IsFileSystem.Name">
<short>Name of device in question, with trailing ':'.</short>
</element>

<!-- function Visibility: default -->
<element name="IsInteractive">
<short>Discover whether a file is "interactive"</short>
<descr>The return value <var>status</var> indicates whether the file associated
  with the file handle <var>file</var> is connected to a virtual terminal like a console or shell window.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IsInteractive.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="IsInteractive.file_">
<short>file handle</short>
</element>

<!-- function Visibility: default -->
<element name="LoadSeg">
<short>Scatterload a loadable file into memory</short>
<descr><p>
  The file <var>name</var> should be a load module produced by the linker.
  <var>LoadSeg()</var> scatterloads the CODE, DATA and BSS segments into memory,
  chaining together the segments with BPTR's on their first words.
  The end of the chain is indicated by a zero.  There can be any number
  of segments in a file.  All necessary relocation is handled by
  <var>LoadSeg()</var>.</p>
<p>
  In the event of an error any blocks loaded will be unloaded and a
  NULL result returned.</p>
<p>
  If the module is correctly loaded then the output will be a pointer
  at the beginning of the list of blocks. Loaded code is unloaded via
  a call to <link id="UnLoadSeg">UnLoadSeg()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="UnLoadSeg"/>
<link id="InternalLoadSeg"/>
<link id="CreateProc"/>
<link id="CreateNewProc"/>
<link id="NewLoadSeg"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LoadSeg.Result">
<short>Pointer to the seglist</short>
</element>

<!-- argument Visibility: default -->
<element name="LoadSeg.Name">
<short>Name of the file to load</short>
</element>

<!-- function Visibility: default -->
<element name="Lock">
<short>Lock a directory or file</short>
<descr>
Gets a lock on a file or directory. There may be more than one
shared lock on a file but only one if it is an exclusive one.
Locked files or directories may not be deleted.
</descr>
<errors>
</errors>
<seealso>
<link id="UnLock"/>
<link id="DupLock"/>
<link id="ChangeMode"/>
<link id="NameFromLock"/>
<link id="DupLockFromFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Lock.Result">
<short>Pointer to lock or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="Lock.Name">
<short>Name of file or directory to lock</short>
</element>

<!-- argument Visibility: default -->
<element name="Lock.AccessMode">
<short>ON of SHARED_LOCK or EXCLUSIVE_LOCK</short>
</element>

<!-- function Visibility: default -->
<element name="LockDosList">
<short>Locks the specified Dos Lists for use</short>
<descr>
Waits until the desired dos lists are free then gets a lock on them.
A handle is returned that can be used for <link id="FindDosEntry">FindDosEntry()</link>.
Calls to this function nest, i.e. you must call <link id="UnLockDosList">UnLockDosList()</link>
as often as you called <var>LockDosList()</var>. Always lock all lists
at once - do not try to get a lock on one of them then on another.
</descr>
<errors>
</errors>
<seealso>
<link id="AttemptLockDosList"/>
<link id="UnLockDosList"/>
<link id="exec.Forbid"/>
<link id="NextDosEntry"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockDosList.Result">
<short>Handle to the dos list. This is not a direct pointer
to the first list element but to a pseudo element instead.
</short>
</element>

<!-- argument Visibility: default -->
<element name="LockDosList.Flags">
<short>what lists to lock</short>
</element>

<!-- function Visibility: default -->
<element name="LockRecord">
<short>Locks a portion of a file</short>
<descr>
Lock a portion of a file for exclusive access. A timeout may be specified
which is the maximum amount of time to wait for the record to be available.
</descr>
<errors>
</errors>
<seealso>
<link id="LockRecords"/>
<link id="UnLockRecord"/>
<link id="UnLockRecords"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockRecord.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecord.fh">
<short>File handle for the file to lock a record of</short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecord.offset">
<short>Starting position of the lock</short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecord.length">
<short>Length of the record in bytes</short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecord.mode">
<short>Lock type (REC_*) For the IMMED modes, the timeout is ignored.</short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecord.timeout">
<short>imeout interval in ticks (1/50 seconds). 0 is legal.
</short>
</element>

<!-- function Visibility: default -->
<element name="LockRecords">
<short>Lock a series of records</short>
<descr>Lock several records at the same time. The timeout specified is applied
to each lock to attempt. The array of RecordLock:s is terminated with
an entry where rec_FH is equal to <var>nil</var>. A set of records should
always be locked in the same order so as to reduce possiblities of deadlock.
</descr>
<errors>
</errors>
<seealso>
<link id="UnLockRecords"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockRecords.Result">
<short>Success/failure indication. In case of a success, all the record locks
are locked. In case of failure, no record locks are locked.</short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecords.recArray">
<short>Array of records to lock</short>
</element>

<!-- argument Visibility: default -->
<element name="LockRecords.timeout">
<short>maximum number of ticks to wait for a lock to be ready (1/50 seconds)</short>
</element>

<!-- function Visibility: default -->
<element name="MakeDosEntry">
<short>Creates a DosList structure</short>
<descr>Create a DosList structure, including allocating a name and correctly
  null-terminating the BSTR.  It also sets the dol_Type field, and sets
  all other fields to 0.  This routine should be eliminated and replaced
  by a value passed to <link id="AllocDosObject">AllocDosObject()</link>!
</descr>
<errors>
</errors>
<seealso>
<link id="AllocDosObject"/>
<link id="RemDosEntry"/>
<link id="FindDosEntry"/>
<link id="LockDosList"/>
<link id="NextDosEntry"/>
<link id="FreeDosEntry"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MakeDosEntry.Result">
<short>New device entry or <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="MakeDosEntry.Name">
<short>Name for the device/volume/assign node.</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeDosEntry.Type_">
<short>Type of Node (LDF_*)</short>
</element>

<!-- function Visibility: default -->
<element name="MakeLink">
<short>Creates a filesystem link</short>
<descr><p>
<var>MakeLink()</var> will create a link between two files or directories.
A link is a filesystem object that refers to another file.</p>
<p>
A soft link refers to another file or directory by name, and is
resolved by the filesystem and the caller. Soft links are not
restricted to the same volume and the target does not have to exist.</p>
<p>
A hard link refers to another file by the location on a disk, and
is resolved by the filesystem. Hard links are restricted to files
or directories on the same volume.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MakeLink.Result">
<short><link id="DOSTRUE"/> or <link id="DOSFALSE"/>. On error, <link id="IoErr">IoErr()</link> will contain more information.</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeLink.Name">
<short>The name of the link to create</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeLink.dest">
<short>If <var>soft</var> is True this must be a filename; if it is False a lock
pointing to the file to be hard-linked must be provided</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeLink.soft">
<short>True, if a soft link is to be created, False for a hard link</short>
</element>

<!-- procedure Visibility: default -->
<element name="MatchEnd">
<short> Free storage allocated for <link id="MatchFirst">MatchFirst()</link>/<link id="MatchNext">MatchNext()</link></short>
<descr>Return all storage associated with a given search.
</descr>
<errors>
</errors>
<seealso>
<link id="MatchFirst"/>
<link id="ParsePattern"/>
<link id="Examine"/>
<link id="CurrentDir"/>
<link id="MatchNext"/>
<link id="ExNext"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="MatchEnd.AP">
<short>Anchor used for <link id="MatchFirst">MatchFirst()</link>/<link id="MatchNext">MatchNext()</link></short>
</element>

<!-- function Visibility: default -->
<element name="MatchFirst">
<short>Finds file that matches pattern</short>
<descr><p>
  Locates the first file or directory that matches a given pattern.
  <var>MatchFirst()</var> is passed your pattern (you do not pass it through
  <link id="ParsePattern">ParsePattern()</link> - <var>MatchFirst()</var>
  does that for you), and the control
  structure.  <var>MatchFirst()</var> normally initializes your AnchorPath
  structure for you, and returns the first file that matched your
  pattern, or an error.  Note that <var>MatchFirst()</var>/
  <link id="MatchNext">MatchNext()</link> are unusual
  for Dos in that they return 0 for success, or the error code,
  instead of the application getting the error code
  from IoErr().</p>
<p>
  When looking at the result of <var>MatchFirst()</var>/
  <link id="MatchNext">MatchNext()</link>, the ap_Info
  field of your <link id="TAnchorPath">TAnchorPath</link> has the results of an <link id="Examine">Examine()</link> of the object.
  You normally get the name of the object from <link id="TFileInfoBlock">fib_FileName</link>, and the
  directory it's in from <link id="TAnchorPath">ap_Current.an_Lock</link>.  To access this object,
  normally you would temporarily <link id="CurrentDir">CurrentDir()</link> to the lock, do an action
  to the file/dir, and then <link id="CurrentDir">CurrentDir()</link> back to your original directory.
  This makes certain you affect the right object even when two volumes
  of the same name are in the system.  You can use <link id="TAnchorPath">ap_Buf</link> (with
  <link id="TAnchorPath">ap_StrLen</link>) to get a name to report to the user.</p>
<p>
  To initialize the <link id="TAnchorPath">TAnchorPath</link> structure (particularily when reusing
  it), set <link id="TAnchorPath">ap_BreakBits</link> to the signal bits (CDEF) that you want to take
  a break on, or <var>nil</var>, if you don't want to convenience the user.
  <link id="TAnchorPath">ap_Flags</link> should be set to any flags you need or all 0's otherwise.
  <link id="TAnchorPath">ap_FoundBreak</link> should be cleared if you'll be using breaks.</p>
<p>
  If you want to have the FULL PATH NAME of the files you found,
  allocate a buffer at the END of this structure, and put the size of
  it into <link id="TAnchorPath">ap_StrLen</link>.  If you don't want the full path name, make sure
  you set <link id="TAnchorPath">ap_StrLen</link> to zero.  In this case, the name of the file, and
  stats are available in the <link id="TAnchorPath">ap_Info</link>, as per usual.</p>
<p>
  Then call <var>MatchFirst()</var> and then afterwards, <link id="MatchNext">MatchNext()</link> with this
  structure.  You should check the return value each time (see below)
  and take the appropriate action, ultimately calling <link id="MatchEnd">MatchEnd()</link> when
  there are no more files or you are done.  You can tell when you are
  done by checking for the normal AmigaDOS return code
  ERROR_NO_MORE_ENTRIES.</p>
<p>
  Note: patterns with trailing slashes may cause <var>MatchFirst()</var>/
  <link id="MatchNext">MatchNext()</link>
  to return with an <link id="TAnchorPath">ap_Current.an_Lock</link> on the object, and a filename
  of the empty string ('').</p>
<p>
  See <link id="ParsePattern">ParsePattern()</link> for more information on the patterns.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MatchNext"/>
<link id="ParsePattern"/>
<link id="Examine"/>
<link id="MatchEnd"/>
<link id="ExNext"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MatchFirst.Result">
<short>0 for success or error code.</short>
</element>

<!-- argument Visibility: default -->
<element name="MatchFirst.pat">
<short>Pattern to search for</short>
</element>

<!-- argument Visibility: default -->
<element name="MatchFirst.AP">
<short>Place holder for search.</short>
</element>

<!-- function Visibility: default -->
<element name="MatchNext">
<short>Finds the next file or directory that matches pattern</short>
<descr>Locates the next file or directory that matches a given pattern.
  Various bits in the flags (APF_*) allow the application to control the operation of <var>MatchNext()</var>.
</descr>
<errors>
</errors>
<seealso>
<link id="MatchFirst"/>
<link id="ParsePattern"/>
<link id="Examine"/>
<link id="MatchEnd"/>
<link id="ExNext"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MatchNext.Result">
<short>0 for success or error code.</short>
</element>

<!-- argument Visibility: default -->
<element name="MatchNext.AP">
<short>Place holder for search.</short>
</element>

<!-- function Visibility: default -->
<element name="MatchPattern">
<short>Checks for a pattern match with a string</short>
<descr><p>The pattern must be a
  tokenized string output by <link id="ParsePattern">ParsePattern()</link>.
  This routine is case-sensitive.</p>
<p>
  NOTE: this routine is highly recursive.  You must have at least
  1500 free bytes of stack to call this (it will cut off it's
  recursion before going any deeper than that and return failure).
  That's <b>currently</b> enough for about 100 levels deep of #, (, ~, etc.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ParsePattern"/>
<link id="MatchPatternNoCase"/>
<link id="MatchFirst"/>
<link id="MatchNext"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MatchPattern.Result">
<short>Success or failure of pattern match.  On failure,
    <link id="IoErr">IoErr()</link> will return 0 or <link id="ERROR_TOO_MANY_LEVELS"/></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchPattern.pat">
<short>Special pattern string to match as returned by <link id="ParsePattern">ParsePattern()</link></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchPattern.str">
<short>String to match against given pattern</short>
</element>

<!-- function Visibility: default -->
<element name="MatchPatternNoCase">
<short>Checks for a pattern match with a string</short>
<descr><p>The pattern must be a
  tokenized string output by <link id="ParsePattern">ParsePattern()</link>.
  This routine is case-insensitive.</p>
<p>
  NOTE: this routine is highly recursive.  You must have at least
  1500 free bytes of stack to call this (it will cut off it's
  recursion before going any deeper than that and return failure).
  That's <b>currently</b> enough for about 100 levels deep of #, (, ~, etc.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ParsePattern"/>
<link id="MatchPattern"/>
<link id="MatchFirst"/>
<link id="MatchNext"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MatchPatternNoCase.Result">
<short>Success or failure of pattern match.  On failure,
    <link id="IoErr">IoErr()</link> will return 0 or <link id="ERROR_TOO_MANY_LEVELS"/></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchPatternNoCase.pat">
<short>Special pattern string to match as returned by <link id="ParsePattern">ParsePattern()</link></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchPatternNoCase.str">
<short>String to match against given pattern</short>
</element>

<!-- function Visibility: default -->
<element name="MaxCli">
<short>Returns the highest CLI process number possibly in use</short>
<descr>
Returns the highest CLI number that may be in use.  CLI numbers are
reused, and are usually as small as possible.  To find all CLIs, scan
using <link id="FindCliProc">FindCliProc()</link> from 1 to <var>MaxCLI()</var>.  The number returned by
<var>MaxCli()</var> may change as processes are created and destroyed.
</descr>
<errors>
</errors>
<seealso>
<link id="FindCliProc"/>
<link id="Cli"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MaxCli.Result">
<short>The highest CLI number that <b>may</b> be in use.
</short>
</element>

<!-- function Visibility: default -->
<element name="NameFromFH">
<short>Get the name of an open filehandle</short>
<descr><p>
  Returns a fully qualified path for the filehandle.  This routine is
  guaranteed not to write more than len characters into the buffer.  The
  name will be null-terminated.  See <link id="NameFromLock">NameFromLock()</link> for more information.</p>
<p>
  Note: Older filesystems that don't support <link id="ExamineFH">ExamineFH()</link> will cause
  <var>NameFromFH()</var>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NameFromLock"/>
<link id="ExamineFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NameFromFH.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromFH.fh">
<short>Lock of object to be examined.</short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromFH.buffer">
<short>Buffer to store name.</short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromFH.Length">
<short>Length of buffer.</short>
</element>

<!-- function Visibility: default -->
<element name="NameFromLock">
<short>Returns the name of a locked object</short>
<descr><p>
  Returns a fully qualified path for the lock. This routine is
  guaranteed not to write more than len characters into the buffer.  The
  name will be null-terminated.</p>
<p>
  NOTE: if the volume is not mounted,
  the system will request it (unless of course you set <link id="TProcess">pr_WindowPtr</link> to
  -1).  If the volume is not mounted or inserted, it will return an
  error.  If the lock passed in is <var>nil</var>, 'SYS:' will be returned. If
  the buffer is too short, an error will be returned, and <link id="IoErr">IoErr()</link> will
  return <link id="ERROR_LINE_TOO_LONG"/>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NameFromFH"/>
<link id="Lock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NameFromLock.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromLock.Lock">
<short>Lock of object to be examined.</short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromLock.buffer">
<short>Buffer to store name.</short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromLock.Length">
<short>Length of buffer.</short>
</element>

<!-- function Visibility: default -->
<element name="NewLoadSeg">
<short>Improved version of LoadSeg for stacksizes</short>
<descr><p>
  Does a LoadSeg on a file, and takes additional actions based on the
  tags supplied.</p>
<p>
  Clears unused portions of Code and Data hunks (as well as BSS hunks).
  (This also applies to <link id="InternalLoadSeg">InternalLoadSeg()</link> and <link id="LoadSeg">LoadSeg()</link>).</p>
</descr>
<errors>
</errors>
<seealso>
<link id="LoadSeg"/>
<link id="UnLoadSeg"/>
<link id="InternalLoadSeg"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NewLoadSeg.Result">
<short>Seglist loaded, or <var>nil</var> </short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSeg.file_">
<short>Filename of file to load</short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSeg.Tags">
<short>Pointer to tagitem array</short>
</element>

<!-- function Visibility: default -->
<element name="NextDosEntry">
<short>Get the next Dos List entry</short>
<descr>
  Find the next Dos List entry of the right type.  You <b>must</b> have locked
  the types you're looking for.  Returns <var>nil</var> if there are no more of
  that type in the list.
</descr>
<errors>
</errors>
<seealso>
<link id="AddDosEntry"/>
<link id="RemDosEntry"/>
<link id="FindDosEntry"/>
<link id="LockDosList"/>
<link id="MakeDosEntry"/>
<link id="FreeDosEntry"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NextDosEntry.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NextDosEntry.DList">
<short>Structure given by <link id="LockDosList">LockDosList()</link> or the last call to <link id="FindDosEntry">FindDosEntry()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="NextDosEntry.Flags">
<short>The same flags as given to <link id="LockDosList">LockDosList()</link> or a subset of them.</short>
</element>

<!-- function Visibility: default -->
<element name="OpenFromLock">
<short>Opens a file you have a lock on</short>
<descr>
  Given a lock, this routine performs an open on that lock.  If the open
  succeeds, the lock is (effectively) relinquished, and should not be
  <link id="UnLock">UnLock()</link>ed or used.  If the open fails, the lock is still usable.
  The lock associated with the file internally is of the same access
  mode as the lock you gave up - shared is similar to <link id="MODE_OLDFILE"/>,
  exclusive is similar to <link id="MODE_NEWFILE"/>.
</descr>
<errors>
</errors>
<seealso>
<link id="DosOpen"/>
<link id="DosClose"/>
<link id="Lock"/>
<link id="UnLock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OpenFromLock.Result">
<short>Newly opened file handle or <var>nil</var> for failure</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenFromLock.Lock">
<short>Lock on object to be opened.</short>
</element>

<!-- function Visibility: default -->
<element name="ParentDir">
<short></short>
<descr><p>
  The argument <var>lock</var> is associated with a given file or directory.
  <var>ParentDir()</var> returns <var>newlock</var> which is associated the parent
  directory of <var>lock</var>.</p>
<p>
  Taking the <var>ParentDir()</var> of the root of the current filing system
  returns a 0 lock.  Note this 0 lock represents the root of
  file system that you booted from (which is, in effect, the parent
  of all other file system roots.)</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="DupLock"/>
<link id="UnLock"/>
<link id="ParentOfFH"/>
<link id="DupLockFromFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ParentDir.Result">
<short>Returns a lock to the parent directory or 0, in which case the
supplied lock has no parent directory (because it is the root
directory) or an error occured. <link id="IoErr">IoErr()</link> returns 0 in the former case and a different value on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="ParentDir.Lock">
<short>Lock to get parent directory of.</short>
</element>

<!-- function Visibility: default -->
<element name="ParentOfFH">
<short>Returns a lock on the parent directory of a file</short>
<descr>
  Returns a shared lock on the parent directory of the filehandle.
</descr>
<errors>
</errors>
<seealso>
<link id="ParentDir"/>
<link id="Lock"/>
<link id="UnLock"/>
<link id="DupLockFromFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ParentOfFH.Result">
<short>Lock on parent directory of the filehandle or <var>nil</var> for failure.</short>
</element>

<!-- argument Visibility: default -->
<element name="ParentOfFH.fh">
<short>Filehandle you want the parent of.</short>
</element>

<!-- function Visibility: default -->
<element name="ParsePattern">
<short>Create a tokenized string for MatchPattern()</short>
<descr><p>
  Tokenizes a pattern, for use by <link id="MatchPattern">MatchPattern()</link>.  Also indicates if
  there are any wildcards in the pattern (i.e. whether it might match
  more than one item).  Note that Dest must be at least 2 times as
  large as Source plus bytes to be (almost) 100% certain of no
  buffer overflow.  This is because each input character can currently
  expand to 2 tokens (with one exception that can expand to 3, but
  only once per string).  Note: this implementation may change in
  the future, so you should handle error returns in all cases, but
  the size above should still be a reasonable upper bound for a buffer
  allocation.</p>
<p>
  The patterns are fairly extensive, and approximate some of the ability
  of Unix/grep "regular expression" patterns.  Here are the available
  tokens:</p>
<dl>
  <dt>?</dt><dd>Matches a single character.</dd>
  <dt>#</dt><dd>Matches the following expression 0 or more times.</dd>
  <dt>(ab|cd)</dt><dd>Matches any one of the items seperated by '|'.</dd>
  <dt>~</dt><dd>Negates the following expression.  It matches all strings
    that do not match the expression (aka ~(foo) matches all
    strings that are not exactly 'foo').</dd>
  <dt>[abc]</dt><dd>Character class: matches any of the characters in the class.</dd>
  <dt>[~bc]</dt><dd>Character class: matches any of the characters not in the
    class.</dd>
  <dt>a-z</dt><dd>Character range (only within character classes).</dd>
  <dt>%</dt><dd>Matches 0 characters always (useful in '(foo|bar|%)').</dd>
  <dt>*</dt><dd>Synonym for "#?", not available by default in 2.0.  Available
    as an option that can be turned on.</dd>
</dl>
<p>
  'Expression' in the above table means either a single character
  (ex: "#?"), or an alternation (ex: "#(ab|cd|ef)"), or a character
  class (ex: "#[a-zA-Z]").</p>

</descr>
<errors>
</errors>
<seealso>
<link id="ParsePatternNoCase"/>
<link id="MatchPattern"/>
<link id="MatchFirst"/>
<link id="MatchNext"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ParsePattern.Result">
<short><dl>
  <dt>1</dt><dd>There are wildcards in the pattern (it might match more than
     one string).</dd>
 <dt>0</dt><dd>No wildcards in it, all went fine.</dd>
<dt>-1</dt><dd> An error happened. <link id="IoErr">IoErr()</link> gives additional information in
     that case.</dd>
</dl>
</short>
</element>


<!-- argument Visibility: default -->
<element name="ParsePattern.Source">
<short>Pattern describing the kind of strings that match.</short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePattern.Dest">
<short>Buffer for the destination.</short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePattern.DestLength">
<short>Size of the buffer.</short>
</element>

<!-- function Visibility: default -->
<element name="ParsePatternNoCase">
<short>Create a tokenized string for MatchPatternNoCase()</short>
<descr>
  Tokenizes a pattern, for use by <link id="MatchPatternNoCase">MatchPatternNoCase()</link>.  Also indicates
  if there are any wildcards in the pattern (i.e. whether it might match
  more than one item).  Note that Dest must be at least 2 times as
  large as Source plus 2 bytes.
  For a description of the wildcards, see <link id="ParsePattern">ParsePattern()</link>.
</descr>
<errors>
</errors>
<seealso>
<link id="ParsePattern"/>
<link id="MatchPattern"/>
<link id="MatchFirst"/>
<link id="MatchNext"/>
<link id="Utility.ToUpper">ToUpper</link>

</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ParsePatternNoCase.Result">
<short>
<dl>
  <dt>1</dt><dd>There are wildcards in the pattern (it might match more than
     one string).</dd>
 <dt>0</dt><dd>No wildcards in it, all went fine.</dd>
 <dt>-1</dt><dd> An error happened. <link id="IoErr">IoErr()</link> gives additional information in that case.</dd>
</dl>
</short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePatternNoCase.Source">
<short>Unparsed wildcard string to search for.</short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePatternNoCase.Dest">
<short>Output string, gets tokenized version of input.</short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePatternNoCase.DestLength">
<short>Length available in destination (should be at least as twice as large as source + 2 bytes).</short>
</element>

<!-- function Visibility: default -->
<element name="PathPart">
<short>Returns a pointer to the end of the next-to-last component of a path.
</short>
<descr>
  This function returns a pointer to the character after the next-to-last
  component of a path specification, which will normally be the directory
  name.  If there is only one component, it returns a pointer to the
  beginning of the string.  The only real difference between this and
  <link id="FilePart">FilePart()</link> is the handling of '/'.
</descr>
<errors>
</errors>
<seealso>
<link id="FilePart"/>
<link id="AddPart"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PathPart.Result">
<short>Pointer to the end of the next-to-last component of the path.
</short>
</element>

<!-- argument Visibility: default -->
<element name="PathPart.Path">
<short>Pointer to an path string. May be relative to the current directory or the current disk.</short>
</element>

<!-- function Visibility: default -->
<element name="PrintFault">
<short>Returns the text associated with a DOS error code</short>
<descr>
  This routine obtains the error message text for the given error code.
  This is similar to the <link id="Fault">Fault()</link> function,
  except that the output is written to the default output channel
  with buffered output. The value returned by <link id="IoErr">IoErr()</link>
  is set to the code passed in.
</descr>
<errors>
</errors>
<seealso>
<link id="IoErr"/>
<link id="Fault"/>
<link id="SetIoErr"/>
<link id="DosOutput"/>
<link id="FPuts"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PrintFault.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="PrintFault.code">
<short>Error code</short>
</element>

<!-- argument Visibility: default -->
<element name="PrintFault.header">
<short>Header to output before error text</short>
</element>

<!-- function Visibility: default -->
<element name="PutStr">
<short>Writes a string the the default output (buffered)</short>
<descr>
  This routine writes an unformatted string to the default output.  No
  newline is appended to the string and any error is returned.  This
  routine is buffered.
</descr>
<errors>
</errors>
<seealso>
<link id="FPuts"/>
<link id="FPutC"/>
<link id="FWrite"/>
<link id="WriteChars"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PutStr.Result">
<short>0 for success, -1 for any error.  NOTE: this is opposite
    most Dos function returns!</short>
</element>

<!-- argument Visibility: default -->
<element name="PutStr.String_">
<short>Null-terminated string to be written to default output</short>
</element>

<!-- function Visibility: default -->
<element name="ReadArgs">
<short>Read bytes of data from a file</short>
<descr><p>
  Parses the commandline, a given string or
  <link id="DosInput">DosInput()</link> and fills
  an argument array according to the options template given.
  The array must be initialized to the wanted defaults before
  each call to <var>ReadArgs()</var>. If the rdargs argument is <var>nil</var>
  <var>ReadArgs()</var> tries to parse the commandline and continues
  on the input channel if it just consists of a single '?',
  prompting the user for input.</p>
<p>
  The template string is given as
  a number of options separated by ',' and modified
  by '/' modifiers, e.g. 'NAME,WIDTH/N,HEIGHT/N'
  means get a name string and two numbers (width and
  height). The possible modifiers are:</p>
<dl>
  <dt>/S</dt><dd>Option is a switch. It may be either set or
              left out.</dd>
  <dt>/T</dt><dd>Option is a boolean value. Requires an argument
              which may be "ON", "YES" (setting the respective
              argument to 1), "OFF" or "NO" (setting the
              respective argument to 0).</dd>
  <dt>/N</dt><dd>Option is a number. Strings are not allowed.
              If the option is optional, a pointer to the
              actual number is returned. This is how you know
              if it was really given. The number is always of type
              LONG.</dd>
  <dt>/A</dt><dd>Argument is required. If it is left out ReadArgs()
              fails.</dd>
  <dt>/K</dt><dd>The keyword must be given when filling the option.
              Normally it's skipped.</dd>
  <dt>/M</dt><dd>Multiple strings or, when used in combination with /N,
              numbers. The result is returned as an array of pointers
              to strings or LONGs, and is terminated with NULL. /M
              eats all strings that don't fit into any other option.
              If there are unfilled /A arguments after parsing they
              steal strings from /M. This makes it possible to, for
              example, write a Copy command template like
              'FROM/A/M,TO/A'. There may be only one /M option in a
              template.</dd>
  <dt>/F</dt><dd>Eats the rest of the line even if there are option
              keywords in it.</dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
<link id="FindArg"/>
<link id="ReadItem"/>
<link id="FreeArgs"/>
<link id="AllocDosObject"/>
<link id="FreeDosObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ReadArgs.Result">
<short>A handle for the memory allocated by <var>ReadArgs()</var>. Must be freed
with <link id="FreeArgs">FreeArgs()</link> later.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadArgs.Template">
<short>Template string.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadArgs.Array_">
<short>Array to be filled with the result values. The array must
be intialized to the default values before calling <var>ReadArgs()</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadArgs.RDArgs">
<short>An optional RDArgs structure determining the type of input to process.</short>
</element>

<!-- function Visibility: default -->
<element name="ReadItem">
<short>Reads a single argument/name from command line</short>
<descr>
Read an item from a given character source. Items are words
or quoted strings separated by whitespace or '=' just like on
the commandline. The separator is unread and the output string
is terminated by a #0 character.
</descr>
<errors>
</errors>
<seealso>
<link id="ReadArgs"/>
<link id="FindArg"/>
<link id="UnGetC"/>
<link id="FGetC"/>
<link id="DosInput"/>
<link id="FreeArgs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ReadItem.Result">
<short>
<dl>
<dt><link id="ITEM_UNQUOTED"/></dt><dd>Normal word read.</dd>
<dt><link id="ITEM_QUOTED"/></dt><dd>Quoted string read.</dd>
<dt><link id="ITEM_NOTHING"/></dt><dd>End of line found. Nothing read.</dd>
<dt><link id="ITEM_EQUAL"/></dt><dd>'=' read. Buffer is empty.</dd>
<dt><link id="ITEM_ERROR"/></dt><dd>An error happened.
<link id="IoErr">IoErr()</link> gives additional information in that case.</dd>
</dl>
</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadItem.Buffer">
<short>Buffer to be filled.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadItem.maxchars">
<short>Size of the buffer. Must be at least 1 (for the #0 terminator).</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadItem.cSource">
<short>A ready to use <link id="TCSource"/> structure or <var>nil</var> which means
'read from the input stream'.</short>
</element>

<!-- function Visibility: default -->
<element name="ReadLink">
<short>Reads the path for a soft filesystem link</short>
<descr>
<p>
  <var>ReadLink()</var> takes a lock/name pair (usually from a failed attempt
  to use them to access an object with packets), and asks the
  filesystem to find the softlink and fill buffer with the modified
  path string.  You then start the resolution process again by
  calling <link id="GetDeviceProc">GetDeviceProc()</link> with the new string from <var>ReadLink()</var>.</p>
<p>
  Soft-links are resolved at access time by a combination of the
  filesystem (by returning <link id="ERROR_IS_SOFT_LINK"/> to dos), and by
  Dos (using <var>ReadLink()</var> to resolve any links that are hit).
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MakeLink"/>
<link id="DosOpen"/>
<link id="Lock"/>
<link id="GetDeviceProc"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ReadLink.Result">
<short>
<dl>
  <dt>&gt;= 0</dt><dd>Length of resolved filename in case of success</dd>
  <dt>= -1</dt><dd>Failure, see <link id="IoErr">IoErr()</link> for more information</dd>
  <dt>= -2</dt><dd>Buffer size was too small to store resolved filename</dd>
</dl>
</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadLink.Port">
<short>MsgPort of the filesystem</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadLink.Lock">
<short>Lock this path is relative to on the filesystem</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadLink.Path">
<short><!--Path that caused the <link id="ERROR_IS_SOFT_LINK"/--></short>
</element>

<!-- argument Visibility: default -->
<element name="ReadLink.buffer">
<short>Pointer to buffer for new path from handler.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadLink.size">
<short>Size of buffer.</short>
</element>

<!-- function Visibility: default -->
<element name="Relabel">
<short>Change the volume name of a volume</short>
<descr>Changes the volumename of a volume, if supported by the filesystem.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Relabel.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Relabel.drive">
<short>Full name of device to rename (with ':')</short>
</element>

<!-- argument Visibility: default -->
<element name="Relabel.newname">
<short>New name to apply to device (without ':')</short>
</element>

<!-- function Visibility: default -->
<element name="RemAssignList">
<short>Remove an entry from a multi-dir assign</short>
<descr><p>
Remove an entry from a multi-dir assign. The entry removed will be
the first one that the <link id="SameLock">SameLock()</link> function called on the <var>lock</var>
parameter returns that they belong to the same object.</p>
<p>
The entry for this lock will be removed from the lock, and the
lock for the entry in the list will be unlocked.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="AssignLock"/>
<link id="AssignPath"/>
<link id="AssignLate"/>
<link id="DupLock"/>
<link id="AssignAdd"/>
<link id="UnLock"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RemAssignList.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RemAssignList.Name">
<short>Name of device to remove lock from (without trailing ':')</short>
</element>

<!-- argument Visibility: default -->
<element name="RemAssignList.Lock">
<short>Lock associated with the object to remove from the list</short>
</element>

<!-- function Visibility: default -->
<element name="RemDosEntry">
<short>Removes a Dos List entry from it's list</short>
<descr>
  This removes an entry from the Dos Device list.  The memory associated
  with the entry is <b>not</b> freed.  NOTE: you must have locked the Dos List
  with the appropriate flags before calling this routine.  Handler
  writers should see the <link id="AddDosEntry">AddDosEntry()</link>
  caveats about locking and use a similar workaround to avoid deadlocks.
</descr>
<errors>
</errors>
<seealso>
<link id="AddDosEntry"/>
<link id="FindDosEntry"/>
<link id="NextDosEntry"/>
<link id="LockDosList"/>
<link id="MakeDosEntry"/>
<link id="FreeDosEntry"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RemDosEntry.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RemDosEntry.DList">
<short>Device list entry to be removed.</short>
</element>

<!-- function Visibility: default -->
<element name="RemSegment">
<short>Removes a resident segment from the resident list</short>
<descr>
  Removes a resident segment from the Dos resident segment list,
  unloads it, and does any other cleanup required.  Will only succeed
  if the <link id="TSegment">seg_UC</link> (usecount) is 0.
</descr>
<errors>
</errors>
<seealso>
<link id="FindSegment"/>
<link id="AddSegment"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RemSegment.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RemSegment.seg">
<short>The segment to be removed</short>
</element>

<!-- procedure Visibility: default -->
<element name="ReplyPkt">
<short>Replies a packet to the person who sent it to you</short>
<descr>
  This returns a packet to the process which sent it to you.  In
  addition, puts your pr_MsgPort address in dp_Port, so using ReplyPkt()
  again will send the message to you.  (This is used in "ping-ponging"
  packets between two processes).  It uses result 1 and 2 to set the
  <link id="TDosPacket">dp_Res1</link> and <link id="TDosPacket">dp_Res2</link>dp_Res2 fields of the packet.
</descr>
<errors>
</errors>
<seealso>
<link id="DoPkt"/>
<link id="SendPkt"/>
<link id="WaitPkt"/>
<link id="IoErr"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ReplyPkt.dp">
<short>Packet to reply, assumed to set up correctly.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReplyPkt.res1">
<short>First result</short>
</element>

<!-- argument Visibility: default -->
<element name="ReplyPkt.res2">
<short>Secondary result</short>
</element>

<!-- function Visibility: default -->
<element name="RunCommand">
<short>Runs a program using the current process</short>
<descr><p>
  Runs a command on your process/cli.  <var>Seg</var> may be any language,
  including BCPL programs.  <var>Stack</var> is in bytes.  <var>paramptr</var> is a null-
  terminated string, <var>paramlen</var> is its length. Returns the returncode the
  program exited. Returns -1 if the stack couldn't be
  allocated.</p>
<p>
  NOTE: the argument string <b>must</b> be terminated with a newline to work
  properly with <link id="ReadArgs">ReadArgs()</link> and other argument parsers.</p>
<p>
  RunCommand also takes care of setting up the current input filehandle
  in such a way that <link id="ReadArgs">ReadArgs()</link> can be used in the program, and restores
  the state of the buffering before returning.  It also sets the value
  returned by <link id="GetArgStr">GetArgStr()</link>, and restores it before returning.</p>
<p>
  It's usually appropriate to set the command name (via
  <link id="SetProgramName">SetProgramName()</link>) before
  calling <link id="RunCommand">RunCommand()</link>.  <link id="RunCommand">RunCommand()</link> sets
  the value returned by <link id="GetArgStr">GetArgStr()</link> while the command is running.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CreateNewProc"/>
<link id="SystemTagList"/>
<link id="Execute"/>
<link id="GetArgStr"/>
<link id="SetProgramName"/>
<link id="ReadArgs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RunCommand.Result">
<short>Return code from executed command. -1 indicates failure</short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.SegList">
<short>Seglist of command to run.</short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.StackSize">
<short>Number of bytes to allocate for stack space</short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.argptr">
<short>Pointer to argument command string.</short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.ArgSize">
<short>Number of bytes in argument command string.</short>
</element>

<!-- function Visibility: default -->
<element name="SameDevice">
<short>Are two locks are on partitions of the device?</short>
<descr>
  <var>SameDevice()</var> returns whether two locks refer to partitions that
  are on the same physical device (if it can figure it out).  This
  may be useful in writing copy routines to take advantage of
  asynchronous multi-device copies.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SameDevice.Result">
<short>Whether they're on the same device as far as Dos can determine. <link id="DosTrue"/> </short>
</element>

<!-- argument Visibility: default -->
<element name="SameDevice.lock1">
<short>Lock to compare</short>
</element>

<!-- argument Visibility: default -->
<element name="SameDevice.lock2">
<short>Lock to compare</short>
</element>

<!-- function Visibility: default -->
<element name="SameLock">
<short>Returns whether two locks are on the same object</short>
<descr>
  Compares two locks.  Returns <link id="LOCK_SAME"/> if they are on the same object,
  <link id="LOCK_SAME_HANDLER"/> if on different objects on the same volume, and
  <link id="LOCK_DIFFERENT"/> if they are on different volumes.  Always compare
  for equality or non-equality with the results, in case new return
  values are added.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SameLock.Result">
<short><link id="LOCK_SAME"/>, <link id="LOCK_SAME_HANDLER"/> or  <link id="LOCK_DIFFERENT"/></short>
</element>

<!-- argument Visibility: default -->
<element name="SameLock.lock1">
<short>1st lock for comparison</short>
</element>

<!-- argument Visibility: default -->
<element name="SameLock.lock2">
<short>2nd lock for comparison</short>
</element>

<!-- function Visibility: default -->
<element name="SelectInput">
<short>Select a filehandle as the default input channel</short>
<descr>
  Set the current input as the default input for the process.
  This changes the value returned by <link id="DosInput">DosInput()</link>.  old_fh should
  be closed or saved as needed.

</descr>
<errors>
</errors>
<seealso>
<link id="DosInput"/>
<link id="SelectOutput"/>
<link id="DosOutput"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SelectInput.Result">
<short>Previous default input filehandle</short>
</element>

<!-- argument Visibility: default -->
<element name="SelectInput.fh">
<short>Newly default input handle</short>
</element>

<!-- function Visibility: default -->
<element name="SelectOutput">
<short>Select a filehandle as the default output channel</short>
<descr>
  Set the current output as the default output for the process.
  This changes the value returned by <link id="DosOutput">Output()</link>.  old_fh should
  be closed or saved as needed.
</descr>
<errors>
</errors>
<seealso>
<link id="DosInput"/>
<link id="SelectInput"/>
<link id="DosOutput"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SelectOutput.Result">
<short>Previous current output</short>
</element>

<!-- argument Visibility: default -->
<element name="SelectOutput.fh">
<short>Newly desired output handle</short>
</element>

<!-- procedure Visibility: default -->
<element name="SendPkt">
<short>Sends a packet to a handler</short>
<descr>
  Sends a packet to a handler and does not wait.  All fields in the
  packet must be initialized before calling this routine.  The packet
  will be returned to replyport.  If you wish to use this with
  <link id="WaitPkt">WaitPkt()</link>, use the address of your
  <link id="TProcess">pr_MsgPort</link> for replyport.
</descr>
<errors>
</errors>
<seealso>
<link id="DoPkt"/>
<link id="WaitPkt"/>
<link id="AllocDosObject"/>
<link id="FreeDosObject"/>
<link id="AbortPkt"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="SendPkt.dp">
<short>Packet to send, must be initialized and have a message.</short>
</element>

<!-- argument Visibility: default -->
<element name="SendPkt.Port">
<short><link id="TProcess">pr_MsgPort</link> of handler process to send to.</short>
</element>

<!-- argument Visibility: default -->
<element name="SendPkt.replyport">
<short>MsgPort for the packet to come back to.</short>
</element>

<!-- function Visibility: default -->
<element name="SetArgStr">
<short>Sets the arguments for the current process</short>
<descr>
  Sets the arguments for the current program.  The ptr MUST be reset
  to it's original value before process exit.
</descr>
<errors>
</errors>
<seealso>
<link id="GetArgStr"/>
<link id="RunCommand"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetArgStr.Result">
<short>The previous argument string, can be <var>nil</var></short>
</element>

<!-- argument Visibility: default -->
<element name="SetArgStr.string_">
<short>Pointer to new argument string.</short>
</element>

<!-- function Visibility: default -->
<element name="SetComment">
<short>Change a files' comment string</short>
<descr>
  <var>SetComment()</var> sets a comment on a file or directory. The comment is
  a pointer to a null-terminated string of up to 80 characters in the
  current ROM filesystem (and RAM:).  Note that not all filesystems
  will support comments (for example, NFS usually will not), or the
  size of comment supported may vary.
</descr>
<errors>
</errors>
<seealso>
<link id="Examine"/>
<link id="ExNext"/>
<link id="SetProtection"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetComment.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetComment.Name">
<short>Name of File to set comment</short>
</element>

<!-- argument Visibility: default -->
<element name="SetComment.comment">
<short>Comment to set</short>
</element>

<!-- function Visibility: default -->
<element name="SetConsoleTask">
<short>ets the default console for the process</short>
<descr>
  Sets the default console task's port (<link id="TProcess">pr_ConsoleTask</link>) for the
  current process.
</descr>
<errors>
</errors>
<seealso>
<link id="GetConsoleTask"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetConsoleTask.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetConsoleTask.Handler">
<short>The <link id="TProcess">pr_MsgPort</link> of the default console handler for the process</short>
</element>

<!-- function Visibility: default -->
<element name="SetCurrentDirName">
<short>Sets the directory name for the process</short>
<descr>
  Sets the name for the current dir in the cli structure.  If the name
  is too long to fit, a failure is returned, and the old value is left
  intact.  It is advised that you inform the user of this condition.
  This routine is safe to call even if there is no CLI structure.
</descr>
<errors>
</errors>
<seealso>
<link id="GetCurrentDirName"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetCurrentDirName.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetCurrentDirName.Name">
<short>Name of directory to be set.</short>
</element>

<!-- function Visibility: default -->
<element name="SetFileDate">
<short>Sets the modification date for a file or dir</short>
<descr>
  Sets the file date for a file or directory.  Note that for the Old
  File System and the Fast File System, the date of the root directory
  cannot be set.  Other filesystems may not support setting the date
  for all files/directories.
</descr>
<errors>
</errors>
<seealso>
<link id="DateStamp"/>
<link id="Examine"/>
<link id="ExNext"/>
<link id="ExAll"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetFileDate.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileDate.Name">
<short>Name of object</short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileDate.date">
<short>New modification date</short>
</element>

<!-- function Visibility: default -->
<element name="SetFileSize">
<short>Sets the size of a file</short>
<descr><p>
  Changes the file size, truncating or extending as needed.  Not all
  handlers may support this; be careful and check the return code.  If
  the file is extended, no values should be assumed for the new bytes.
  If the new position would be before the filehandle's current position
  in the file, the filehandle will end with a position at the
  end-of-file.  If there are other filehandles open onto the file, the
  new size will not leave any filehandle pointing past the end-of-file.
  You can check for this by looking at the new size (which would be
  different than what you requested).</p>
<p>
  The seek position should not be changed unless the file is made
  smaller than the current seek position.  However, see Errors.</p>
<p>
  Do NOT count on any specific values to be in any extended area.</p>
</descr>
<errors><p>
  The RAM: filesystem and the normal Amiga filesystem act differently
  in where the file position is left after <link id="SetFileSize">SetFileSize()</link>.  RAM: leaves
  you at the new end of the file (incorrectly), while the Amiga ROM
  filesystem leaves the seek position alone, unless the new position
  is less than the current position, in which case you're left at the
  new EOF.</p>
<p>
  The best workaround is to not make any assumptions about the seek
  position after <link id="SetFileSize">SetFileSize()</link>.</p>
</errors>
<seealso>
<link id="DosSeek"/>
</seealso>
</element>


<!-- function result Visibility: default -->
<element name="SetFileSize.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileSize.File_">
<short>File to be truncated/extended.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileSize.Offset">
<short>Offset from position determined by mode.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileSize.Mode">
<short>One of <link id="OFFSET_BEGINNING"/>, <link id="OFFSET_CURRENT"/>, or <link id="OFFSET_END"/>.</short>
</element>

<!-- function Visibility: default -->
<element name="SetFileSysTask">
<short>Sets the default filesystem for the process</short>
<descr>
Sets the default filesystem task's port (<link id="TProcess">pr_FileSystemTask</link>) for the current process.
</descr>
<errors>
</errors>
<seealso>
<link id="GetFileSysTask"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetFileSysTask.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileSysTask.task">
<short>The <link id="TProcess">pr_MsgPort</link> of the default filesystem for the process</short>
</element>

<!-- function Visibility: default -->
<element name="SetIoErr">
<short>Sets the value returned by IoErr()</short>
<descr>
This routine sets up the secondary result (<link id="TProcess">pr_Result2</link>) return code
  (returned by the <link id="IoErr">IoErr()</link> function).
</descr>
<errors>
</errors>
<seealso>
<link id="IoErr"/>
<link id="Fault"/>
<link id="PrintFault"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetIoErr.Result_">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="SetMode">
<short>Set the current behavior of a handler</short>
<descr>
  <var>SetMode()</var> sends an <link id="ACTION_SCREEN_MODE"/> packet to the handler in
  question, normally for changing a CON: handler to raw mode or
  vice-versa.  For CON:, use 1 to go to RAW: mode, 0 for CON: mode.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetMode.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetMode.fh">
<short>filehandle</short>
</element>

<!-- argument Visibility: default -->
<element name="SetMode.mode">
<short>The new mode you want</short>
</element>

<!-- function Visibility: default -->
<element name="SetOwner">
<short>Set owner information for a file or directory</short>
<descr>
<p>
  <var>SetOwner()</var> sets the owner information for the file or directory.
  This value is a 32-bit value that is normally split into 16 bits
  of owner user id (bits 31-16), and 16 bits of owner group id (bits
  15-0).  However, other than returning them as shown by <link id="Examine">Examine()</link>/
  <link id="ExNext">ExNext()</link>/<link id="ExAll">ExAll()</link>, the filesystem take no interest in the values.
  These are primarily for use by networking software (clients and
  hosts), in conjunction with the FIBF_OTR_* and FIBF_GRP_*
  protection bits.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Examine"/>
<link id="ExNext"/>
<link id="ExAll"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetOwner.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetOwner.Name">
<short>Name of file</short>
</element>

<!-- argument Visibility: default -->
<element name="SetOwner.owner_info">
<short>Owner uid (31:16) and group id (15:0)</short>
</element>

<!-- function Visibility: default -->
<element name="SetProgramDir">
<short>Sets the directory returned by <link id="GetProgramDir">GetProgramDir</link></short>
<descr>
  Sets a shared lock on the directory the program was loaded from.
  This can be used for a program to find data files, etc, that are
  stored with the program, or to find the program file itself.  <var>Nil</var>
  is a valid input.  This can be accessed via <link id="GetProgramDir">GetProgramDir</link> or
  by using paths relative to PROGDIR:.
</descr>
<errors>
</errors>
<seealso>
<link id="GetProgramDir"/>
<link id="DosOpen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetProgramDir.Result">
<short>The previous ProgramDir.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetProgramDir.Lock">
<short>A lock on the directory the current program was loaded from</short>
</element>

<!-- function Visibility: default -->
<element name="SetProgramName">
<short>Sets the name of the program being run</short>
<descr>
  Sets the name for the program in the cli structure.  If the name is
  too long to fit, a failure is returned, and the old value is left
  intact.  It is advised that you inform the user if possible of this
  condition, and/or set the program name to an empty string.
  This routine is safe to call even if there is no CLI structure.
</descr>
<errors>
</errors>
<seealso>
<link id="GetProgramName"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetProgramName.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetProgramName.Name">
<short>New Name of Program</short>
</element>

<!-- function Visibility: default -->
<element name="SetPrompt">
<short>Sets the CLI/shell prompt for the current process</short>
<descr>
  Sets the text for the prompt in the cli structure.  If the prompt is
  too long to fit, a failure is returned, and the old value is left
  intact.  It is advised that you inform the user of this condition.
  This routine is safe to call even if there is no CLI structure.
</descr>
<errors>
</errors>
<seealso>
<link id="GetPrompt"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetPrompt.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetPrompt.Name">
<short>Name of prompt to be set.</short>
</element>

<!-- function Visibility: default -->
<element name="SetProtection">
<short>Set protection for a file or directory
</short>
<descr>
  Sets the protection attributes on a file or
  directory. Use FIBF_* for protection bits.
  The archive bit should be cleared by the
  filesystem whenever the file is changed.
  Backup utilities will generally set the bit after
  backing up each file.
</descr>
<errors>
</errors>
<seealso>
<link id="SetComment"/>
<link id="Examine"/>
<link id="ExNext"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetProtection.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetProtection.Name">
<short>Name of File</short>
</element>

<!-- argument Visibility: default -->
<element name="SetProtection.protect">
<short>Protection Mask required</short>
</element>

<!-- function Visibility: default -->
<element name="SetVar">
<short>Sets a local or environment variable</short>
<descr><p>Sets a local or environment variable.  It is advised to only use
  ASCII strings inside variables, but not required.</p>
<dl>
  <dt><link id="GVF_LOCAL_ONLY"/></dt><dd>set a local (to your process) variable.</dd>
  <dt><link id="GVF_GLOBAL_ONLY"/></dt><dd>set a global environment variable.</dd>
</dl>
<p>The default is to set a local environment variable.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetVar"/>
<link id="DeleteVar"/>
<link id="FindVar"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetVar.Result">
<short>If non-zero, the variable was sucessfully set, False
      indicates failure.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetVar.Name">
<short>pointer to an variable name.  Note variable names follow
     filesystem syntax and semantics.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetVar.buffer">
<short>a user allocated area which contains a string that is the
     value to be associated with this variable.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetVar.size">
<short>combination of type of var to set (low 8 bits), and
     flags to control the behavior of this routine. </short>
</element>

<!-- argument Visibility: default -->
<element name="SetVar.Flags">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="SetVBuf">
<short>Set buffering modes and size</short>
<descr><p>
  Changes the buffering modes and buffer size for a filehandle.
  With buff = <var>nil</var>, the current buffer will be deallocated and a
  new one of (approximately) size will be allocated.  If buffer is
  non-<var>nil</var>, it will be used for buffering and must be at least
  max(size,208) bytes long, and <b>must</b> be longword aligned.  If size
  is -1, then only the buffering mode will be changed.</p>
<p>
  Note that a user-supplied buffer will not be freed if it is later
  replaced by another <var>SetVBuf()</var> call, nor will it be freed if the
  filehandle is closed.</p>
<p>
  Has no effect on the buffersize of filehandles that were not created
  by <link id="AllocDosObject">AllocDosObject()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FPutC"/>
<link id="FGetC"/>
<link id="UnGetC"/>
<link id="DosFlush"/>
<link id="FRead"/>
<link id="FWrite"/>
<link id="FGets"/>
<link id="FPuts"/>
<link id="AllocDosObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetVBuf.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetVBuf.File_">
<short>Filehandle</short>
</element>

<!-- argument Visibility: default -->
<element name="SetVBuf.buff">
<short>Buffer pointer for buffered I/O or <var>nil</var>.  <b>Must</b> be 4-aligned!</short>
</element>

<!-- argument Visibility: default -->
<element name="SetVBuf.Type_">
<short>buffering mode (BUF_*)</short>
</element>

<!-- argument Visibility: default -->
<element name="SetVBuf.size">
<short>Size of buffer for buffered I/O (sizes less than 208 bytes will be rounded up to 208), or -1.</short>
</element>

<!-- function Visibility: default -->
<element name="SplitName">
<short>splits out a component of a pathname into a buffer</short>
<descr><p>
  This routine splits out the next piece of a name from a given file
  name.  Each piece is copied into the buffer, truncating at <var>size</var>-1
  characters.  The new position is then returned so that it may be
  passed in to the next call to splitname.  If the separator is not
  found within <var>size</var> characters, then <var>size</var>-1 characters plus a null will
  be put into the buffer, and the position of the next separator will
  be returned.</p>
<p>
  If a a separator cannot be found, -1 is returned (but the characters
  from the old position to the end of the string are copied into the
  buffer, up to a maximum of <var>size</var>-1 characters).  Both strings are
  null-terminated.</p>
<p>
  This function is mainly intended to support handlers.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FilePart"/>
<link id="PathPart"/>
<link id="AddPart"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SplitName.Result">
<short>New position for next call to splitname. -1 for last one.</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitName.Name">
<short>Filename being parsed.</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitName.seperator">
<short>Separator charactor to split by.</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitName.buf">
<short>Buffer to hold separated name.</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitName.oldpos">
<short>Current position in the file.</short>
</element>

<!-- argument Visibility: default -->
<element name="SplitName.size">
<short>Size of buf in bytes (including null termination).</short>
</element>

<!-- function Visibility: default -->
<element name="StartNotify">
<short>Starts notification on a file or directory</short>
<descr>
  Posts a notification request.  Do not modify the notify structure while
  it is active.  You will be notified when the file or directory changes.
  For files, you will be notified after the file is closed.  Not all
  filesystems will support this: applications should <b>not</b> require it.  In
  particular, most network filesystems won't support it.
</descr>
<errors>
</errors>
<seealso>
<link id="EndNotify"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="StartNotify.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="StartNotify.notify">
<short>A filled-in NotifyRequest structure</short>
</element>

<!-- function Visibility: default -->
<element name="StrToLong">
<short>string to Integer value (decimal)</short>
<descr>
  Converts decimal string into Integer value. Returns number of characters
  converted.  Skips over leading spaces and tabs (included in count).  If
  no decimal digits are found (after skipping leading spaces and tabs),
  <var>StrToLong()</var> returns -1 for characters converted, and puts 0 into value.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="StrToLong.Result">
<short>Number of characters converted or -1.</short>
</element>

<!-- argument Visibility: default -->
<element name="StrToLong.string_">
<short>Input string.</short>
</element>

<!-- argument Visibility: default -->
<element name="StrToLong.value">
<short>Pointer to integer value.  Set to 0 if no digits are converted.</short>
</element>

<!-- function Visibility: default -->
<element name="SystemTagList">
<short>Have a shell execute a command line</short>
<descr><p>
  Similar to <link id="Execute">Execute()</link>, but does not read commands from the input
  filehandle.  Spawns a Shell process to execute the command, and
  returns the returncode the command produced, or -1 if the command
  could not be run for any reason.  The input and output filehandles
  will not be closed by System, you must close them (if needed) after
  System returns, if you specified them via <link id="SYS_Input"/> or <link id="SYS_Output"/>.</p>
<p>
  By default the new process will use your current <link id="DosInput">DosInput()</link>
  and <link id="DosOutput">Output()</link>
  filehandles.  Normal Shell command-line parsing will be done
  including redirection on <var>command</var>. The current directory and path
  will be inherited from your process.  Your path will be used to find
  the command (if no path is specified).</p>
<p>
  Note that you may NOT pass the same filehandle for both <link id="SYS_Input"/>
  and <link id="SYS_Output"/>.  If you want input and output to both be to the same
  CON: window, pass a SYS_Input of a filehandle on the CON: window,
  and pass a <link id="SYS_Output"/> of <var>nil</var>.  The shell will automatically set
  the default Output() stream to the window you passed via <link id="SYS_Input"/>,
  by opening '*' on that handler.</p>
<p>
  If used with the <link id="SYS_Asynch"/> flag, it <b>will</b> close both it's input and
  output filehandles after running the command (even if these were
  your <link id="DosInput">DosInput()</link> and <link id="DosOutput">Output()</link>!)</p>
<p>
  Normally uses the boot (ROM) shell, but other shells can be specified
  via <link id="SYS_UserShell"/> and <link id="SYS_CustomShell"/>.  Normally, you should send
  things written by the user to the UserShell.  The UserShell defaults
  to the same shell as the boot shell.</p>
<p>
  The tags are passed through to <link id="CreateNewProc">CreateNewProc()</link> (tags that conflict
  with <link id="SystemTagList">SystemTagList()</link> will be filtered out).  This allows setting
  things like priority, etc for the new process.  The tags that are
  currently filtered out are:</p>
<ul>
  <li>NP_Seglist</li>
  <li>NP_FreeSeglist</li>
  <li>NP_Entry</li>
  <li>NP_Input</li>
  <li>NP_Output</li>
  <li>NP_CloseInput</li>
  <li>NP_CloseOutput</li>
  <li>NP_HomeDir</li>
  <li>NP_Cli</li>
</ul>
</descr>
<errors>
</errors>
<seealso>
<link id="Execute"/>
<link id="CreateNewProc"/>
<link id="DosInput"/>
<link id="DosOutput"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SystemTagList.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SystemTagList.command">
<short>Program and arguments</short>
</element>

<!-- argument Visibility: default -->
<element name="SystemTagList.Tags">
<short>Tags for start (SYS_*) some (NP_*)</short>
</element>

<!-- function Visibility: default -->
<element name="UnGetC">
<short>Makes a char available for reading again. (buffered)</short>
<descr><p>
  Pushes the character specified back into the input buffer.  Every
  time you use a buffered read routine, you can always push back 1
  character.  You may be able to push back more, though it is not
  recommended, since there is no guarantee on how many can be
  pushed back at a given moment.</p>
<p>
  Passing -1 for the character will cause the last character read to
  be pushed back.  If the last character read was an EOF, the next
  character read will be an EOF.</p>
<p>
  Note: <var>UnGetC</var> can be used to make sure that a filehandle is set up
  as a read filehandle.  This is only of importance if you are writing
  a shell, and must manipulate the filehandle's buffer.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnGetC.Result">
<short>Character pushed back, or False if the character cannot be pushed back.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnGetC.File_">
<short>Filehandle to use for buffered I/O</short>
</element>

<!-- argument Visibility: default -->
<element name="UnGetC.character">
<short>Character to push back or -1</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnLoadSeg">
<short>Unload a seglist previously loaded by <link id="LoadSeg">LoadSeg()</link></short>
<descr>
  Unload a seglist loaded by <link id="LoadSeg">LoadSeg()</link>.  <var>seglist</var>> may be zero.
  Overlaid segments will have all needed cleanup done, including
  closing files.
</descr>
<errors>
</errors>
<seealso>
<link id="LoadSeg"/>
<link id="InternalLoadSeg"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnLoadSeg.seglist">
<short>Pointer to a segment identifier</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnLock">
<short>Unlock a directory or file</short>
<descr>
The filing system lock (obtained from <link id="Lock">Lock()</link>, <link id="DupLock">DupLock()</link>, or
  <link id="DOSCreateDir">DOSCreateDir()</link>) is removed and deallocated.
</descr>
<errors>
</errors>
<seealso>
<link id="Lock"/>
<link id="DupLock"/>
<link id="ParentOfFH"/>
<link id="DupLockFromFH"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnLock.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="UnLock.Lock">
<short>Lock to unlock, zero is harmless</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnLockDosList">
<short>Unlocks the Dos List</short>
<descr>
Unlocks the access on the Dos Device List.  You <b>must</b> pass the same
flags you used to lock the list.
</descr>
<errors>
</errors>
<seealso>
<link id="AttemptLockDosList"/>
<link id="LockDosList"/>
<link id="Exec.Permit">Permit</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnLockDosList.Flags">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="UnLockRecord">
<short>Unlock a record</short>
<descr>
  This releases the specified lock on a file.  Note that you must use
  the same filehandle you used to lock the record, and offset and length
  must be the same values used to lock it.  Every <link id="LockRecord">LockRecord()</link> call must
  be balanced with an <var>UnLockRecord()</var> call.
</descr>
<errors>
</errors>
<seealso>
<link id="LockRecords"/>
<link id="LockRecord"/>
<link id="UnLockRecords"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnLockRecord.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="UnLockRecord.fh">
<short>File handle of locked file</short>
</element>

<!-- argument Visibility: default -->
<element name="UnLockRecord.offset">
<short>Record start position</short>
</element>

<!-- argument Visibility: default -->
<element name="UnLockRecord.length">
<short>Length of record in bytes</short>
</element>

<!-- function Visibility: default -->
<element name="UnLockRecords">
<short>Unlock a list of records</short>
<descr>
  This releases an array of record locks obtained using LockRecords.
  You should <b>not</b> modify the record_array while you have the records
  locked.  Every <link id="LockRecords">LockRecords()</link> call must be balanced with an
  <var>UnLockRecords()</var> call.
</descr>
<errors>
</errors>
<seealso>
<link id="LockRecords"/>
<link id="LockRecord"/>
<link id="UnLockRecord"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnLockRecords.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="UnLockRecords.recArray">
<short>List of records to be unlocked</short>
</element>

<!-- function Visibility: default -->
<element name="VFPrintf">
<short>format and print a string to a file (buffered)</short>
<descr>
  Writes the formatted string and values to the given file.  This
  routine is assumed to handle all internal buffering so that the
  formatting string and resultant formatted values can be arbitrarily
  long.  Any secondary error code is returned in <link id="IoErr">IoErr()</link>.  This routine
  is buffered.
</descr>
<errors>
</errors>
<seealso>
<link id="VPrintf"/>
<link id="VFWritef"/>
<link id="Exec.RawDoFmt">RawDoFmt</link>
<link id="FPutC"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="VFPrintf.Result">
<short>Number of bytes written or -1 (EOF) for an error</short>
</element>

<!-- argument Visibility: default -->
<element name="VFPrintf.fh">
<short>Filehandle to write to</short>
</element>

<!-- argument Visibility: default -->
<element name="VFPrintf.format">
<short><link id="Exec.RawDoFmt">RawDoFmt()</link> style formatting string</short>
</element>

<!-- argument Visibility: default -->
<element name="VFPrintf.argarray">
<short>Pointer to array of formatting values</short>
</element>

<!-- procedure Visibility: default -->
<element name="VFWritef">
<short>Write a BCPL formatted string to a file (buffered)</short>
<descr>
<p>
  Writes the formatted string and values to the specified file.  This
  routine is assumed to handle all internal buffering so that the
  formatting string and resultant formatted values can be arbitrarily
  long.  The formats are in BCPL form.  This routine is buffered.</p>
<p>
  Supported formats are:  (Note x is in base 36!)</p>
<dl>
  <dt>%S</dt><dd>string (CSTR)</dd>
  <dt>%Tx</dt><dd>writes a left-justified string in a field at least
          x bytes long.</dd>
  <dt>%C</dt><dd>writes a single character</dd>
  <dt>%Ox</dt><dd>writes a number in octal, maximum x characters wide</dd>
  <dt>%Xx</dt><dd>writes a number in hex, maximum x characters wide</dd>
  <dt>%Ix</dt><dd>writes a number in decimal, maximum x characters wide</dd>
  <dt>%N</dt><dd>writes a number in decimal, any length</dd>
  <dt>%Ux</dt><dd>writes an unsigned number, maximum x characters wide</dd>
  <dt>%$</dt><dd>ignore parameter</dd>
</dl><p>
  Note: 'x' above is actually the character value - '0'.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="VPrintf"/>
<link id="VFPrintf"/>
<link id="FPutC"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="VFWritef.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="VFWritef.fh">
<short>Filehandle to write to</short>
</element>

<!-- argument Visibility: default -->
<element name="VFWritef.Fmt">
<short>BCPL style formatting string</short>
</element>

<!-- argument Visibility: default -->
<element name="VFWritef.argarray">
<short>Pointer to array of formatting values</short>
</element>

<!-- function Visibility: default -->
<element name="VPrintf">
<short>Format and print string (buffered)</short>
<descr><p>
  Writes the formatted string and values to <link id="DosOutput">DosOutput()</link>.  This routine is
  assumed to handle all internal buffering so that the formatting string
  and resultant formatted values can be arbitrarily long.  Any secondary
  error code is returned in <link id="IoErr">IoErr()</link>.  This routine is buffered.</p>
<p>
  Note: RawDoFmt assumes 16 bit ints, so you will usually need 'l's in
  your formats (ex: %ld versus %d).</p>
</descr>
<errors>
</errors>
<seealso>
<link id="VFPrintf"/>
<link id="VFWritef"/>
<link id="Exec.RawDoFmt">RawDoFmt</link>
<link id="FPutC"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="VPrintf.Result">
<short>Number of bytes written or -1 (EOF) for an error</short>
</element>

<!-- argument Visibility: default -->
<element name="VPrintf.format">
<short>exec.library <link id="Exec.RawDoFmt">RawDoFmt</link> style formatting string</short>
</element>

<!-- argument Visibility: default -->
<element name="VPrintf.argarray">
<short>Pointer to array of formatting values</short>
</element>

<!-- function Visibility: default -->
<element name="WaitForChar">
<short>Determine if chars arrive within a time limit</short>
<descr>
  If a character is available to be read from <var>file</var> within the
  time (in microseconds) indicated by <var>timeout</var>, <var>WaitForChar()</var>
  returns -1 (True). If a character is available, you can use Read()
  to read it.  Note that <var>WaitForChar()</var> is only valid when the I/O
  stream is connected to a virtual terminal device. If a character is
  not available within <var>timeout</var>, a 0 (False) is returned.
</descr>
<errors>
</errors>
<seealso>
<link id="DosRead"/>
<link id="FGetC"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WaitForChar.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="WaitForChar.file_">
<short>BCPL pointer to a file handle</short>
</element>

<!-- argument Visibility: default -->
<element name="WaitForChar.timeout">
<short>In miliseconds</short>
</element>

<!-- function Visibility: default -->
<element name="WaitPkt">
<short> Waits for a packet to arrive at your <link id="TProcess">pr_MsgPort</link></short>
<descr>
  Waits for a packet to arrive at your <link id="TProcess">pr_MsgPort</link>.
  If anyone has installed a packet wait function in
  <link id="TProcess">pr_PktWait</link>, it will be called.
  The message will be automatically <link id="exec.GetMsg">GetMsg()</link>ed so that it is no longer
  on the port.  It assumes the message is a dos packet.  It is <b>not</b>
  guaranteed to clear the signal for the port.
</descr>
<errors>
</errors>
<seealso>
<link id="SendPkt"/>
<link id="DoPkt"/>
<link id="AbortPkt"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WaitPkt.Result">
<short>the packet that arrived at the port (from <link id="Exec.TNode">ln_Name</link> of message).</short>
</element>

<!-- function Visibility: default -->
<element name="WriteChars">
<short>Writes bytes to the the default output (buffered)</short>
<descr>
This routine writes a number of bytes to the default output.  The
length is returned. This routine is buffered.
</descr>
<errors>
</errors>
<seealso>
<link id="FPuts"/>
<link id="FPutC"/>
<link id="FWrite"/>
<link id="PutStr"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WriteChars.Result">
<short>Number of bytes written. -1 (EOF) indicates an error</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteChars.buf">
<short>Buffer of characters to write</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteChars.buflen">
<short>Number of characters to write
</short>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Flags">
<short>EXEC message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Size">
<short>Size of buffered io buffer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TFileHandle.fh_Buf2">
<short>Always the same as <var>fh_Buf</var></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosList.dol_Unused">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRootNode.rn_RootLock">
<short>RootNode arbitrator</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDosLibrary">
<short>This is how the base of dos.library looks like.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDosLibrary">
<short>This is how the base of dos.library looks like.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosLibrary.dl_lib">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosLibrary.dl_Root">
<short>Pointer to RootNode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosLibrary.dl_Errors">
<short>Pointer to array of error msgs</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosLibrary.dl_TimeReq">
<short>Private pointer to timer request</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosLibrary.dl_UtilityBase">
<short>Private ptr to utility library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDosLibrary.dl_IntuitionBase">
<short>Private ptr to intuition library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AllocDosObjectTags">
<short>Variable args version for <link id="AllocDosObject"/> for direct tag use.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AllocDosObjectTags.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObjectTags.Type_">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObjectTags.Tags">
<short>Variable array of Tags use [TAG_1, 1, TAG_2, 2 ....] TAG_END will be automatically added at the end</short>
</element>

<!-- function Visibility: default -->
<element name="CreateNewProcTags">
<short>Variable args version for <link id="CreateNewProc"/> for direct tag use.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CreateNewProcTags.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="CreateNewProcTags.Tags">
<short>Variable array of Tags use [TAG_1, 1, TAG_2, 2 ....] TAG_END will be automatically added at the end</short>
</element>

<!-- function Visibility: default -->
<element name="NewLoadSegTags">
<short>Variable args version for <link id="NewLoadSeg"/> for direct tag use.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NewLoadSegTags.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSegTags.File_">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSegTags.Tags">
<short>Variable array of Tags use [TAG_1, 1, TAG_2, 2 ....] TAG_END will be automatically added at the end</short>
</element>

<!-- function Visibility: default -->
<element name="SystemTags">
<short>Variable args version for <link id="SystemTagList"/> for direct tag use.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SystemTags.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SystemTags.Command">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SystemTags.Tags">
<short>Variable array of Tags use [TAG_1, 1, TAG_2, 2 ....] TAG_END will be automatically added at the end</short>
</element>

<!-- function Visibility: default -->
<element name="MKBADDR">
<short>Conbert a Pointer to a BPTR Value</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MKBADDR.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="MKBADDR.a">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="BADDR">
<short>Convert a BPTR to a Pointer</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BADDR.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="BADDR.a">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="exec">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="utility">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="timer">
<short></short>
</element>

<!-- pointer type Visibility: default -->
<element name="_pDateTime">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="_tDateTime">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="_tDateTime.dat_Stamp">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="_tDateTime.dat_Format">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="_tDateTime.dat_Flags">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="_tDateTime.dat_StrDay">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="_tDateTime.dat_StrDate">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="_tDateTime.dat_StrTime">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosLibrary.dl_GV">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosLibrary.dl_A2">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosLibrary.dl_A5">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosLibrary.dl_A6">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Handler.dol_Handler">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Handler.dol_StackSize">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Handler.dol_Priority">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Handler.dol_Startup">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Handler.dol_SegList">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Handler.dol_GlobVec">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Volume.dol_VolumeDate">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Volume.dol_LockList">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Volume.dol_DiskType">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_assign.dol_AssignName">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_assign.dol_List">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDosList.dol_Misc">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tNotifyRequest.nr_stuff.nr_Msg">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tNotifyRequest.nr_stuff.nr_Msg.nr_Port">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tNotifyRequest.nr_stuff.nr_Signal">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tNotifyRequest.nr_stuff.nr_Signal.nr_Task">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tNotifyRequest.nr_stuff.nr_Signal.nr_SignalNum">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tNotifyRequest.nr_stuff.nr_Signal.nr_pad">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AddBuffers.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AddBuffers.number">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AddSegment.system">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="AllocDosObjectTagList">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AllocDosObjectTagList.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObjectTagList.type_">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObjectTagList.tags">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeMode.fh">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="CreateDir">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CreateDir.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="CreateDir.name">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="CreateNewProcTagList">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CreateNewProcTagList.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="CreateNewProcTagList.tags">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DOSDateToStr">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSDateToStr.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSDateToStr.datetime">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DoPkt0">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoPkt0.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt0.port">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt0.action">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DoPkt1">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoPkt1.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt1.port">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt1.action">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt1.arg1">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DoPkt2">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoPkt2.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt2.port">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt2.action">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt2.arg1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt2.arg2">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DoPkt3">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoPkt3.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt3.port">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt3.action">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt3.arg1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt3.arg2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt3.arg3">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DoPkt4">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoPkt4.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt4.port">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt4.action">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt4.arg1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt4.arg2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt4.arg3">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoPkt4.arg4">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSFlush.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSSeek.offset">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DupLockFromFH.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Execute.file_">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Execute.file2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FGetC.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FindArg.arg_template">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="Format">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Format.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Format.filesystem">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Format.volumename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Format.dostype">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FPutC.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FPutC.ch">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FPuts.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FPuts.str">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FWrite.number">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="Lock.type_">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchEnd.anchor">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchFirst.anchor">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="MatchNext.anchor">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromFH.len">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NameFromLock.len">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="NewLoadSegTagList">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NewLoadSegTagList.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSegTagList.file_">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSegTagList.tags">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePattern.pat">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePattern.buf">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePattern.buflen">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePatternNoCase.pat">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePatternNoCase.buf">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ParsePatternNoCase.buflen">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="PutStr.str">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ReadArgs.arg_template">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ReadArgs.arra">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ReadArgs.args">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ReadItem.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.seg">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.stack">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.paramptr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="RunCommand.paramlen">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetConsoleTask.task">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileSize.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetFileSize.pos">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="SetIoErr.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetVBuf.fh">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DOSStrToDate">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSStrToDate.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSStrToDate.datetime">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="DOSSystem">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DOSSystem.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSSystem.command">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DOSSystem.tags">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="UnGetC.fh">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="VFWritef.format">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="BADDR.bval">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="MKBADDR.adr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocDosObjectTags.argv">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="CreateNewProcTags.argv">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewLoadSegTags.argv">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SystemTags.argv">
<short></short>
</element>


<!-- constant Visibility: default -->
<element name="LEN_DATSTRING">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DTB_SUBST">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DTF_SUBST">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DTB_FUTURE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DTF_FUTURE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FORMAT_DOS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FORMAT_INT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FORMAT_USA">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FORMAT_CDN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FORMAT_MAX">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FORMAT_DEF">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

</module> <!-- amigados -->

</package>
</fpdoc-descriptions>
