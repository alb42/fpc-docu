<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="morphunits">

<!--
  ====================================================================
    CYBERGRAPHICS
  ====================================================================
-->

<module name="cybergraphics">
<short>CyberGraphics System compatbible interface for MorphOS (cybergraphics.library)</short>
<descr>
<p>
CyberGraphics System compatbible interface for MorphOS (cybergraphics.library)
Texts mainly from the official Autodocs http://aminet.net/package/dev/misc/CGraphX-DevKit.lha
and MorphOS SDK.
</p>
<p><b>Purpose</b></p>
<p>
   cybergraphics.library started as a videoboard extension for the
   native C= graphics.library. Because C= never completed/released a RTG
   compliant library (up to and including OS3.1 there was no way to add
   custom extension boards to the display database in a system friendly
   way), CyberGraphX patched some of the original graphics functions in
   order to add custom graphics board support in the system.</p>
  <p>It also featured some new functions which were not available in the
   original graphics.library implementation. Due to the patch approach this
   new functions had to be moved into a new library base, namely
   cybergraphics.library. Both OS3.0 graphics.library v39 and OS 3.1 v40 were
   supported with this patch.</p>
  <p>For the first time, CyberGraphX offered the possibility to open non CLUT
   screens with more than 256 colours which offered complete intuition level
   legacy compatibility.
   Nearly every function could be used on such views except some special
   blits which relied on planar bitmap graphics targets.
   This screens featured 8bit backwards compatibility which means that
   nearly every legacy, standard 8bit application even not aware of truecolour
   abilities worked on this improved screens.
   The pen allocation system, formerly used to lock certain colour indexes for
   shared/exclusive application access, had been fully mapped to this new
   display targets to allow maximum legacy compatibility.</p>
  <p>The additional truecolour features could only be used with CyberGraphX
   aware applications, though. Since there was no similar approach which
   allowed easy adaption of existing applications, CyberGraphX was widely
   adopted as the standard interface for truecolour applications at that time.</p>
  <p>There were attempts to imitate this efforts but those never caught up
   with the widely accepted CyberGraphX API.</p>
<p></p>
 <p>MorphOS builds upon the above approach and still uses both graphics and
   cybergraphics library as it's graphics API layer.
   Additional functions have been added, especially in regard to alpha blending
   support and other additional eyecandy which is commonly used within MorphOS.
   Many of this functions are either GPU or AltiVec accelerated starting with
   Version 2 of MorphOS, dynamically enabled based on the underlying hardware
   which MorphOS has been started on.</p>
<p><b>Overview</b></p>
<p>
This part only describes how to use the extended features of
CyberGraphX. Anything else about programming graphics can be found
in the <link id="agraphics">original graphics.library documentation</link>. Most graphics.library
functions are extended to work on CyberGraphX's 15/16/24 bit
rastports.</p>

<p><b>Bitmaps and CyberGraphX</b></p>
<p>
 Before OS 3.x there was no standard method to create bitmaps.  It was up
to the application programmer to allocate memory for the bitmap structure
and to get the plane pointers by subsequent calls to <link id="agraphics.AllocRaster">AllocRaster()</link>/gfx.  A
<link id="agraphics.InitBitmap">InitBitMap()</link> call was available to initialize various elements in the
bitmap structure.</p>
<p>Unfortunately some people didn't even use <link id="agraphics.AllocRaster">AllocRaster()</link> and <link id="agraphics.InitBitmap">InitBitMap()</link>
to setup their bitmaps but used <link id="exec.ExecAllocMem">ExecAllocMem()</link> and initialized the bitmap
structure on their own.</p>
<p>Because there was only one certain bitplane format description, it was no
problem to directly poke into the allocated planes.  It even was no problem
to alter the contents of the bitmap structure because the application had
total control over the location and the contents of this structure and
related plane pointers.</p>
<p> </p>
<p>Starting with OS 3.x two new graphics calls were added to support bitmap
creation and removal:  <link id="agraphics.AllocBitmap">AllocBitmap()</link>/gfx and <link id="agraphics.FreeBitmap">FreeBitmap()</link>/gfx.  With this
calls the first step was made to allow custom bitmap formats.  Before it
was no problem at all to directly render into the planes or to make
assumptions about the structure of the bitmap data.  To get more
information about the bitmap data an information retrieval call was added:
<link id="agraphics.GetBitmapAttr">GetBitmapAttr()</link>/gfx.  With this one you could get information on the width,
height, depth and certain flags of the bitmap.  This was the first step
into the RTG direction.  As soon as <link id="agraphics.GetBitmapAttr">GetBitmapAttr</link>(bm, <link id="agraphics.BMA_FLAGS">BMA_FLAGS</link>) didn't
return <link id="agraphics.BMF_STANDARD">BMF_STANDARD</link>, the bitmap was not direct accessable anymore and could
only be accessed by attachment to a rastport and subsequent rendering calls
or by using blit calls with a standard amiga bitmap as destination.</p>
<p>Unfortunately many programs didn't follow these guide lines and didn't
check for the <link id="agraphics.BMF_STANDARD">BMF_STANDARD</link> flag with OS3.0 and above.  Up to now many
programs still use the methods described at the beginning of this chapter.
That's one reason why graphics extensions like CyberGraphX still have to
fiddle around with planar to chunky conversions, even if the underlying
hardware doesn't support planar graphics anymore.  This often leads to
dramatic speed losses with certain applications which often could be
redundant if standard rendering calls were used.</p>
<p>So please use <link id="agraphics.AllocBitmap">AllocBitmap()</link>/<link id="agraphics.FreeBitmap">FreeBitmap()</link> whereever possible when running
3.x.  It really gives you a major performance improvement in most cases
when used on 3rd party display adapters.  Don't forget to add a friend
bitmap pointer whereever possible to allocate compatible bitmap structures.</p>
<p>With CyberGraphX you also have to add <link id="agraphics.BMF_MINPLANES">BMF_MINPLANES</link> in the flags field of
<link id="agraphics.AllocBitmap">AllocBitmap()</link>/gfx.  This is due to bug in the standard picture.datatype
which doesn't check for <link id="agraphics.BMF_STANDARD">BMF_STANDARD</link> and directly pokes into the bitplanes
even if the returned bitmap is non planar ......  Using <link id="agraphics.BMF_MINPLANES">BMF_MINPLANES</link> in a
non CyberGraphX environment remains still compatible and should not lead to
any problems, with CyberGraphX a chunky bitmap is returned, if a chunky
friendbitmap is supplied.  How to access the bitmap data will be discussed
later on.  Don't make assumptions on the bitmap contents before you have
called the required CyberGraphX library calls!!</p>
<p> </p>
<p>Besides the <link id="agraphics.AllocBitmap">AllocBitmap()</link> friend bitmap method, <link id="agraphics.AllocBitmap">AllocBitmap()</link> has been
extended to allow for allocation of certain pixel format bitmaps when using
CyberGraphX.  With CyberGraphX, bitmaps aren't limited to planar image maps
or 8 bit chunky data (which wasn't even available with the standard
chipset/ graphics.library) anymore.  It is also possible now to allocate
device dependant pixel format bitmaps and standard 15/16/24/32 bit depth
image maps.  Therefore new bits in the 32bit flags field parameter of
<link id="agraphics.AllocBitmap">AllocBitmap()</link> have been added.  If you specify the <link id="BMB_SPECIALFMT">BMB_SPECIALFMT</link> bit (see
includes), the upper 8 bits of the flags longword contain information on
the pixel format of the requested bitmap.  The following pixel formats are
available:</p>
<p>
  <link id="PIXFMT_LUT8"/>,
  <link id="PIXFMT_RGB15"/>,
  <link id="PIXFMT_BGR15"/>,
  <link id="PIXFMT_RGB15PC"/>,
  <link id="PIXFMT_BGR15PC"/>,
  <link id="PIXFMT_RGB16"/>,
  <link id="PIXFMT_BGR16"/>,
  <link id="PIXFMT_RGB16PC"/>,
  <link id="PIXFMT_BGR16PC"/>,
  <link id="PIXFMT_RGB24"/>,
  <link id="PIXFMT_BGR24"/>,
  <link id="PIXFMT_ARGB32"/>,
  <link id="PIXFMT_BGRA32"/>,
  <link id="PIXFMT_RGBA32"/></p>
<p>Many of this pixel
formats are device specific and should not be used, recommended formats are
<link id="PIXFMT_LUT8"/>, <link id="PIXFMT_RGB16"/>, <link id="PIXFMT_RGB24"/> and <link id="PIXFMT_ARGB32"/>.</p>
<p>Once allocated, you can attach the returned bitmap to a rastport and do
rendering calls.  It is <b>not</b> possible to attach this bitmap to a screen by
supplying it as custom bitmap with <link id="intuition.OpenScreenTagList">OpenScreenTagList()</link>!!</p>
<p>You are not allowed to directly poke into the bitmap image data as long as
the bitmap isn't locked!  The location and contents of the image data is
subject to change and is only valid when it's locked by using the available
locking calls (see autodocs).  <link id="LockBitmapTagList">LockBitmapTagList()</link>/<link id="UnLockBitmap">UnLockBitmap()</link> has been
added for this purpose.  You <b>have to</b> supply a taglist with <link id="LockBitmapTagList">LockBitmapTagList()</link>
which contains pointers to longwords which are filled with valid data if
the call returns with a non-zero value.  Only if a non-zero value is
returned you are able to access the bitmap directly!  Check the address
you get back with the <link id="LBMI_BASEADDRESS"/> tag.  This is the base address you
can do your rendering to.  Get the value of the <link id="LBMI_PIXFMT"/> ULONG field to
get information on the colormodel you have to use for image rendering.  <b>All</b>
models have to be supported!  The other fields give you information on the
layout of the bitmap data.  It should be no problem, to directly render
into the bitmap anymore.  Keep in mind that all this values are only valid
until a subsequent call to <link id="UnLockBitmap">UnLockBitmap()</link>.  Afterwards you have to lock the
bitmap again.  Don't hold this lock for longer than one frame!  You may
use the standard graphics.library bitmap blitting calls to copy the bitmap
contents to another bitmap.  Copying truecolour bitmaps into indexed colour
chunky bitmaps is not supported by now.</p>
</descr>

<!-- uses unit Visibility: default -->
<element name="Exec">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="agraphics">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="utility">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="CyberGfxBase">
<short>CyberGraphics library base structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBERGRAPHICSNAME">
<short>Name of cybergraphics main library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBERGFXNAME">
<short>Name of cybergraphics main library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBERGFX_INCLUDE_VERSION">
<short>Minimal version of supported cybergraphics.library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PCyberModeNode">
<short>List of available screen modes returned by <link id="AllocCModeListTagList"/></short>
<descr>
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tCyberModeNode">
<short>List of available screen modes pointer to it returned by <link id="AllocCModeListTagList"/></short>
<descr>
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="PCyberModeNode"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.Node">
<short>Standard exec list structure.</short>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.ModeText">
<short>Name for this mode</short>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.DisplayID">
<short>Display id associated with the node</short>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.Width">
<short>Visible width</short>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.Height">
<short>Visible height</short>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.Depth">
<short>Display depth</short>
</element>

<!-- variable Visibility: default -->
<element name="tCyberModeNode.DisplayTagList">
<short>Taglist with extended ModeID information</short>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_XMOD">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_BPPIX">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_DISPADR">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_PIXFMT">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_WIDTH">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_HEIGHT">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_DEPTH">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_ISCYBERGFX">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMATTR_ISLINEARMEM">
<short>Attribute for <link id="GetCyberMapAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRIDATTR_PIXFMT">
<short>Attribute for <link id="GetCyberIDAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRIDATTR_WIDTH">
<short>Attribute for <link id="GetCyberIDAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRIDATTR_HEIGHT">
<short>Attribute for <link id="GetCyberIDAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRIDATTR_DEPTH">
<short>Attribute for <link id="GetCyberIDAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRIDATTR_BPPIX">
<short>Attribute for <link id="GetCyberIDAttr"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_TB">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_MinDepth">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
  Value is a word describing the minimum display depth to let the user choose. Default is 8.
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_MaxDepth">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
  Value is a word describing the maximum display depth to let the user choose. Default is 32.
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_MinWidth">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
    Value is a longword describing the minimum display width to let the user choose. Default is 320.
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_MaxWidth">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
  Value is a longword describing the maximum display width to let the user choose. Default is 1600.
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_MinHeight">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
  Value is a longword describing the minimum display width to let the user choose. Default is 240.
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_MaxHeight">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
  Value is a longword describing the maximum display width to let the user choose. Default is 1200.
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_CModelArray">
<short>Tag for <link id="AllocCModeListTagList"/> and <link id="CModeRequestTagList"/></short>
<descr>
</descr>
<seealso>
  <link id="AllocCModeListTagList"/>
  <link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_WinTitle">
<short>Tag for <link id="CModeRequestTagList"/></short>
<descr>
  Value is PChar as Title to use for the requesting window.
</descr>
<seealso>
<link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_OKText">
<short>Tag for <link id="CModeRequestTagList"/></short>
<descr>
Value is PChar as Label of the positive gadget in the requester. English default is 'OK'.
</descr>
<seealso>
<link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_CancelText">
<short>Tag for <link id="CModeRequestTagList"/></short>
<descr>
Value is PChar as Label of the negative gadget in the requester. English default is 'Cancel'.
</descr>
<seealso>
<link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRMREQ_Screen">
<short>Tag for <link id="CModeRequestTagList"/></short>
<descr>
Value is <link id="intuition.PScreen">PScreen</link> setting the Screen on which to open the requester. Default locale will be used.
</descr>
<seealso>
<link id="CModeRequestTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRBIDTG_TB">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRBIDTG_Depth">
<short>Tag for <link id="BestCModeIDTagList"/></short>
<descr>
  Value is a LongWord describing the wanted depth the returned ModeID must support. Default = 8.
</descr>
<seealso>
<link id="BestCModeIDTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRBIDTG_NominalWidth">
<short>Tag for <link id="BestCModeIDTagList"/></short>
<descr>
Value is a Word describing the desired width the ModeID should have.
</descr>
<seealso>
<link id="BestCModeIDTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRBIDTG_NominalHeight">
<short>Tag for <link id="BestCModeIDTagList"/></short>
<descr>
Value is a Word describing the desired height the ModeID should have.
</descr>
<seealso>
<link id="BestCModeIDTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRBIDTG_MonitorID">
<short>Tag for <link id="BestCModeIDTagList"/></short>
<descr>
Value is a Longword. If multiple graphics boards are installed in the system, you can choose the desired one with this tag
</descr>
<seealso>
<link id="BestCModeIDTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CYBRBIDTG_BoardName">
<short>Tag for <link id="BestCModeIDTagList"/></short>
<descr>Value is PChar, specifies the card name directly. For
				example, pass "CVision3D" to get a
				CyberVision64/3D board ID
</descr>
<seealso>
<link id="BestCModeIDTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_LUT8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGB15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_BGR15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGB15PC">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_BGR15PC">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGB16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_BGR16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGB16PC">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_BGR16PC">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGB24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_BGR24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_ARGB32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_BGRA32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGBA32">
<short></short>
<descr>

</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECTFMT_RGB">
<short>PixelFormat for <link id="ReadPixelArray"/>, <link id="ScalePixelArray"/>, <link id="WritePixelArray"/></short>
<descr>3 bytes per pixel, one byte red, one blue and one byte green component
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECTFMT_RGBA">
<short>PixelFormat for <link id="ReadPixelArray"/>, <link id="ScalePixelArray"/>, <link id="WritePixelArray"/></short>
<descr>4 bytes per pixel, one byte red, one blue,
	    one byte green component and the last
      byte is alpha channel information which
		  is 0 if the board does not support alpha
      channel
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECTFMT_ARGB">
<short>PixelFormat for <link id="ReadPixelArray"/>, <link id="ScalePixelArray"/>, <link id="WritePixelArray"/></short>
<descr>4 bytes per pixel, one byte red, one blue,
	    one byte green component and the first
      byte is alpha channel information. If the
      board does not support alpha channel a 
		  0 is returned for alpha channel information
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECTFMT_LUT8">
<short>PixelFormat for <link id="ScalePixelArray"/>, <link id="WritePixelArray"/></short>
<descr>1 byte per pixel, specifying the pen
       number. On screen depths &gt; 8 bits the
	     data is converted using the actual color
	     lookup table.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECTFMT_GREY8">
<short>PixelFormat for <link id="ScalePixelArray"/>, <link id="WritePixelArray"/></short>
<descr>1 byte per pixel, specifying grey scale value.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SETVC_DPMSLevel">
<short>Tag for <link id="CVideoCtrlTagList"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DPMS_ON">
<short>Value for Tag <link id="SETVC_DPMSLevel"/></short>
<descr>
</descr>
<seealso>
<link id="CVideoCtrlTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DPMS_STANDBY">
<short>Value for Tag <link id="SETVC_DPMSLevel"/></short>
<descr>
</descr>
<seealso>
<link id="CVideoCtrlTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DPMS_SUSPEND">
<short>Value for Tag <link id="SETVC_DPMSLevel"/></short>
<descr>
</descr>
<seealso>
<link id="CVideoCtrlTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DPMS_OFF">
<short>Value for Tag <link id="SETVC_DPMSLevel"/></short>
<descr>
</descr>
<seealso>
<link id="CVideoCtrlTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_WIDTH">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get bitmaps width.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_HEIGHT">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get bitmaps height.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_DEPTH">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get bitmaps color depth.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_PIXFMT">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get bitmaps pixel format.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_BYTESPERPIX">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get bitmaps amount of bytes per pixel data.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_BYTESPERROW">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get the number of bytes per row for one bitmap line.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LBMI_BASEADDRESS">
<short>Tag for <link id="LockBitMapTagList"/></short>
<descr>
Value is a PLongWord to get the bitmap base address.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UBMI_UPDATERECTS">
<short>Tag for <link id="UnLockBitMapTagList"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UBMI_REALLYUNLOCK">
<short>Tag for <link id="UnLockBitMapTagList"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PCDrawMsg">
<short>Message passed to the <link id="DoCDrawMethodTagList"/>() hook function</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tCDrawMsg">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_MemPtr">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_offx">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_offy">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_xsize">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_ysize">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_BytesPerRow">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_BytesPerPix">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tCDrawMsg.cdm_ColorModel">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="CTABFMT_XRGB8">
<short>CTabFormat for <link id="WriteLUTPixelArray"/></short>
<descr>
<p>CTable is a pointer to a LongWord table
	 which contains 256 entries. Each entry specifies the
	rgb colour value for the related index. The format
	is XXRRGGBB.</p>
  <ul>
	    <li>XX - unused</li>
      <li>RR - 8-bit red component of the pixel</li>
	    <li>GG - 8-bit green component</li>
      <li>BB - 8-bit blue component</li>
  </ul>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMB_SPECIALFMT">
<short>Use for <link id="agraphics.AllocBitmap">AllocBitmap</link></short>
<descr>
<p>
If you specify the <link id="BMB_SPECIALFMT">BMB_SPECIALFMT</link> bit for <link id="agraphics.AllocBitmap">AllocBitmap</link> extended flag, the upper 8 bits of the flags longword contain information on
the pixel format of the requested bitmap.  The following pixel formats are
available:</p>
<p>
  <link id="PIXFMT_LUT8"/>,
  <link id="PIXFMT_RGB15"/>,
  <link id="PIXFMT_BGR15"/>,
  <link id="PIXFMT_RGB15PC"/>,
  <link id="PIXFMT_BGR15PC"/>,
  <link id="PIXFMT_RGB16"/>,
  <link id="PIXFMT_BGR16"/>,
  <link id="PIXFMT_RGB16PC"/>,
  <link id="PIXFMT_BGR16PC"/>,
  <link id="PIXFMT_RGB24"/>,
  <link id="PIXFMT_BGR24"/>,
  <link id="PIXFMT_ARGB32"/>,
  <link id="PIXFMT_BGRA32"/>,
  <link id="PIXFMT_RGBA32"/></p>
<p>Many of this pixel
formats are device specific and should not be used, recommended formats are
<link id="PIXFMT_LUT8"/>, <link id="PIXFMT_RGB16"/>, <link id="PIXFMT_RGB24"/> and <link id="PIXFMT_ARGB32"/>.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMF_SPECIALFMT">
<short>see <link id="BMB_SPECIALFMT"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AllocCModeListTagList">
<short>Get an exec list with requested modes</short>
<descr>
<p>
Allocates a list structure which contains all requested modes (All nodes
are of type CyberModeNode). See defines for more information about the
structure of this nodes.</p>
<p>Available Tags:</p>
<dl>
  <dt>CYBRMREQ_MinWidth</dt><dd>(LongWord) The minimum display width to let the user choose. Default is 320.</dd>
  <dt>CYBRMREQ_MaxWidth</dt><dd>(LongWord) The maximum display width to let the user choose. Default is 1600.</dd>
  <dt>CYBRMREQ_MinHeight</dt><dd>(LongWord) The minimum display height to let the user choose. Default is 240.</dd>
  <dt>CYBRMREQ_MaxHeight</dt><dd>(LongWord) The maximum display height to let the user choose. Default is 1200.</dd>
  <dt>CYBRMREQ_MinDepth</dt><dd>(Word) The minimum display depth to let the user choose. Default is 8.</dd>
  <dt>CYBRMREQ_MaxDepth</dt><dd>(Word) The maximum display depth to let the user choose. Default is 32.</dd>
  <dt>CYBRMREQ_CModelArray</dt><dd>(PWord) Array of color models which should be
	                available for screenmode selection. Currently supported
	                colormodels are:
                  <link id="PIXFMT_LUT8"/>,
                  <link id="PIXFMT_RGB15"/>,
                  <link id="PIXFMT_BGR15"/>,
                  <link id="PIXFMT_RGB15PC"/>,
                  <link id="PIXFMT_BGR15PC"/>,
                  <link id="PIXFMT_RGB16"/>,
                  <link id="PIXFMT_BGR16"/>,
                  <link id="PIXFMT_RGB16PC"/>,
                  <link id="PIXFMT_BGR16PC"/>,
                  <link id="PIXFMT_RGB24"/>,
                  <link id="PIXFMT_BGR24"/>,
                  <link id="PIXFMT_ARGB32"/>,
                  <link id="PIXFMT_BGRA32"/>,
                  <link id="PIXFMT_RGBA32"/>
	                default is all colormodels available, nothing filtered</dd>
</dl>  
</descr>
<errors>
</errors>
<seealso>
<link id="FreeCModeList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AllocCModeListTagList.Result">
<short>nil if no modes are available, a pointer to a exec <link id="exec.PList">list</link> if there are modes which fit your needs. Use <link id="FreeCModeList"/> to free it after use.</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocCModeListTagList.ModeListTags">
<short>Pointer to an optional tag list which may be used to control the number of returned modes</short>
</element>

<!-- function Visibility: default -->
<element name="BestCModeIDTagList">
<short>Calculate the best ModeID with given parameters</short>
<descr>
  <p>
  Returns the CyberGraphX displaymode ID which fits best for the parameters
  supplied in the TagList.
  </p>
  <p>Available Tags:</p>
  <dl>  
    <dt>CYBRBIDTG_Depth</dt><dd>(Word) Depth the returned ModeID must support. Default is 8</dd>
    <dt>CYBRBIDTG_NominalWidth</dt><dd>(Word) desired width the ModeID should have</dd>
    <dt>CYBRBIDTAG_NominalHeight</dt><dd>(Word) desired height the ModeID should have</dd>
    <dt>CYBRBIDTG_MonitorID</dt><dd><p>(LongWord) if multiple graphics boards are installed in the system, you can choose the desired one with this tag
      Currently supported boards are: </p><ul><li>1 = CVision64 </li><li>2 = Piccolo</li><li>3 = PicassoII</li><li>4 = Spectrum</li><li>5 = Domino</li>
      <li>6 = RetinaZ3/DraCoAltais</li><li>7 = PiccoSD64</li><li>8 = A2410</li><li>13 = CVision3D (V41)</li><li>14 = Inferno (V41)</li><li>15 = PicassoIV (V41)</li></ul>
      </dd>
    <dt>CYBRBIDTG_BoardName</dt><dd>(STRPTR) - Specify the card name directly. For example, pass 'CVision3D' to get a CyberVision64/3D board ID</dd>
  </dl>
</descr>
<errors>
  Older versions return displaymode IDs with wrong depth if the	desired color depth is not available.
	If you specify very small widths/heights (e.g. 50/20 icon size) this call returns <link id="INVALID_ID"/> instead of the smallest available lowres ID.
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BestCModeIDTagList.Result">
<short>DisplayID of the best mode to use, or <link id="INVALID_ID"/> if a match could not be found.</short>
</element>

<!-- argument Visibility: default -->
<element name="BestCModeIDTagList.BestModeIDTags">
<short>Pointer to an array of TagItems describing the wanted screen mode</short>
</element>

<!-- function Visibility: default -->
<element name="CModeRequestTagList">
<short>Get screenmode from user using a requester.</short>
<descr>
<p>
  Prompts the user for input by showing all available CyberGraphX
	screenmodes in a requester.
	If the user cancels or the system aborts the request, 0 is returned,
	otherwise the displaymode ID of the selected screenmode.</p>
  <p>Available Tags:</p>
<dl>
  <dt>CYBRMREQ_Screen</dt><dd>(<link id="intuition.PScreen">PScreen</link>) Screen on which to open the requester. Default locale will be used.</dd>
  <dt>CYBRMREQ_WinTitle</dt><dd>(PChar) Title to use for the requesting window.</dd>
  <dt>CYBRMREQ_OKText</dt><dd>(PChar) Label of the positive gadget in the requester. English default is 'OK'.</dd>
  <dt>CYBRMREQ_CancelText</dt><dd>(PChar) Label of the negative gadget in the requester. English default is 'Cancel'.</dd>
  <dt>CYBRMREQ_MinWidth</dt><dd>(LongWord) The minimum display width to let the user choose. Default is 320.</dd>
  <dt>CYBRMREQ_MaxWidth</dt><dd>(LongWord) The maximum display width to let the user choose. Default is 1600.</dd>
  <dt>CYBRMREQ_MinHeight</dt><dd>(LongWord) The minimum display height to let the user choose. Default is 240.</dd>
  <dt>CYBRMREQ_MaxHeight</dt><dd>(LongWord) The maximum display height to let the user choose. Default is 1200.</dd>
  <dt>CYBRMREQ_MinDepth</dt><dd>(Word) The minimum display depth to let the user choose. Default is 8.</dd>
  <dt>CYBRMREQ_MaxDepth</dt><dd>(Word) The maximum display depth to let the user choose. Default is 32.</dd>
  <dt>CYBRMREQ_CModelArray</dt><dd>(PWord) Array of color models which should be
	                available for screenmode selection. Currently supported
	                colormodels are:
                  <link id="PIXFMT_LUT8"/>,
                  <link id="PIXFMT_RGB15"/>,
                  <link id="PIXFMT_BGR15"/>,
                  <link id="PIXFMT_RGB15PC"/>,
                  <link id="PIXFMT_BGR15PC"/>,
                  <link id="PIXFMT_RGB16"/>,
                  <link id="PIXFMT_BGR16"/>,
                  <link id="PIXFMT_RGB16PC"/>,
                  <link id="PIXFMT_BGR16PC"/>,
                  <link id="PIXFMT_RGB24"/>,
                  <link id="PIXFMT_BGR24"/>,
                  <link id="PIXFMT_ARGB32"/>,
                  <link id="PIXFMT_BGRA32"/>,
                  <link id="PIXFMT_RGBA32"/>
	                default is all colormodels available, nothing filtered</dd>
</dl>  
</descr>
<errors>
The requester structure is not supported. You should better use asl.library/<link id="asl.aslrequest">AslRequest()</link> instead.
</errors>
<seealso>
<link id="asl.aslrequest">AslRequest()</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CModeRequestTagList.Result">
<short>0 if the user cancelled the requester or if something
		 prevented the requester from opening. If &lt;&gt; 0 the displaymode
		 ID of the selected screenmode is returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="CModeRequestTagList.ModeRequest">
<short>not used currently. You have to set it to nil!</short>
</element>

<!-- argument Visibility: default -->
<element name="CModeRequestTagList.ModeRequestTags">
<short>Pointer to an optional tag list which may be used to control features of the requester</short>
</element>

<!-- procedure Visibility: default -->
<element name="CVideoCtrlTagList">
<short>Control video output</short>
<descr>
<p>This function controls the video output of the gfx board to which the
	specified ViewPort belongs to.</p>
<p>Available Tags</p>
<dl>
  <dt>SETVC_DPMSLevel</dt><dd><p>(LongWord) Set the DPMS level for the specified viewport
		Supported levels are:</p>
    <ul>
      <li> DPMS_ON	Full operation</li>
      <li> DPMS_STANDBY	Optional state of minimal power reduction</li>
      <li> DPMS_SUSPEND	Significant reduction of power consumption</li>
      <li> DPMS_OFF	Lowest level of power consumption</li>
    </ul>
  </dd>
</dl>
<p><b>Snippet</b></p>
<code>
{ set DPMS level }
CVideoCtrlTags(@Scr^.ViewPort, [SETVC_DPMSLevel, DPMS_OFF, TAG_DONE]);	
</code>
</descr>
<errors>
  Some DPMS levels are not implemented for certain graphics cards
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="CVideoCtrlTagList.ViewPort">
<short>Pointer to a ViewPort of a CyberGraphX screen</short>
</element>

<!-- argument Visibility: default -->
<element name="CVideoCtrlTagList.TagList">
<short>Pointer to Taglist to control operation</short>
</element>

<!-- procedure Visibility: default -->
<element name="DoCDrawMethodTagList">
<short>Do the given hook for the supplied rastport</short>
<descr>
  <p>This function will call the given hook for the given rastport. Is is
	mainly used to do direct bitmap modifications in a locked graphics
	environment. You have to support <b>all</b> known color models, so only use
	this call if you really need it!!</p>
  <p><b>Hook call parameter</b></p>
  <dl>
    <dt>object</dt><dd><link id="agraphics.PRastPort">PRastPort</link></dd>
    <dt>message</dt><dd><p>pointer to <link id="TCDrawMsg"/>:</p>
      <ul>        
        <li> MemPtr: APTR</li>
        <li> XOffset: LongWord</li><li>YOffset: LongWord</li>
        <li> XSize: LongWord</li><li>YSize: LongWord</li>
        <li> BytesPerRow: Word</li><li>BytesPerPix: Word</li>
        <li> ColorModel: Word</li>
      </ul>
      <p> where colormodel is on of following:
                  <link id="PIXFMT_LUT8"/>,
                  <link id="PIXFMT_RGB15"/>,
                  <link id="PIXFMT_BGR15"/>,
                  <link id="PIXFMT_RGB15PC"/>,
                  <link id="PIXFMT_BGR15PC"/>,
                  <link id="PIXFMT_RGB16"/>,
                  <link id="PIXFMT_BGR16"/>,
                  <link id="PIXFMT_RGB16PC"/>,
                  <link id="PIXFMT_BGR16PC"/>,
                  <link id="PIXFMT_RGB24"/>,
                  <link id="PIXFMT_BGR24"/>,
                  <link id="PIXFMT_ARGB32"/>,
                  <link id="PIXFMT_BGRA32"/>,
                  <link id="PIXFMT_RGBA32"/></p>
      </dd>
  </dl>
</descr>
<errors>
  In previous autodocs, the <var>bytesperrow</var> message field was described as
	an LongWord which in fact was an Word. 
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DoCDrawMethodTagList.Hook">
<short>Pointer to callback hook which will be called </short>
</element>

<!-- argument Visibility: default -->
<element name="DoCDrawMethodTagList.a1arg">
<short>A pointer to a cybergraphics RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="DoCDrawMethodTagList.TagList">
<short>optional taglist, currently not used. Set it to nil!</short>
</element>

<!-- function Visibility: default -->
<element name="ExtractColor">
<short>Extract the specified colour/CLUT value from a given CyberGraphX RastPort</short>
<descr>
<p>
    Extract the specified colour/CLUT value from a given
		CyberGraphX RastPort into a single plane bitmap starting at
		a certain x,y location and using the specified width and
		height. Use this function if you want to create masks.
		(V41)
</p>
</descr>
<errors>
This call was a no-op in very early revisions of cybergraphics v41
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ExtractColor.Result">
<short>Returns True (&lt;&gt; 0) if colour could be extracted, False (= 0) if not</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.a0arg">
<short>pointer to a CyberGraphX RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.BitMap">
<short>Planar destination bitmap that has at least a depth of one and the minimum width and height specified.</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.Colour">
<short>the color that should be extracted in AARRGGBB format for true color rastports or in indexed mode for CLUT rastports (index in BB).</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.SrcX">
<short>X starting point in the RastPort that should be analyzed</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.SrcY">
<short>Y starting point in the RastPort that should be analyzed</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.Width">
<short>Width of the rectangle that should be analyzed</short>
</element>

<!-- argument Visibility: default -->
<element name="ExtractColor.Height">
<short>Height of the rectangle that should be analyzed</short>
</element>

<!-- function Visibility: default -->
<element name="FillPixelArray">
<short>fill a rectangular area with the supplied ARGB</short>
<descr>
<p>fill a rectangular area with the supplied ARGB value
	starting at a specified x,y location and continuing through to another
	x,y location within a certain RastPort</p>
<p>For each pixel in a rectangular region, write the supplied color value
	into the bitmap used to describe a particular rastport.</p>
<p><b>Attention</b></p>
<p>This function should only be used on screens depths &gt;8 bits in
	cybergraphics versions prior v41.</p>
</descr>
<errors>
The returned count value is wrong up to and including v41 of the cybergraphics.library
</errors>
<seealso>
<link id="InvertPixelArray"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FillPixelArray.Result">
<short>Count will be set to the number of pixels plotted</short>
</element>

<!-- argument Visibility: default -->
<element name="FillPixelArray.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="FillPixelArray.DestX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="FillPixelArray.DestY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="FillPixelArray.SizeX">
<short>Width of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="FillPixelArray.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="FillPixelArray.ARGB">
<short>the desired color in AARRGGBB format for true color rastports
		or in indexed mode for CLUT rastports. Every component
		uses 8 bits in the supplied longword.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeCModeList">
<short>Frees a previously allocated ModeList</short>
<descr>
  Frees all data which was previously allocated by <link id="AllocCModeListTagList"/>
</descr>
<errors>
</errors>
<seealso>
<link id="AllocCModeListTagList"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeCModeList.ModeList">
<short>a list structure which contains all the mode data.</short>
</element>

<!-- function Visibility: default -->
<element name="GetCyberIDAttr">
<short>Returns information about a cybergraphics ID</short>
<descr>
<p>Returns information about a specified displaymode ID.</p>
<p><b>Available CyberIDAttr</b></p>
<p>You should know what you are doing if you call this function!
	Don't apply it on a non cybergraphics displaymode!</p>
<dl>
  <dt>CYBRIDATTR_PIXFMT</dt><dd>return the pixel format of the supplied screenmode id</dd>
  <dt>CYBRIDATTR_WIDTH</dt><dd>returns visible width in pixels</dd>
  <dt>CYBRIDATTR_HEIGHT</dt><dd>returns visible height in lines</dd>
  <dt>CYBRIDATTR_DEPTH</dt><dd>returns bits per pixel</dd>
  <dt>CYBRIDATTR_BPPIX</dt><dd>returns bytes per pixel</dd>
</dl>
<p>Unknown attributes are reserved for future use, and return ($FFFFFFFF).</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetCyberIDAttr.Result">
<short>depends on the supplied CyberIDAttr</short>
</element>

<!-- argument Visibility: default -->
<element name="GetCyberIDAttr.CyberIDAttr">
<short>A number telling cybergraphics which attribute of the displaymode id should be returned</short>
</element>

<!-- argument Visibility: default -->
<element name="GetCyberIDAttr.CyberDisplayModeID">
<short>CyberGraphX displaymode ID</short>
</element>

<!-- function Visibility: default -->
<element name="GetCyberMapAttr">
<short>Returns information about a cybergraphics bitmap</short>
<descr>
<p>Gets information about an extended cybergraphics bitmap.
	This function should be used instead of making any assumptions about
	fields in the bitmap structure. This will provide future
  compatibility.</p>
<p>You should know what you are doing if you call this function!
	Always use the <link id ="CYBRMATTR_ISCYBERGFX"/> attribute first to check if the
	bitmap is a CyberGraphX one.</p>  
<p><b>Available CyberAttrTag</b></p>
<dl>
  <dt>CYBRMATTR_XMOD</dt><dd>returns bytes per row of the supplied bitmap</dd>
  <dt>CYBRMATTR_BPPIX</dt><dd>returns number of bytes per pixel</dd>
  <dt>CYBRMATTR_PIXFMT</dt><dd>return the pixel format of the bitmap</dd>
  <dt>CYBRMATTR_WIDTH</dt><dd>return width of the bitmap in pixels</dd>
  <dt>CYBRMATTR_HEIGHT</dt><dd>return the height in lines</dd>
  <dt>CYBRMATTR_DEPTH</dt><dd>returns bits per pixel</dd>
  <dt>CYBRMATTR_ISCYBERGFX</dt><dd>returns True (result &lt;&gt; 0) if supplied bitmap is a CyberGraphX one</dd>
  <dt>CYBRMATTR_ISLINEARMEM</dt><dd>returns True (result &lt;&gt; 0) if the related display buffer supports linear memory access</dd>
</dl>
<p>Unknown attributes are reserved for future use, and return ($FFFFFFFF).</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetCyberMapAttr.Result">
<short>Value described by <var>CyberAttrTag</var></short>
</element>

<!-- argument Visibility: default -->
<element name="GetCyberMapAttr.CyberGfxBitmap">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GetCyberMapAttr.CyberAttrTag">
<short>A number telling cybergraphics which attribute of the bitmap should be returned</short>
</element>

<!-- function Visibility: default -->
<element name="InvertPixelArray">
<short>Invert a rectangular area</short>
<descr><p>Invert each pixel in a rectangular region.</p>
<p><b>Attention</b></p>
<p>This function should only be used on screens depths > 8 bits with
	cybergraphics versions prior v41.</p>
</descr>
<errors>
The count value returned is totally wrong.
</errors>
<seealso>
<link id="FillPixelArray"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="InvertPixelArray.Result">
<short>count will be set to the number of pixels plotted</short>
</element>

<!-- argument Visibility: default -->
<element name="InvertPixelArray.a1arg">
<short>pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="InvertPixelArray.DestX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="InvertPixelArray.DestY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="InvertPixelArray.SizeX">
<short>Width of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="InvertPixelArray.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- function Visibility: default -->
<element name="IsCyberModeID">
<short>Returns whether supplied ModeID is a cybergraphics ID</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IsCyberModeID.Result">
<short>Returns whether the supplied ModeID is a cybergraphics.library mode identifier (True) or not (False).</short>
</element>

<!-- argument Visibility: default -->
<element name="IsCyberModeID.displayID">
<short>a 32 bit display identifier.</short>
</element>

<!-- function Visibility: default -->
<element name="LockBitMapTagList">
<short>Lock supplied BitMap for a short amount of time to allow direct memory access</short>
<descr>
  <p>Lock supplied BitMap for a short amount of time to allow direct memory access</p>
  <p><b>Available Tags</b></p>
  <dl>
    <dt>LBMI_WIDTH</dt><dd>(PLongWord) Points to a longword which contains the bitmap width after a succesful call</dd>
    <dt>LBMI_HEIGHT</dt><dd>(PLongWord) Points to a longword which contains the bitmap height after a succesful call</dd>
    <dt>LBMI_DEPTH</dt><dd>(PLongWord) Points to a longword which contains the bitmap depth after a succesful call</dd>
    <dt>LBMI_PIXFMT</dt><dd>(PLongWord) Points to a longword which contains the usedpixel format.
			Possibly returned colormodels are:
                  <link id="PIXFMT_LUT8"/>,
                  <link id="PIXFMT_RGB15"/>,
                  <link id="PIXFMT_BGR15"/>,
                  <link id="PIXFMT_RGB15PC"/>,
                  <link id="PIXFMT_BGR15PC"/>,
                  <link id="PIXFMT_RGB16"/>,
                  <link id="PIXFMT_BGR16"/>,
                  <link id="PIXFMT_RGB16PC"/>,
                  <link id="PIXFMT_BGR16PC"/>,
                  <link id="PIXFMT_RGB24"/>,
                  <link id="PIXFMT_BGR24"/>,
                  <link id="PIXFMT_ARGB32"/>,
                  <link id="PIXFMT_BGRA32"/>,
                  <link id="PIXFMT_RGBA32"/>  </dd>
    <dt>LBMI_BYTESPERPIX</dt><dd>(PLongWord) points to a longword which contains the amount of bytes per pixel data.</dd>
    <dt>LBMI_BYTESPERROW</dt><dd>(PLongWord) points to a longword which contains the number of bytes per row for one bitmap line</dd>
    <dt>LBMI_BASEADDRESS</dt><dd>(PLongWord) points to a longword which contains the
                                     bitmap base address. <b>This address is only valid inside of the Lock/UnLockBitmap call!</b></dd>
  </dl>
</descr>
<errors>
</errors>
<seealso>
 <link id="UnLockBitMap"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockBitMapTagList.Result">
<short>0 if the bitmap could not be locked, &lt;&gt; 0 it contains a handle which should be passed to <link id="UnLockBitMap"/> afterwards</short>
</element>

<!-- argument Visibility: default -->
<element name="LockBitMapTagList.BitMap">
<short>Pointer to a CyberGraphX bitmap pointer. please check if it is a cybermap by calling <link id="GetCyberMapAttr"/>() first.</short>
</element>

<!-- argument Visibility: default -->
<element name="LockBitMapTagList.TagList">
<short>Pointer to a mandatory taglist which's tagdata pointer fields contain valid LongWords after a successful call.</short>
</element>

<!-- function Visibility: default -->
<element name="MovePixelArray">
<short>move the color values of a rectangular area</short>
<descr>
<p>
move the color values of a rectangular area of
pixels starting at a specified x,y location and continuing through
to another x,y location within a certain RastPort
</p>
<p>For each pixel in a rectangular region, move the pixel value from a
	specified source to a specified destination</p>
<p>  
	The blitter can be used to move the data if the bitmap is in display
	memory. This is why you should use this call.</p>

</descr>
<errors>
The count value returned is totally wrong.
This function should only be used on screens depths > 8 bits with
cybergraphics versions up to v40.
</errors>
<seealso>
<link id="FillPixelArray"/>
<link id="InvertPixelArray"/>
<link id="agraphics.BltBitMapRastPort">BltBitMapRastPort</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MovePixelArray.Result">
<short>number of pixels moved</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.SrcX">
<short>Starting x point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.SrcY">
<short>Starting y point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.DestX">
<short>Starting x point in the destination rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.DestY">
<short>Starting y point in the destination rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.SizeX">
<short>Width of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="MovePixelArray.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- function Visibility: default -->
<element name="ReadPixelArray">
<short>Read the color values of a rectangular array</short>
<descr>
<p>Read the color values of a rectangular array of
	pixels starting at a specified x,y location and continuing through
	to another x,y location within a certain RastPort</p>
<p>For each pixel in a rectangular region, write the color value to a
	linear array of color values from the bitmap used to describe a
	particular rastport.</p> 
<p><b>Attention</b></p>
<p>This function should only be used on screens depths > 8 bits.</p>
</descr>
<errors>The count value returned is totally wrong.
</errors>
<seealso>
<link id="WritePixelArray"/>
<link id="agraphics.ReadPixelArray8">ReadPixelArray8</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ReadPixelArray.Result">
<short>number of pixels read</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.destRect">
<short>Pointer to an array of pixels where to write the pixel data to. The pixel format is specified in DestFormat</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.destX">
<short>X starting point in the destination rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.destY">
<short>Y starting point in the destination rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.destMod">
<short>The number of bytes per row in the destination rectangle.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.SrcX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.SrcY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.SizeX">
<short>Width of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadPixelArray.DestFormat">
<short>pixel format in the destination rectangle Currently supported formats are: <link id="RECTFMT_RGB"/>, <link id="RECTFMT_RGBA"/>, <link id="RECTFMT_ARGB"/></short>
</element>

<!-- function Visibility: default -->
<element name="ReadRGBPixel">
<short>Reads a pixel from a specified location</short>
<descr>
<p>Read the alpha,red,green and blue 8-bit color components of the pixel at a specified x,y location within a certain RastPort</p>
<p><b>Attention</b></p>
<p>This function should only be used on screens depths &gt; 8 bits. Use
	<link id="AGraphics.ReadPixel">ReadPixel</link>() on 8 bit screens!</p>
</descr>
<errors>
</errors>
<seealso>
<link id="WriteRGBPixel"/>
<link id="AGraphics.ReadPixel">ReadPixel</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ReadRGBPixel.Result">
<short>the desired color in AARRGGBB format. Every component allocates 8 bits in the returned longword.</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadRGBPixel.a1arg">
<short>pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadRGBPixel.x">
<short>the x coordinate of the pixel</short>
</element>

<!-- argument Visibility: default -->
<element name="ReadRGBPixel.y">
<short>the y coordinate of the pixel</short>
</element>

<!-- function Visibility: default -->
<element name="ScalePixelArray">
<short>Scale the colors values of a rectangular array (V41)</short>
<descr><p>Scale the colors values of a rectangular array of
	pixels starting at a specified x,y location and continuing through
	to another x,y location within a certain RastPort</p>
<p>For each pixel in a rectangular region, scale the color values from a
	linear array of color values into the bitmap used to describe a
	particular rastport.</p>  
<p><b>Attention</b></p>
<p>Up to v40, this function only worked on screens depths &gt; 8 bits.
	You may specify <link id="RECTFMT_LUT8"/> on 8bit screens, too now if v41 is
	available</p>
</descr>
<errors>
Very early v40 revision did not support <link id="RECTFMT_LUT8"/> and <link id="RECTFMT_GREY8"/>.
Scaling is not very accurate. If you need high quality, use
graphics.library/<link id="agraphics.BitmapScale">BitMapScale()</link> instead or custom code.
The count value returned is totally wrong.
</errors>
<seealso>
<link id="agraphics.BitmapScale">BitMapScale()</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ScalePixelArray.Result">
<short>number of pixels plotted</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.srcRect">
<short>Pointer to an array of pixels from which to fetch the pixel data. The pixel format is specified in <var>SrcFormat</var></short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.SrcW">
<short>Width of the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.SrcH">
<short>Height of the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.SrcMod">
<short>The number of bytes per row in the source rectangle.</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.a1arg">
<short>pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.DestX">
<short>starting x point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.DestY">
<short>starting y point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.DestW">
<short>Width of the destination area</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.DestH">
<short>Height of the destination area</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArray.SrcFormat">
<short>pixel format in the source rectangle. Currently supported formats are:
  <link id="RECTFMT_RGB"/>, 
  <link id="RECTFMT_RGBA"/>, 
  <link id="RECTFMT_ARGB"/>, 
  <link id="RECTFMT_LUT8"/>, 
  <link id="RECTFMT_GREY8"/>
  </short>
</element>

<!-- procedure Visibility: default -->
<element name="UnLockBitMap">
<short>Unlock CyberGraphX BitMap that was previously locked</short>
<descr>Unlock CyberGraphX BitMap that was previously locked.
</descr>
<errors>
</errors>
<seealso>
<link id="LockBitMapTagList"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnLockBitMap.Handle">
<short>handle to the previously locked BitMap</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnLockBitMapTagList">
<short>Unlock CyberGraphX BitMap that was previously</short>
<descr><p>Unlock CyberGraphX BitMap that was previously locked</p>
<p><b>Available Tags</b></p>
<dl>
  <dt>UBMI_UPDATERECTS</dt><dd><p>(PRectList) - Pointer to a rectlist which
		contains rectangles that should be updated. This is needed for
		cards that don't have a linear display memory address space</p>
		<p>The RectList structure looks like this:</p>
    <code>
TRectList = record
  rl_num: LongWord;     // no. of rects in this list
  rl_next: PRectList;  // pointer to next list
  rect1: TRectangle;   // This is the first 
end;</code></dd>
  <dt>UBMI_REALLYUNLOCK</dt><dd>Specifies whether bitmap should really be
		unlocked (True) or not (False) in case you just want to update
		certain rectangles and unlock later.  </dd>
</dl>
</descr>
<errors>
Very early v40 revisions did not support this call
</errors>
<seealso>
<link id="LockBitMapTagList"/>
<link id="UnLockBitMap"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnLockBitMapTagList.Handle">
<short>handle to the previously locked BitMap</short>
</element>

<!-- argument Visibility: default -->
<element name="UnLockBitMapTagList.TagList">
<short>pointer to a mandatory taglist</short>
</element>

<!-- function Visibility: default -->
<element name="WriteLUTPixelArray">
<short>write the color value generated from a given	color table (V41)</short>
<descr>
<p>write the color value generated from a given
	color table of a rectangular array of pixels starting at a specified
	x,y location and continuing through to another x,y location within
	a certain RastPort</p>
<p>For each pixel in a rectangular region, write the color value
	generated with a given color lookup table from a linear array of
  indexed pixel values into the bitmap used to describe a	particular
	rastport.</p>
<p><b>Attention</b></p>
<p>Does only work on rastports with depth &gt; 8bits</p>
</descr>
<errors>
<p>The count value returned is totally wrong.</p>
<p>
	With cgxsystem.library up to version 41.19, the call returns
	immediately with <link id="CTABFMT_XRGB8"/> due to a bug in the code</p>
</errors>
<seealso>
<link id="ReadPixelArray"/>
<link id="WritePixelArray"/>
<link id="agraphics.WritePixelArray8">WritePixelArray8</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WriteLUTPixelArray.Result">
<short>number of pixels plotted</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.srcRect">
<short>Pointer to an array of pixels from which to fetch the CLUT data. Pixels are specified in bytes, 8bits/pixel</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.SrcX">
<short>X starting point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.SrcY">
<short>Y starting point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.SrcMod">
<short>The number of bytes per row in the source rectangle.</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.ColorTab">
<short>pointer to the color table using the format specified with <var>CTabFormat</var></short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.DestX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.DestY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.SizeX">
<short>Width of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteLUTPixelArray.CTFormat">
<short>color table format in the source rectangle
		Currently supported formats are:
		 <link id="CTABFMT_XRGB8"/></short>
</element>

<!-- function Visibility: default -->
<element name="WritePixelArray">
<short>write the color value of a rectangular array</short>
<descr>
<p>write the color value of a rectangular array of
	pixels starting at a specified x,y location and continuing through
	to another x,y location within a certain RastPort</p>
<p>For each pixel in a rectangular region, write the color value from a
	linear array of color values into the bitmap used to describe a
	particular rastport.</p>
<p><b>Attention</b></p>
<p>Only <link id="RECTFMT_LUT8"/> can be used on screen depths &lt;= 8 bits.
	For &gt; 8 bit rastport <link id="RECTFMT_LUT8"/> uses the actual colormap "attached"
	to the bitmap. If the bitmap is a friend bitmap of a screen bitmap
	or the screen bitmap itself, it uses the screen's viewport colormap.</p>
</descr>
<errors>
The count value returned is totally wrong.
</errors>
<seealso>
<link id="ReadPixelArray"/>
<link id="WriteLUTPixelArray"/>
<link id="WritePixelArray"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WritePixelArray.Result">
<short>number of pixels plotted</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.srcRect">
<short>pointer to an array of pixels from which to fetch the
	          pixel data. The pixel format is specified in <var>SrcFormat</var></short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.SrcX">
<short>X starting point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.SrcY">
<short>Y starting point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.SrcMod">
<short>The number of bytes per row in the source rectangle.</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.DestX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.DestY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.SizeX">
<short>Widht of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArray.SrcFormat">
<short>pixel format in the source rectangle. Currently supported formats are:
  <link id="RECTFMT_RGB"/>, 
  <link id="RECTFMT_RGBA"/>, 
  <link id="RECTFMT_ARGB"/>, 
  <link id="RECTFMT_LUT8"/>, 
  <link id="RECTFMT_GREY8"/>
</short>
</element>

<!-- function Visibility: default -->
<element name="WriteRGBPixel">
<short>Writes a pixel to a specified location</short>
<descr>
<p>Write the alpha,red,green and blue 8-bit color component of the given
        color to a specified x,y location within a certain RastPort</p>
<p><b>Attention</b></p>
<p>This function should only be used on screens depths &gt; 8 bits. Use
	<link id="agraphics.WritePixel">WritePixel</link> on 8 bit screens!</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ReadRGBPixel"/>
<link id="agraphics.WritePixel">WritePixel</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WriteRGBPixel.Result">
<short><p>error = 0 if pixel succesfully changed</p>
	      <p>= -1 if (x,y) is outside the rastport</p></short>
</element>

<!-- argument Visibility: default -->
<element name="WriteRGBPixel.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteRGBPixel.x">
<short>X coordinate of the pixel</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteRGBPixel.y">
<short>Y coordinate of the pixel</short>
</element>

<!-- argument Visibility: default -->
<element name="WriteRGBPixel.argb">
<short>The desired color in AARRGGBB format. Every component allocates 8 bits of the longword.</short>
</element>

<!-- function Visibility: default -->
<element name="SHIFT_PIXFMT">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SHIFT_PIXFMT.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SHIFT_PIXFMT.fmt">
<short></short>
</element>


<!-- constant Visibility: default -->
<element name="CYBRMATTR_COLORMAP">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXFMT_RGB15X">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECTFMT_RAW">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMF_REQUESTVMEM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMB_ROOTMAP">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMF_ROOTMAP">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMB_3DTARGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BMF_3DTARGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>


<!-- constant Visibility: default -->
<element name="POP_BRIGHTEN">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>brighten the rectangle. The amount of brightening
        to be done is defined by the <var>value</var> input, which must be in
        the range 0 to 255.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_DARKEN">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>darken the rectangle. The amount of darkening to be
        done is defined by the <var>value</var> input, which must be in the
        range 0 to 255.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_SETALPHA">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>set the alpha channel value for all pixels in the
        rectangle to that specified in the <var>value</var> input. The valid
        range is 0 to 255.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_TINT">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>tint the rectangle with an ARGB32 color (<var>value</var> input).
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_BLUR">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>blur the rectangle.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_COLOR2GREY">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_NEGATIVE">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_NEGFADE">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_TINTFADE">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_GRADIENT">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>apply a gradient to the rectangle. Gradient
        parameters are supplied through the taglist.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POP_SHIFTRGB">
<short>Operation for <link id="ProcessPixelArray"/></short>
<descr>
Values:
<link id="RGBSHIFT_BGR"/>, 
<link id="RGBSHIFT_BRG"/>, 
<link id="RGBSHIFT_GBR"/>, 
<link id="RGBSHIFT_GRB"/>, 
<link id="RGBSHIFT_RBG"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RGBSHIFT_BGR">
<short>Value for Tag <link id="POP_SHIFTRGB"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RGBSHIFT_BRG">
<short>Value for Tag <link id="POP_SHIFTRGB"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RGBSHIFT_GBR">
<short>Value for Tag <link id="POP_SHIFTRGB"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RGBSHIFT_GRB">
<short>Value for Tag <link id="POP_SHIFTRGB"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RGBSHIFT_RBG">
<short>Value for Tag <link id="POP_SHIFTRGB"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_FADEFULLSCALE">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_FADEOFFSET">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_GRADIENTTYPE">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GRADTYPE_HORIZONTAL">
<short>Tag Value for Tags <link id="PPAOPTAG_GRADIENTTYPE"/> of <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GRADTYPE_VERTICAL">
<short>Tag Value for Tags <link id="PPAOPTAG_GRADIENTTYPE"/> of <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GRADTYPE_RECTANGLE">
<short>Tag Value for Tags <link id="PPAOPTAG_GRADIENTTYPE"/> of <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GRADTYPE_LINEAR_ANGLE">
<short>Tag Value for Tags <link id="PPAOPTAG_GRADIENTTYPE"/> of <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GRADTYPE_RADIAL">
<short>Tag Value for Tags <link id="PPAOPTAG_GRADIENTTYPE"/> of <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GRADIENT_NUMTYPES">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_GRADCOLOR1">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_GRADCOLOR2">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_GRADFULLSCALE">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_GRADOFFSET">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_RGBMASK">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PPAOPTAG_GRADSYMCENTER">
<short>Tag for <link id="ProcessPixelArray"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BLTBMA_MIXLEVEL">
<short>Tag for <link id="BltBitMapAlpha"/> and <link id="BltBitMapRastPortAlpha"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BLTBMA_USESOURCEALPHA">
<short>Tag for <link id="BltBitMapAlpha"/> and <link id="BltBitMapRastPortAlpha"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BLTBMA_GLOBALALPHA">
<short>Tag for <link id="BltBitMapAlpha"/> and <link id="BltBitMapRastPortAlpha"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BLTBMA_DESTALPHAVALUE">
<short>Tag for <link id="BltBitMapAlpha"/> and <link id="BltBitMapRastPortAlpha"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DESTALPHAVALUE_UNDEFINED">
<short>Value for Tag <link id="BLTBMA_DESTALPHAVALUE"/></short>
<descr>
</descr>
<seealso>
<link id="BltBitMapAlpha"/>
<link id="BltBitMapRastPortAlpha"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DESTALPHAVALUE_ONE">
<short>Value for Tag <link id="BLTBMA_DESTALPHAVALUE"/></short>
<descr>
</descr>
<seealso>
<link id="BltBitMapAlpha"/>
<link id="BltBitMapRastPortAlpha"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DESTALPHAVALUE_USESOURCE">
<short>Value for Tag <link id="BLTBMA_DESTALPHAVALUE"/></short>
<descr>
</descr>
<seealso>
<link id="BltBitMapAlpha"/>
<link id="BltBitMapRastPortAlpha"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DESTALPHAVALUE_USEDEST">
<short>Value for Tag <link id="BLTBMA_DESTALPHAVALUE"/></short>
<descr>
</descr>
<seealso>
<link id="BltBitMapAlpha"/>
<link id="BltBitMapRastPortAlpha"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WritePixelArrayAlpha">
<short>Write the color value of a rectangular array</short>
<descr>
<p>
  write the color value of a rectangular array of
  pixels starting at a specified x,y location and continuing through
  to another x,y location within a certain RastPort</p>
<p>For each pixel in a rectangular region, write the color value from a
    linear array of color values into the bitmap used to describe a
    particular rastport.</p>
<p><b>Attention</b></p>
<p>Only currently supported pixelformat is <link id="RECTFMT_ARGB"/></p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WritePixelArrayAlpha.Result">
<short>Number of pixels plotted</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.srcRect">
<short>pointer to an array of pixels from which to fetch the pixel data. The pixel format is always <link id="RECTFMT_ARGB"/></short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.SrcX">
<short>X starting point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.SrcY">
<short>Y starting point in the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.SrcMod">
<short>The number of bytes per row in the source rectangle.</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.a1arg">
<short>Pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.DestX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.DestY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.SizeX">
<short>Width of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.SizeY">
<short>Height of the rectangle that should be transfered</short>
</element>

<!-- argument Visibility: default -->
<element name="WritePixelArrayAlpha.globalAlpha">
<short>32 bit unsigned left justified fraction (1.0 = $ffffffff)</short>
</element>

<!-- procedure Visibility: default -->
<element name="BltTemplateAlpha">
<short>Blends an alpha mask into a rectangular area into the target RastPort. (v51)</short>
<descr>
<p>This function blends the alpha image in the template into the
    RastPort using the current color and drawing mode at the
    specified position.  The alpha template is assumed not to overlap
    the destination.</p><p>
    If the alpha template falls outside the RastPort boundary, it is
    truncated to that boundary.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="BltTemplate"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.source">
<short>pointer to the alpha 8bit mask array.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.xSrc">
<short>x offset into the alpha mask</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.srcMod">
<short>number of bytes per row in alpha mask array.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.destRP">
<short>pointer to destination RastPort.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.xDest">
<short>x coordinate of the upper left corner of the destination for the blit.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.yDest">
<short>y coordinate of the upper left corner of the destination for the blit.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.xSize">
<short>Width of the rectangle to be used as the template.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltTemplateAlpha.ySize">
<short>Height of the rectangle to be used as the template.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ProcessPixelArray">
<short>Applies one of a variety of transformations to a rectangular portion of a RastPort.</short>
<descr>
<p><b>Available Tags</b></p>
<dl>
  <dt>PPAOPTAG_GRADIENTTYPE</dt><dd><link id="GRADTYPE_HORIZONTAL"/> or <link id="GRADTYPE_VERTICAL"/></dd>
  <dt>PPAOPTAG_GRADCOLOR1</dt><dd>The starting color of the gradient (ARGB32).</dd>
  <dt>PPAOPTAG_GRADCOLOR2</dt><dd>The ending color of the gradient (ARGB32).</dd>
  <dt>PPAOPTAG_GRADFULLSCALE</dt><dd>  </dd>
  <dt>PPAOPTAG_GRADOFFSET</dt><dd>  </dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.rastport">
<short>the RastPort to process.</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.destX">
<short>Left corner of portion of RastPort to process.</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.destY">
<short>Top corner of portion of RastPort to process.</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.sizeX">
<short>Width of the affected area.</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.sizeY">
<short>Height of the affected area.</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.operation">
<short>one of the following transformation types:
  <link id="POP_TINT"/>, 
  <link id="POP_BLUR"/>, 
  <link id="POP_BRIGHTEN"/>,
  <link id="POP_DARKEN"/>,
  <link id="POP_SETALPHA"/>,
  <link id="POP_GRADIENT"/>
</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.value">
<short>see description of <var>operation</var> input.</short>
</element>

<!-- argument Visibility: default -->
<element name="ProcessPixelArray.taglist">
<short>currently describes gradient parameters</short>
</element>

<!-- function Visibility: default -->
<element name="BltBitMapAlpha">
<short>Blend a rectangular region of pixels in a BitMap. (v51)</short>
<descr>
<p>Blend a rectangular region of pixels in a BitMap.</p>
<p>Available Tags</p>
<dl>
  <dt>BLTBMA_DESTALPHAVALUE</dt><dd>Determines what happens to the destination
                                pixel alpha component. <link id="DESTALPHAVALUE_UNDEFINED"/>, <link id="DESTALPHAVALUE_ONE"/>, <link id="DESTALPHAVALUE_USESOURCE"/>, <link id="DESTALPHAVALUE_USEDEST"/></dd>
  <dt>BLTBMA_MIXLEVEL</dt><dd>Set the global 32bit left-justified alpha mix
                          level, defaults to $80808080 (50%) if source alpha
                          is not used, otherwise $FFFFFFFF (100%)</dd>
  <dt>BLTBMA_USESOURCEALPHA</dt><dd>Use the supplied per pixel source alpha value
                                if a non-zero data value is passed, disabled
                                by default</dd>
</dl>
<p>Uses hardware acceleration on dedicated hardware</p>
<p>Uses Altivec enabled code if hardware acceleration is not available
        but an Altivec unit is available</p>
</descr>
<errors>
</errors>
<seealso>
<link id="agraphics.ClipBlit">ClipBlit</link>
<link id="agraphics.BltBitMap">BltBitMap</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BltBitMapAlpha.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.srcBitMap">
<short>the BitMap(s) containing the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.xSrc">
<short>Left corner of the source rectangle.  Valid range is positive
        signed integer such that the raster word's offset
        0..(32767-Size)</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.ySrc">
<short>Top corner of the source rectangle.  Valid range is positive
        signed integer such that the raster word's offset
        0..(32767-Size)</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.destBitMap">
<short>the BitMap(s) containing the destination rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.xDest">
<short>the x coordinate of the upper left
        corner of the destination for the rectangle.  Valid
        range is as for Src.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.yDest">
<short>the y coordinate of the upper left
        corner of the destination for the rectangle.  Valid
        range is as for Src.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.xSize">
<short>Width of the rectangle to be moved.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.ySize">
<short>Height of the rectangle to be moved.</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapAlpha.tagList">
<short>tags for options</short>
</element>

<!-- function Visibility: default -->
<element name="BltBitMapRastPortAlpha">
<short>Blends from source bitmap to destination rastport. (v51)</short>
<descr>
<p>Blends from source bitmap to position specified in destination rastport.</p>
<p>Uses hardware acceleration on dedicated hardware</p>
<p>Uses Altivec enabled code if hardware acceleration is not available
        but an Altivec unit is available</p>
</descr>
<errors>
</errors>
<link id="BltBitMapAlpha"/>
<link id="BltMaskBitMapRastPort"/>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BltBitMapRastPortAlpha.Result">
<short>True</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.srcBitMap">
<short>a pointer to the source bitmap</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.xSrc">
<short>x offset into source bitmap</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.ySrc">
<short>y offset into source bitmap</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.destRP">
<short>a pointer to the destination rastport</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.xDest">
<short>x offset into dest rastport</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.yDest">
<short>y offset into dest rastport</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.xSize">
<short>width of blit in pixels</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.ySize">
<short>height of blit in rows</short>
</element>

<!-- argument Visibility: default -->
<element name="BltBitMapRastPortAlpha.tagList">
<short>optional taglist, see <link id="BltBitMapAlpha"/>() for options and defaults</short>
</element>

<!-- function Visibility: default -->
<element name="ScalePixelArrayAlpha">
<short>Scale the colors value of a rectangular array (V51)</short>
<descr>
<p>Scale the colors value of a rectangular array of
    pixels starting at a specified x,y location and continuing through
    to another x,y location within a certain RastPort (v51)</p>
<p>For each pixel in a rectangular region, scale and blend the color values from
    a linear alpha array of truecolor values into the bitmap used to describe a
    particular rastport.</p>
<p>This function should only be used on screens depths > 8 bits.</p>
<p>Uses hardware acceleration on dedicated hardware</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ScalePixelArrayAlpha.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.srcRect">
<short>pointer to an array of pixels from which to fetch the
      pixel data. The pixel format is fixed to <link id="RECTFMT_ARGB"/> and
      the alpha 8bit value is used to blend the data into the
      target</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.SrcW">
<short>Width of the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.SrcH">
<short>Height of the source rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.SrcMod">
<short>The number of bytes per row in the source rectangle.</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.a1arg">
<short>pointer to a RastPort structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.DestX">
<short>X starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.DestY">
<short>Y starting point in the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.DestW">
<short>Width of the destination area</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.DestH">
<short>Height of the destination area</short>
</element>

<!-- argument Visibility: default -->
<element name="ScalePixelArrayAlpha.globalAlpha">
<short>32bit left justified global alpha value, e.g. use
       $FFFFFFFF for full opacity. This global value is combined
       with the per pixel alpha of the source rectangle</short>
</element>

<!-- function Visibility: default -->
<element name="InitCyberGfxLibrary">
<short>deprecated, to open the cybergraphics library, only here for compatibilty reasons</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="InitCyberGfxLibrary.Result">
<short>True if cybergraphics lib is open</short>
</element>

</module> <!-- CYBERGRAPHICS -->

</package>
</fpdoc-descriptions>
