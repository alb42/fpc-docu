<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="morphunits">

<!--
  ====================================================================
    Intuition
  ====================================================================
-->

<module name="Intuition">
<short>Screen and Window handling routines of intuition.library</short>
<descr>
</descr>

<!-- pointer type Visibility: default -->
<element name="PIntuiText">
<short>IntuiText is a series of strings.</short>
<descr>IntuiText is a series of strings that start with a screen location
  (always relative to the upper-left corner of something) and then the
  text of the string.  The text is null-terminated.
</descr>
<seealso>
<link id="TGadget"/>
<link id="TExtGadget"/>
<link id="TRequester"/>
<link id="GFLG_LABELITEXT"/>
<link id="GA_IntuiText"/>
<link id="AutoRequest"/>
<link id="BuildSysRequest"/>
<link id="IntuiTextLength"/>
<link id="PrintIText"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIntuiText">
<short>IntuiText is a series of strings.</short>
<descr>IntuiText is a series of strings that start with a screen location
  (always relative to the upper-left corner of something) and then the
  text of the string.  The text is null-terminated.
</descr>
<seealso>
<link id="TGadget"/>
<link id="TExtGadget"/>
<link id="TRequester"/>
<link id="GFLG_LABELITEXT"/>
<link id="GA_IntuiText"/>
<link id="AutoRequest"/>
<link id="BuildSysRequest"/>
<link id="IntuiTextLength"/>
<link id="PrintIText"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.FrontPen">
<short>Front pen for Font rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.BackPen">
<short>Back pen for Font rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.DrawMode">
<short>The mode for rendering the text</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.LeftEdge">
<short>relative left start location for the text</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.TopEdge">
<short>relative top start location for the text</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.ITextFont">
<short>If nil, you accept the default</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.IText">
<short>A pointer to null-terminated text</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiText.NextText">
<short>Continuation to TxWrite another text</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PStringExtend">
<short>Extended string info for Gadgets texts</short>
<descr>
</descr>
<seealso>
<link id="GFLG_STRINGEXTEND"/>
<link id="GACT_STRINGEXTEND"/>
<link id="TStringInfo"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TStringExtend">
<short>Extended string info for Gadgets texts</short>
<descr>
</descr>
<seealso>
<link id="GFLG_STRINGEXTEND"/>
<link id="GACT_STRINGEXTEND"/>
<link id="TStringInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.Font">
<short>Must be an open Font (not TextAttr)</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.Pens">
<short>Color of text/background</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.ActivePens">
<short>Colors when gadget is active</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.InitialModes">
<short>Initial mode flags (e.g. <link id="Checked"/>, <link id="ISDRAWN"/>, <link id="HIGHITEM"/>, <link id="ITEMENABLED"/>, <link id="MENUTOGGLE"/>, <link id="COMMSEQ"/>, <link id="ITEMTEXT"/>, <link id="CHECKIT"/>)</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.EditHook">
<short>If non-nil, must supply WorkBuffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.WorkBuffer">
<short>Must be as large as StringInfo.Buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringExtend.Reserved">
<short>Set to 0</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PBorder">
<short>Pointer to Border Drawing structure</short>
<descr>
Data type Border, used for drawing a series of lines which is intended for use as a border drawing, but which may, in fact, be used to render any
  arbitrary vector shape. The routine DrawBorder sets up the RastPort with the appropriate variables, then does a Move to the first coordinate, then does Draws
  to the subsequent coordinates. After all the Draws are done, if NextBorder is non-zero we call DrawBorder recursively
</descr>
<seealso>
<link id="TRequester"/>
<link id="GA_Border"/>
<link id="DrawBorder"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TBorder">
<short>Pointer drawing structure</short>
<descr>
  Data type Border, used for drawing a series of lines which is intended for use as a border drawing, but which may, in fact, be used to render any
  arbitrary vector shape. The routine DrawBorder sets up the RastPort with the appropriate variables, then does a Move to the first coordinate, then does Draws
  to the subsequent coordinates. After all the Draws are done, if NextBorder is non-zero we call DrawBorder recursively
</descr>
<seealso>
<link id="TRequester"/>
<link id="GA_Border"/>
<link id="DrawBorder"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.LeftEdge">
<short>Initial left offsets from the origin</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.TopEdge">
<short>Initial top offsets from the origin</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.FrontPen">
<short>Front pen for rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.BackPen">
<short>Back pen for rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.DrawMode">
<short>Draw Mode for rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.Count">
<short>Number of XY pairs</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.XY">
<short>Vector coordinate pairs relative to LeftTop</short>
</element>

<!-- variable Visibility: default -->
<element name="TBorder.NextBorder">
<short>pointer to any other Border too</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMenuItem">
<short>Pointer to an menu item</short>
<descr>
</descr>
<seealso>
<link id="TMenu"/>
<link id="ItemAddress"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TMenuItem">
<short>Structure to describe a menu item</short>
<descr>
</descr>
<seealso>
<link id="TMenu"/>
<link id="ItemAddress"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.NextItem">
<short>Pointer to next in chained list</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.LeftEdge">
<short>Left position of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.TopEdge">
<short>Top position of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.Width">
<short>Width of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.Height">
<short>Height of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.Flags">
<short>Flags for the item (e.g. <link id="Checked"/>, <link id="ISDRAWN"/>, <link id="HIGHITEM"/>, <link id="ITEMENABLED"/>, <link id="MENUTOGGLE"/>, <link id="COMMSEQ"/>, <link id="ITEMTEXT"/>, <link id="CHECKIT"/>)</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.MutualExclude">
<short>Set bits mean this item excludes that</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.ItemFill">
<short><link id="PImage"/>, <link id="PIntuiText"/> or nil</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.SelectFill">
<short><link id="PImage"/>, <link id="PIntuiText"/> or nil when this item is pointed to by the cursor and the items highlight mode <link id="HIGHIMAGE"/> is selected, this alternate image will be displayed.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.Command">
<short>Only if application sets the <link id="COMMSEQ"/> flag</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.SubItem">
<short>If non-nil, DrawMenu shows "->"</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenuItem.NextSelect">
<short>The NextSelect field represents the menu number of next selected item (when user has drag-selected several items)</short>
</element>

<!-- constant Visibility: default -->
<element name="CHECKIT">
<short>Flag for <link id="TMenuItem"/>.Flags set by the Application, whether to check this item if selected</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEMTEXT">
<short>Flag for <link id="TMenuItem"/>.Flags set by the Application, set if textual, clear if graphical item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="COMMSEQ">
<short>Flag for <link id="TMenuItem"/>.Flags set by the Application, set if there's an command sequence</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUTOGGLE">
<short>Flag for <link id="TMenuItem"/>.Flags set by the Application, set to toggle the check of a menu item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEMENABLED">
<short>Flag for <link id="TMenuItem"/>.Flags set by the Application, set if this item is enabled</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHIMAGE">
<short>SPECIAL HIGHLIGHT FLAG state meanings for <link id="TMenuItem"/>.Flags, use the user's "select image"</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHCOMP">
<short>SPECIAL HIGHLIGHT FLAG state meanings for <link id="TMenuItem"/>.Flags, highlight by complementing the selectbox</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHBOX">
<short>SPECIAL HIGHLIGHT FLAG state meanings for <link id="TMenuItem"/>.Flags, highlight by "boxing" the selectbox</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHFLAGS">
<short>SPECIAL HIGHLIGHT FLAG state meanings for <link id="TMenuItem"/>.Flags, see definitions below for these bits</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHNONE">
<short>SPECIAL HIGHLIGHT FLAG state meanings for <link id="TMenuItem"/>.Flags, don't highlight</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="Checked">
<short>Flag for <link id="TMenuItem"/>.Flags set by the Application and intuition, if <link id="CHECKIT"/>, then set this when selected</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ISDRAWN">
<short>Flag for <link id="TMenuItem"/>.Flags set by intuition (ReadOnly), this item's subs are currently drawn</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHITEM">
<short>Flag for <link id="TMenuItem"/>.Flags set by intuition (ReadOnly), this item is currently highlighted</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUTOGGLED">
<short>Flag for <link id="TMenuItem"/>.Flags set by intuition (ReadOnly), this item was already toggled</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOMENU">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOITEM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOSUB">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUNULL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CHECKWIDTH">
<short>Define for <link id="CHECKIT"/> width for the CheckMark in a menu item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOWCHECKWIDTH">
<short>Define for <link id="CHECKIT"/> width for the CheckMark (Low res resolution) in a menu item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="COMMWIDTH">
<short>Define for <link id="COMMSEQ"/> width for the Command sequence in a menu item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOWCOMMWIDTH">
<short>Define for <link id="COMMSEQ"/> width for the Command sequence (Low resolution) in a menu item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PMenu">
<short>Pointer to a menu structure</short>
<descr>
</descr>
<seealso>
<link id="TWindow"/>
<link id="ItemAddress"/>
<link id="ResetMenuStrip"/>
<link id="SetMenuStrip"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TMenu">
<short>Structure to describe a menu</short>
<descr>
</descr>
<seealso>
<link id="TWindow"/>
<link id="ItemAddress"/>
<link id="ResetMenuStrip"/>
<link id="SetMenuStrip"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.NextMenu">
<short>Next Menu on the same level</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.LeftEdge">
<short>Left position of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.TopEdge">
<short>Top position of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.Width">
<short>Width of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.Height">
<short>Height of the select box</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.Flags">
<short>Flags for the menu (<link id="MENUENABLED"/>, <link id="MIDRAWN"/>)</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.MenuName">
<short>Text for this Menu Header </short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.FirstItem">
<short>Pointer to first menu item in chain</short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.JazzX">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.JazzY">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.BeatX">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TMenu.BeatY">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="MENUENABLED">
<short>Flag for <link id="TMenu"/>.Flags, whether or not this menu is enabled</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MIDRAWN">
<short>Flag for <link id="TMenu"/>.Flags, this menu's items are currently drawn (ReadOnly)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PGadget">
<short>Pointer to a Gadget structure</short>
<descr>
</descr>
<seealso>
<link id="TRequester"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="TScreen"/>
<link id="TNewScreen"/>
<link id="TExtNewScreen"/>
<link id="GA_Previous"/>
<link id="GA_Next"/>
<link id="TSGWork"/>
<link id="ActivateGadget"/>
<link id="AddGadget"/>
<link id="AddGList"/>
<link id="DoGadgetMethodA"/>
<link id="GadgetMouse"/>
<link id="ModifyProp"/>
<link id="ObtainGIRPort"/>
<link id="OffGadget"/>
<link id="OnGadget"/>
<link id="RefreshGadgets"/>
<link id="RefreshGList"/>
<link id="RemoveGadget"/>
<link id="RemoveGList"/>
<link id="SetGadgetAttrsA"/>
<link id="GADGET_BOX"/>
<link id="CUSTOM_HOOK"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TGadget">
<short>Structure to describe a Gadget</short>
<descr>
</descr>
<seealso>
<link id="TRequester"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="TScreen"/>
<link id="TNewScreen"/>
<link id="TExtNewScreen"/>
<link id="GA_Previous"/>
<link id="GA_Next"/>
<link id="TSGWork"/>
<link id="ActivateGadget"/>
<link id="AddGadget"/>
<link id="AddGList"/>
<link id="DoGadgetMethodA"/>
<link id="GadgetMouse"/>
<link id="ModifyProp"/>
<link id="ObtainGIRPort"/>
<link id="OffGadget"/>
<link id="OnGadget"/>
<link id="RefreshGadgets"/>
<link id="RefreshGList"/>
<link id="RemoveGadget"/>
<link id="RemoveGList"/>
<link id="SetGadgetAttrsA"/>
<link id="GADGET_BOX"/>
<link id="CUSTOM_HOOK"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.NextGadget">
<short>Next Gadget in the list</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.LeftEdge">
<short>Left edge of Hitbox</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.TopEdge">
<short>Top edge of Hitbox</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.Width">
<short>Width of Hitbox</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.Height">
<short>Height of Hitbox</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.Flags">
<short>Flag for Gadget (GFLG_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.Activation">
<short>Activation flag (GACT_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.GadgetType">
<short>Gadget typ (GTYP_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.GadgetRender">
<short>Application can specify that the Gadget be rendered as either as Border
or an Image. This variable points to which (or equals nil if there's nothing to be rendered about this Gadget)</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.SelectRender">
<short>Application can specify "highlighted" imagery rather than algorithmic this can point to either Border or Image data</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.GadgetText">
<short>Text for this gadget</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.MutualExclude">
<short>obsolete</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.SpecialInfo">
<short>A pointer to a structure of special data required by Proportional, String and LongInt Gadgets</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.GadgetID">
<short>User-definable ID field</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadget.UserData">
<short>A pointer to general purpose User data (ignored by Intuition)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtGadget">
<short>Pointer to and extended Gadget structure</short>
<descr>
</descr>
<seealso>
<link id="PGadget"/>
<link id="GFLG_EXTENDED"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExtGadget">
<short>Extended Gadget structure</short>
<descr>Check <link id="TGadget"/> for the meaning for the first fields.
</descr>
<seealso>
<link id="TGadget"/>
<link id="GFLG_EXTENDED"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtGadget.MoreFlags">
<short>Additional flags (GMORE_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtGadget.BoundsLeftEdge">
<short>Bounding extent for gadget, valid</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtGadget.BoundsTopEdge">
<short>only if <link id="GMORE_BOUNDS"/> is set. The</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtGadget.BoundsWidth">
<short>GFLG_RELxxx flags affect these</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtGadget.BoundsHeight">
<short>coordinates as well.</short>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_GADGHCOMP">
<short>Flag for <link id="TGadget"/>.Flags. Complement the select box</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_GADGHBOX">
<short>Flag for <link id="TGadget"/>.SpecialInfo. Draw a box around the image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_GADGHIMAGE">
<short>Flag for <link id="TGadget"/>.SpecialInfo. Blast in this alternate image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_GADGHNONE">
<short>Flag for <link id="TGadget"/>.SpecialInfo. don't highlight</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_GADGHIGHBITS">
<short>Flag for <link id="TGadget"/>.SpecialInfo. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_GADGIMAGE">
<short>Flag for <link id="TGadget"/>.SpecialInfo. set if <link id="TGadget"/>.GadgetRender <b>and</b> <link id="TGadget"/>.SelectRender is <link id="PImage"/>, clear if it is a <link id="PBorder"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_RELBOTTOM">
<short>Flag for <link id="TGadget"/>.SpecialInfo. vertical position is relative to bottom edge</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_RELRIGHT">
<short>Flag for <link id="TGadget"/>.SpecialInfo. horizontal position is relative to right edge </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_RELWIDTH">
<short>Flag for <link id="TGadget"/>.SpecialInfo. width is relative to req/window</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_RELHEIGHT">
<short>Flag for <link id="TGadget"/>.SpecialInfo. height is relative to req/window</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_SELECTED">
<short>Flag for <link id="TGadget"/>.SpecialInfo. you may initialize <b>and</b> look at this</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_DISABLED">
<short>Flag for <link id="TGadget"/>.SpecialInfo. Is initialized by you and later set by Intuition according to your calls to <link id="OnGadget"/>/<link id="OffGadget"/>. It specifies whether or not this Gadget is currently disabled from being selected</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_TABCYCLE">
<short>Flag for <link id="TGadget"/>.SpecialInfo. (string OR custom) gadget participates in cycling activation with Tab or Shift-Tab</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_STRINGEXTEND">
<short>Flag for <link id="TGadget"/>.SpecialInfo. this String Gadget has <link id="PStringExtend"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_IMAGEDISABLE">
<short>Flag for <link id="TGadget"/>.SpecialInfo. Gadget's image knows how to do disabled rendering</short>
<descr>
  This flag is automatically set if
  the custom image of this gadget knows how to do disabled rendering
  (more specifically, if its IA_SupportsDisable attribute is True).
  Intuition uses this to defer the ghosting to the image-class,
  instead of doing it itself (the old compatible way).
  Do not set this flag yourself - Intuition will do it for you.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_LABELITEXT">
<short>Flag for <link id="TGadget"/>.SpecialInfo. <link id="TGadget"/>.GadgetText is a <link id="PIntuiText"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_LABELSTRING">
<short>Flag for <link id="TGadget"/>.SpecialInfo. <link id="TGadget"/>.GadgetText is a PChar</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_LABELIMAGE">
<short>Flag for <link id="TGadget"/>.SpecialInfo. <link id="TGadget"/>.GadgetText is a <link id="PImage">PImage</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_LABELMASK">
<short>Flag for <link id="TGadget"/>.SpecialInfo. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_RELSPECIAL">
<short>Flag for <link id="TGadget"/>.SpecialInfo. Custom gadget has special relativity. Gadget box values are absolutes, but can be changed via the <link id="GM_LAYOUT"/> method.</short>
<descr>
  Allows custom gadget implementors to
  make gadgets whose position and size depend in an arbitrary way
  on their window's dimensions.  The <link id="GM_LAYOUT"/> method will be invoked
  for such a gadget (or any other GREL_xxx gadget) at suitable times,
  such as when the window opens or the window's size changes.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GFLG_EXTENDED">
<short>Flag for <link id="TGadget"/>.SpecialInfo. Gadget is an <link id="PExtGadget"/></short>
<descr>
  If set, this bit means that the Gadget is actually
  a <link id="PExtGadget"/>, with new fields and flags.  All boopsi
  gadgets are <link id="PExtGadget"/>.  Never ever attempt to read the extended
  fields of a gadget if this flag is not set.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_RELVERIFY">
<short>Activation flag for <link id="TGadget"/>.Activation. Set if you want to verify that the pointer was still over the gadget when the select button was released.  Will cause an <link id="IDCMP_GADGETUP"/> message to be sent if so.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_IMMEDIATE">
<short>Activation flag for <link id="TGadget"/>.Activation. when set, informs the caller that the gadget was activated when it was activated.  This flag works in conjunction with the <link id="GACT_RELVERIFY"/> flag</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_ENDGADGET">
<short>Activation flag for <link id="TGadget"/>.Activation. when set, tells the system that this gadget, when selected, causes the Requester to be ended.  Requesters that are ended are erased and unlinked from the system.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_FOLLOWMOUSE">
<short>Activation flag for <link id="TGadget"/>.Activation. when set, specifies that you want to receive reports on mouse movements</short>
<descr>
  Flag, when set, specifies that you want to receive
  reports on mouse movements while this gadget is active.
  You probably want to set the <link id="GACT_IMMEDIATE"/> flag when using
  <link id="GACT_FOLLOWMOUSE"/>, since that's the only reasonable way you have of
  learning why Intuition is suddenly sending you a stream of mouse
  movement events.  If you don't set <link id="GACT_RELVERIFY"/>, you'll get at
  least one Mouse Position event.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_RIGHTBORDER">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>if set in a Gadget that's included in the Gadget list when a Window is opened, the corresponding Border will be adjusted to make room for the Gadget
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_LEFTBORDER">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>if set in a Gadget that's included in the Gadget list when a Window is opened, the corresponding Border will be adjusted to make room for the Gadget
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_TOPBORDER">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>if set in a Gadget that's included in the Gadget list when a Window is opened, the corresponding Border will be adjusted to make room for the Gadget
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_BOTTOMBORDER">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>if set in a Gadget that's included in the Gadget list when a Window is opened, the corresponding Border will be adjusted to make room for the Gadget
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_TOGGLESELECT">
<short>Activation flag for <link id="TGadget"/>.Activation. this bit for toggle-select mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_STRINGLEFT">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_STRINGCENTER">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_STRINGRIGHT">
<short>Activation flag for <link id="TGadget"/>.Activation. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_LONGINT">
<short>Activation flag for <link id="TGadget"/>.Activation. this String Gadget is for LongInts</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_ALTKEYMAP">
<short>Activation flag for <link id="TGadget"/>.Activation. this String has an alternate keymap</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_STRINGEXTEND">
<short>Activation flag for <link id="TGadget"/>.Activation. this String Gadget has <link id="PStringExtend"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_BOOLEXTEND">
<short>Activation flag for <link id="TGadget"/>.Activation. this Boolean Gadget has a BoolInfo</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_ACTIVEGADGET">
<short>Activation flag for <link id="TGadget"/>.Activation. This gadget is "active".</short>
<descr>
This flag is maintained by Intuition, and you cannot count on its value persisting
while you do something on your program's task.  It can only be trusted by people implementing custom gadgets
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GACT_BORDERSNIFF">
<short>Activation flag for <link id="TGadget"/>.Activation. neither set nor rely on this bit</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_GADGETTYPE">
<short>All Gadget Global type flags for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_SIZING">
<short>System gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_WDRAGGING">
<short>System gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_SDRAGGING">
<short>System gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_CLOSE">
<short>System gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_REQGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type this is a Requester Gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_GZZGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type for <link id="WFLG_GIMMEZEROZERO"/> borders</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_SCRGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type 1 = ScreenGadget, 0 = WindowGadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_SYSGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type 1 = Allocated by the system, 0 = by application</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_BOOLGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_GADGET0002">
<short>Application gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_PROPGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_STRGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_CUSTOMGADGET">
<short>Application gadget type for <link id="TGadget"/>.Type</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_GTYPEMASK">
<short>Application gadget type for <link id="TGadget"/>.Type mask you can apply to tell what class of gadget this is.</short>
<descr>
The possible classes: <link id="GTYP_BOOLGADGET"/>, <link id="GTYP_GADGET0002"/>, <link id="GTYP_PROPGADGET"/>, <link id="GTYP_STRGADGET"/> or <link id="GTYP_CUSTOMGADGET"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMORE_BOUNDS">
<short>Flag for <link id="TExtGadget"/>.MoreFlags ExtGadget has valid Bounds</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMORE_GADGETHELP">
<short>Flag for <link id="TExtGadget"/>.MoreFlags This gadget responds to gadget help</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMORE_SCROLLRASTER">
<short>Flag for <link id="TExtGadget"/>.MoreFlags This (custom) gadget uses ScrollRaster</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PBoolInfo">
<short>Special info for <link id="TGadget"/>.SpecialInfo if <link id="TGadget"/>.Type is a <link id="GTYP_BOOLGADGET"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TBoolInfo">
<short>Boolgadget informations <link id="PBoolInfo"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TBoolInfo.Flags">
<short>Flags for BoolGadget <link id="BOOLMASK"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TBoolInfo.Mask">
<short>Bit mask for highlighting and selecting mask must follow the same rules as an Image plane.
It's width and height are determined by the width and height of the gadget's select box. (i.e. <link id="TGadget"/>.Width and <link id="TGadget"/>.Height).</short>
</element>

<!-- variable Visibility: default -->
<element name="TBoolInfo.Reserved">
<short>Set to 0</short>
</element>

<!-- constant Visibility: default -->
<element name="BOOLMASK">
<short>Extension is for masked gadget</short>
<descr>
Set <link id="TBoolInfo"/>.Flags to this flag bit. in the future, additional bits might mean more stuff hanging  off of <link id="TBoolInfo"/>.Reserved.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPropInfo">
<short>Special info for <link id="TGadget"/>.SpecialInfo if <link id="TGadget"/>.Type is a <link id="GTYP_PROPGADGET"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TPropInfo">
<short>Proportional Gadget</short>
<descr><p>You initialize the Pot variables before the Gadget is added to
the system.  Then you can look here for the current settings
any time, even while User is playing with this Gadget.  To
adjust these after the Gadget is added to the System, use
<link id="ModifyProp">ModifyProp()</link> The Pots are the actual proportional settings,
where a value of zero means zero and a value of <link id="MAXPOT"/> means
that the Gadget is set to its maximum setting.</p>
<p>
The 16-bit FixedPoint Body variables describe what percentage of
the entire body of stuff referred to by this Gadget is actually
shown at one time.  This is used with the <link id="AUTOKNOB"/> routines,
to adjust the size of the <link id="AUTOKNOB"/> according to how much of
the data can be seen.  This is also used to decide how far
to advance the Pots when User hits the Container of the Gadget.
For instance, if you were controlling the display of a 5-line
Window of text with this Gadget, and there was a total of 15
lines that could be displayed, you would set the VertBody value to
    (<link id="MAXBODY"/> / (TotalLines / DisplayLines)) = <link id="MAXBODY"/> / 3.
Therefore, the <link id="AUTOKNOB"/> would fill 1/3 of the container, and
if User hits the Cotainer outside of the knob, the pot would
advance 1/3 (plus or minus) If there's no body to show, or
the total amount of displayable info is less than the display area,
set the Body variables to the max.  To adjust these after the
Gadget is added to the System, use <link id="ModifyProp">ModifyProp()</link>
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.Flags">
<short>General purpose flag bits (e.g. <link id="AUTOKNOB"/>, <link id="FREEHORIZ"/>, <link id="FREEVERT"/>, <link id="PROPBORDERLESS"/>, <link id="KNOBHIT"/> or  <link id="PROPNEWLOOK"/>)</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.HorizPot">
<short>16-bit FixedPoint horizontal quantity percentage</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.VertPot">
<short>16-bit FixedPoint vertical quantity percentage</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.HorizBody">
<short>horizontal Body</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.VertBody">
<short>vertical Body</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.CWidth">
<short>Container width (with any relativity absoluted) Intuition sets and maintain</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.CHeight">
<short>Container height (with any relativity absoluted) Intuition sets and maintain</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.HPotRes">
<short>Horizontal pot increment</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.VPotRes">
<short>Vertical pot increment</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.LeftBorder">
<short>Left Container border</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropInfo.TopBorder">
<short>Top Container border</short>
</element>

<!-- constant Visibility: default -->
<element name="AUTOKNOB">
<short>Flag value for <link id="TPropInfo"/>.Flags. Gimme that old auto-knob</short>
<descr>
If you do not use an AUTOKNOB for a proportional gadget,
you are currently limited to using a single Image of your own design: Intuition won't handle a linked list
of images as a proportional gadget knob.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FREEHORIZ">
<short>Flag value for <link id="TPropInfo"/>.Flags. if set, the knob can move horizontally</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FREEVERT">
<short>Flag value for <link id="TPropInfo"/>.Flags. if set, the knob can move vertically</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PROPBORDERLESS">
<short>Flag value for <link id="TPropInfo"/>.Flags. if set, no border will be rendered</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KNOBHIT">
<short>Flag value for <link id="TPropInfo"/>.Flags. set when this Knob is hit</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PROPNEWLOOK">
<short>Flag value for <link id="TPropInfo"/>.Flags. set this if you want to get the new look</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KNOBHMIN">
<short>Minimum horizontal size of the <link id="TPropInfo">Knop</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KNOBVMIN">
<short>minimum vertical size of the <link id="TPropInfo">Knop</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAXBODY">
<short>Maximum body value in <link id="TPropInfo"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAXPOT">
<short>Maximum pot value  in <link id="TPropInfo"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PStringInfo">
<short>Special info for <link id="TGadget"/>.SpecialInfo if <link id="TGadget"/>.Type is a <link id="GTYP_STRGADGET"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TStringInfo">
<short>String Gadget structure</short>
<descr>
</descr>
<seealso>
<link id="PStringInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.Buffer">
<short>The buffer containing the start and final string</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.UndoBuffer">
<short>Optional buffer for undoing current entry</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.BufferPos">
<short>Character position in Buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.MaxChars">
<short>Maximal number of chars in Buffer (including #0)</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.DispPos">
<short>Buffer position of first displayed character</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.UndoPos">
<short>Character position in the undo buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.NumChars">
<short>Number of characters currently in Buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.DispCount">
<short>Number of whole characters visible in Container</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.CLeft">
<short>Left offset of the container</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.CTop">
<short>Top offset of the container</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.Extension">
<short>you can initialize this variable before the gadget is submitted to
      Intuition, and then examine it later to discover what LongInt
      the user has entered (if the user never plays with the gadget,
      the value will be unchanged from your initial setting)</short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo._LongInt">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TStringInfo.AltKeyMap">
<short>If you want this Gadget to use your own Console keymapping, you
      set the <link id="GACT_ALTKEYMAP"/> bit in the Activation flags of the Gadget, and then
      set this variable to point to your keymap.  If you don't set the
      <link id="GACT_ALTKEYMAP"/>, you'll get the standard ASCII keymapping.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PImage">
<short>This is a brief image structure for very simple transfers of image data to a RastPort</short>
<descr>
</descr>
<seealso>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="TDrawInfo"/>
<link id="GA_Image"/>
<link id="GA_SelectRender"/>
<link id="DrawImage"/>
<link id="DrawImageState"/>
<link id="EraseImage"/>
<link id="PointInImage"/>
<link id="IM_BGPEN"/>
<link id="IM_BOX"/>
<link id="IM_FGPEN"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PWindow">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PScreen">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PRequester">
<short>Requesters The following struct is used for standard intuition requesters</short>
<descr>
not to be mixed up with asl or easy requesters. See <link id="Request">Request()</link> for more information.
</descr>
<seealso>
<link id="TWindow"/>
<link id="TGadgetInfo"/>
<link id="ActivateGadget"/>
<link id="AddGList"/>
<link id="DoGadgetMethodA"/>
<link id="EndRequest"/>
<link id="InitRequester"/>
<link id="ModifyProp"/>
<link id="NewModifyProp"/>
<link id="OffGadget"/>
<link id="OnGadget"/>
<link id="RefreshGadgets"/>
<link id="RefreshGList"/>
<link id="Request"/>
<link id="SetDMRequest"/>
<link id="SetGadgetAttrsA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRequester">
<short>Requesters The following struct is used for standard intuition requesters</short>
<descr>
<p>The ClipRect and BitMap and used for rendering the requester</p>
<p>
If the BitMap plane pointers are non-zero, this tells the system
that the image comes pre-drawn (if the appliprog wants to define
it's own box, in any shape or size it wants!);  this is OK by
Intuition as long as there's a good correspondence between
the image and the specified Gadgets</p>
</descr>
<seealso>
<link id="PRequester"/>
<link id="TWindow"/>
<link id="TGadgetInfo"/>
<link id="ActivateGadget"/>
<link id="AddGList"/>
<link id="DoGadgetMethodA"/>
<link id="EndRequest"/>
<link id="InitRequester"/>
<link id="ModifyProp"/>
<link id="NewModifyProp"/>
<link id="OffGadget"/>
<link id="OnGadget"/>
<link id="RefreshGadgets"/>
<link id="RefreshGList"/>
<link id="Request"/>
<link id="SetDMRequest"/>
<link id="SetGadgetAttrsA"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.OlderRequest">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.LeftEdge">
<short>dimensions of the entire box</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.TopEdge">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.Height">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.RelLeft">
<short>For Pointer relativity offsets</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.RelTop">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqGadget">
<short>First gadget of the requester</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqBorder">
<short>First border of the requester</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqText">
<short>First intuitext of the requester</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.Flags">
<short>Flags for requester (e.g. <link id="POINTREL"/>, <link id="PREDRAWN"/>, <link id="NOISYREQ"/>, <link id="SIMPLEREQ"/>, <link id="USEREQIMAGE"/>,
<link id="NOREQBACKFILL"/>, <link id="REQOFFWINDOW"/>,<link id="REQACTIVE"/>, <link id="SYSREQUEST"/> or <link id="DEFERREFRESH"/>)</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.BackFill">
<short>Pen number for back-plane fill before draws</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqLayer">
<short>Layer in place of clip rect</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqPad1">
<short>Private</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ImageBMap">
<short>you may use this to fill the requester with your own image</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.RWindow">
<short>Window, which the requester belongs to</short>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqImage">
<short>corresponds to <link id="USEREQIMAGE"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRequester.ReqPad2">
<short>Private</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TImage">
<short>This is a brief image structure for very simple transfers of image data to a RastPort</short>
<descr>
<p>The <i>TImage.PlanePick</i> and <i>PlaneOnOff</i> variables work much the same way as the equivalent GELS Bob variables.  It's a space-saving
  mechanism for image data.  Rather than defining the image data for every plane of the RastPort, you need define data only
  for the planes that are not entirely zero or one.  As you define your Imagery, you will often find that most of the planes
  ARE just as color selectors.  For instance, if you're designing a two-color Gadget to use colors two and three, and the Gadget
  will reside in a five-plane display, bit plane zero of your imagery would be all ones, bit plane one would have data that
  describes the imagery, and bit planes two through four would be all zeroes.  Using these flags allows you to avoid wasting all
  that memory in this way:  first, you specify which planes you want your data to appear in using the PlanePick variable.  For
  each bit set in the variable, the next "plane" of your image data is blitted to the display.  For each bit clear in this
  variable, the corresponding bit in PlaneOnOff is examined. If that bit is clear, a "plane" of zeroes will be used.
  If the bit is set, ones will go out instead.  So, for our example:</p>
<p>Gadget.PlanePick = $02;</p>
<p>Gadget.PlaneOnOff = $01;</p>
<p>
  Note that this also allows for generic Gadgets, like the System Gadgets, which will work in any number of bit planes.
  Note also that if you want an Image that is only a filled rectangle, you can get this by setting PlanePick to zero
  (pick no planes of data) and set PlaneOnOff to describe the pen color of the rectangle.</p>
</descr>
<seealso>
<link id="PImage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="TDrawInfo"/>
<link id="GA_Image"/>
<link id="GA_SelectRender"/>
<link id="DrawImage"/>
<link id="DrawImageState"/>
<link id="EraseImage"/>
<link id="PointInImage"/>
<link id="IM_BGPEN"/>
<link id="IM_BOX"/>
<link id="IM_FGPEN"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TImage.LeftEdge">
<short>Starting offset relative to some origin</short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.TopEdge">
<short>Starting offsets relative to some origin</short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.Width">
<short>Pixel size (though data is Word-aligned)</short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.Height">
<short>Height of image</short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.Depth">
<short>Pixel size</short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.ImageData">
<short>A Pointer to the actual Word-aligned bits</short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.PlanePick">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.PlaneOnOff">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TImage.NextImage">
<short>If not nil, Intuition presumes that it points to another Image structure with another Image to be rendered</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PTabletData">
<short>Pointer to a IntuiMessage TabletData</short>
<descr>If your window sets <link id="WA_TabletMessages"/> to True, then it will receive extended IntuiMessages (<link id="TExtIntuiMessage"/>) whose <link id="TExtIntuiMessage">.eim_TabletData</link>
  field points at a TabletData structure.  This structure contains additional information about the input event.
</descr>
<seealso>
<link id="TExtIntuiMessage"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TTabletData">
<short>IntuiMessage TabletData</short>
<descr>If your window sets <link id="WA_TabletMessages"/> to True, then it will receive extended IntuiMessages (<link id="TExtIntuiMessage"/>) whose <link id="TExtIntuiMessage">.eim_TabletData</link>
  field points at a TabletData structure.  This structure contains additional information about the input event.
</descr>
<seealso>
<link id="TExtIntuiMessage"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_XFraction">
<short>Sub-pixel position of tablet, in screen coordinates, scaled to fill a Word fraction:</short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_YFraction">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_TabletX">
<short>Current tablet coordinates along each axis</short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_TabletY">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_RangeX">
<short>Tablet range along each axis.  For example, if <i>td_TabletX</i> can take values 0-999, <i>td_RangeX</i> should be 1000.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_RangeY">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletData.td_TagList">
<short>Pointer to tag-list of additional tablet attributes. TABLETA_*</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PTabletHookData">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TTabletHookData">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TTabletHookData.thd_Screen">
<short>Pointer to the active screen: Note: if there are no open screens, <i>thd_Screen</i> will be nil.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletHookData.thd_Width">
<short>Scaled to a standard NTSC width of 640.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletHookData.thd_Height">
<short>Scaled to a standard NTSC height of 400</short>
</element>

<!-- variable Visibility: default -->
<element name="TTabletHookData.thd_ScreenChanged">
<short>Non-zero if the screen or something about the screen  changed since the last time you were invoked</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntuiMessage">
<short>Pointer to an Intuition message</short>
<descr>
</descr>
<seealso>
<link id="TWindow"/>
<link id="exec.GetMsg"/>
<link id="exec.PutMsg"/>
<link id="exec.ReplyMsg"/>
<link id="exec.WaitPort"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIntuiMessage">
<short>Intuition message structure</short>
<descr>
</descr>
<seealso>
<link id="TWindow"/>
<link id="exec.GetMsg"/>
<link id="exec.PutMsg"/>
<link id="exec.ReplyMsg"/>
<link id="exec.WaitPort"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.ExecMessage">
<short>Standard Exec message </short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.IClass">
<short>The Class bits correspond directly with the IDCMP Flags (IDCMP_*), except for the special bit <link id="IDCMP_LONELYMESSAGE"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.Code">
<short>The Code field is for special values like Menu number, Keycode and so on</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.Qualifier">
<short>The Qualifier field is a copy of the current InputEvent's Qualifier</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.IAddress">
<short>IAddress contains particular addresses for Intuition functions, like the pointer to the Gadget or the Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.MouseX">
<short>When getting mouse movement reports, any event you get will have the the mouse coordinates in these variables.</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.MouseY">
<short>the coordinates are relative to the upper-left corner of your Window (<link id="WA_GIMMEZEROZERO"/> notwithstanding)</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.Seconds">
<short>The time values are copies of the current system clock time.</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.Micros">
<short>Micros are in units of microseconds, Seconds in seconds.</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.IDCMPWindow">
<short>The IDCMPWindow variable will always have the Pointer of the Window of this IDCMP</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuiMessage.SpecialLink">
<short>System-use variable</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtIntuiMessage">
<short>Pointer to an extended Intuition message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExtIntuiMessage">
<short>Extended Intuition message structure</short>
<descr><p>
  All IntuiMessages are now slightly extended.  The ExtIntuiMessage
  structure has an additional field for tablet data, which is usually
  nil.</p>
<p><b>Note</b></p>
<p>This structure is subject to grow in the future. Making assumptions about its size is a bad idea.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtIntuiMessage.eim_IntuiMessage">
<short>Standard Intuition message</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtIntuiMessage.eim_TabletData">
<short>Pointer to tablet data</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PIBox">
<short>A data structure common in Intuition processing</short>
<descr>
</descr>
<seealso>
<link id="GA_Bounds"/>
<link id="TimpFrameBox"/>
<link id="TGadgetInfo"/>
<link id="TPGX"/>
<link id="TgpDomain"/>
<link id="IM_BOX"/>
<link id="GADGET_BOX"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIBox">
<short>A data structure common in Intuition processing</short>
<descr>Describes a rectangle via a point with width and height
</descr>
<seealso>
<link id="GA_Bounds"/>
<link id="TimpFrameBox"/>
<link id="TGadgetInfo"/>
<link id="TPGX"/>
<link id="TgpDomain"/>
<link id="IM_BOX"/>
<link id="GADGET_BOX"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIBox.Left">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIBox.Top">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIBox.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIBox.Height">
<short></short>
</element>

<!-- record type Visibility: default -->
<element name="TWindow">
<short>Window structure</short>
<descr>
<p>The border variables describe the window border.   If you specify
<link id="WA_GIMMEZEROZERO"/> when you open the window, then the upper-left of the
ClipRect for this window will be upper-left of the BitMap (with correct
offsets when in SuperBitMap mode; you <b>must</b> select <link id="WA_GIMMEZEROZERO"/> when
using SuperBitMap).  If you don't specify ZeroZero, then you save
memory (no allocation of RastPort, Layer, ClipRect and associated
Bitmaps), but you also must offset all your writes by BorderTop,
BorderLeft and do your own mini-clipping to prevent writing over the
system gadgets</p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.NextWindow">
<short>For the linked list in a screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.LeftEdge">
<short>Left edge of window on the screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.TopEdge">
<short>Top edge of window on the screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Width">
<short>Width of Window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Height">
<short>Height of Window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MouseY">
<short>Y Mouse position relative to upper-left edge of Window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MouseX">
<short>X Mouse position relative to upper-left edge of Window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MinWidth">
<short>Minimum width for resizeable windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MinHeight">
<short>Minimum height for resizeable windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MaxWidth">
<short>Maximum width of resizeable windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MaxHeight">
<short>Maximum height of resizeable windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Flags">
<short>Window Flags (WFLG_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MenuStrip">
<short>The strip of menu headers</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Title">
<short>The title text for this window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.FirstRequest">
<short>All active requesters</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.DMRequest">
<short>Double click requester</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.ReqCount">
<short>Count of requester blocking Window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.WScreen">
<short>This Window's Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.RPort">
<short>This Window's very own RastPort</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.BorderLeft">
<short>Width of window decoration on the left</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.BorderTop">
<short>Width of window decoration on the top</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.BorderRight">
<short>Width of window decoration on the right</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.BorderBottom">
<short>Width of window decoration on the bottom</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.BorderRPort">
<short>Rastport to draw on the Border</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.FirstGadget">
<short>You supply a linked-list of Gadgets for your Window. This list <b>does not</b> include system gadgets.</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Parent">
<short>these are for opening/closing the windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Descendant">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow._Pointer">
<short>sprite data</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.PtrHeight">
<short>sprite height (not including sprite padding)</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.PtrWidth">
<short>sprite width (must be less than or equal to 16)</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.XOffset">
<short>sprite X offset</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.YOffset">
<short>sprite Y offset</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.IDCMPFlags">
<short>User-selected flags (IDCMP_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.UserPort">
<short>User message port </short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.WindowPort">
<short>Intuition's message port</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MessageKey">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.DetailPen">
<short>for bar/border/gadget rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.BlockPen">
<short>for bar/border/gadget rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.CheckMark">
<short>the CheckMark is a pointer to the imagery that will be used when  rendering MenuItems of this Window that want to be checkmarked if this is equal to nil, you'll get the default imagery</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.ScreenTitle">
<short>if non-nil, Screen title when Window is active</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.GZZMouseX">
<short>These variables have the mouse coordinates relative to the</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.GZZMouseY">
<short>inner-Window of GIMMEZEROZERO Windows.</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.GZZWidth">
<short>width of the inner-Window of GIMMEZEROZERO Windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.GZZHeight">
<short>height of the inner-Window of GIMMEZEROZERO Windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.ExtData">
<short>general-purpose pointer to User data extension</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.UserData">
<short>general-purpose pointer to User data extension</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.WLayer">
<short>Layer of the window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.IFont">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.MoreFlags">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.RelLeftEdge">
<short>relative coordinates of the window to its parent window. If it is</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.RelTopEdge">
<short>a window on the screen then these are the same as LeftEdge and TopEdge.</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.FirstChild">
<short>pointer to first child</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.PrevChild">
<short>if window is a child of a window</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.NextChild">
<short>then they are concatenated here.</short>
</element>

<!-- variable Visibility: default -->
<element name="TWindow.Parent2">
<short>parent of this window</short>
</element>

<!-- record type Visibility: default -->
<element name="TScreen">
<short>Basic screen structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.NextScreen">
<short>linked list of screens in intuition</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.FirstWindow">
<short>linked list Screen's Windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.LeftEdge">
<short>Left edge of Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.TopEdge">
<short>Top Edge of screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.Width">
<short>Width of screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.Height">
<short>Height of screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.MouseX">
<short>Current mouse position, relative to upper left edge</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.MouseY">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.Flags">
<short>Screen flags</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.Title">
<short>Screen title</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.DefaultTitle">
<short>shown when window without screen title is active</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.BarHeight">
<short>Bar sizes for this Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.BarVBorder">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.BarHBorder">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.MenuVBorder">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.MenuHBorder">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.WBorTop">
<short>Decoration size for all windows in this screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.WBorLeft">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.WBorRight">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.WBorBottom">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.Font">
<short>this screen's default font</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.ViewPort">
<short>describing the Screen's display</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.RastPort">
<short>describing Screen rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.BitMap">
<short>extra copy of RastPort BitMap obsolete</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.LayerInfo">
<short>each screen gets a LayerInfo</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.FirstGadget">
<short>You supply a linked-list of Gadgets for your Screen. This list <b>does not</b> include system Gadgets. You get the standard system Screen Gadgets by default</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.DetailPen">
<short>for bar/border/gadget rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.BlockPen">
<short>for bar/border/gadget rendering</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.SaveColor0">
<short>SAve variable for display Beep</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.BarLayer">
<short>This layer is for the Screen and Menu bars</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.ExtData">
<short>general purpose to User data extension</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreen.UserData">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_SIZEVERIFY">
<short>IDCMP class: resize must be verified by application</short>
<descr>
  Set this flag if the program must complete some operation before the
  user sizes the window.  When the user sizes the window, Intuition
  sends an <i>IDCMP_SIZEVERIFY</i> message to the application and then waits
  until the program replies before allowing the user to size the
  window.  See the "Verification Functions" section below for some
  things to consider when using this flag.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_NEWSIZE">
<short>IDCMP class: User resized the Window</short>
<descr>
  Intuition sends this message after the user has resized the window.
  After receiving this, the program can examine the size variables in
  the window structure to discover the new size of the window.  The
  message is sent, even if the size of the window did not actually
  change.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_REFRESHWINDOW">
<short>IDCMP class: Window needs refreshing</short>
<descr><p>
    This message is sent whenever the window needs refreshing.  This flag
    makes sense only with windows that have a refresh type of
    <link id="WA_SimpleRefresh"/> or <link id="WA_SmartRefresh"/>.</p>
<p>
    As a minimum, the application must call <link id="BeginRefresh">BeginRefresh()</link> and
    <link id="EndRefresh">EndRefresh()</link> for the window after receiving an <i>IDCMP_REFRESHWINDOW</i>
    event.  Create the window with the <link id="WA_NoCareRefresh"/> attribute if you
    do not want to manage these events.</p>
<p>
    Most of the graphics library calls used for display output are
    compatible with Intuition, with the exception of <link id="agraphics.ScrollRaster">ScrollRaster()</link>.
    Intuition will not send an <i>IDCMP_REFRESHWINDOW</i> event when damage is
    caused to a window by <link id="agraphics.ScrollRaster">ScrollRaster()</link>. This may happen in a simple
    refresh window which is partially obscured by another window--the
    region that scrolls out from behind the front window will be damaged,
    but the window will receive no notification.  Check the <link id="layers.LAYERREFRESH"/>
    bit in the Layer structure Flags field to see if damage did happen as
    a result of <link id="agraphics.ScrollRaster">ScrollRaster()</link>.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_MOUSEBUTTONS">
<short>IDCMP class: Contains reports about mouse button up and down events.</short>
<descr>
<p>Contains reports about mouse button up and down events.  The events
    will be sent to the application only if they are not used internally
    by Intuition.</p>
<p>
    The Code field contains information on the specific mouse button
    event this message represents.  The Code field will be equal to
    <link id="SELECTDOWN"/>, <link id="SELECTUP"/>, <link id="MENUDOWN"/>, <link id="MENUUP"/>, <link id="MIDDLEDOWN"/> or <link id="MIDDLEUP"/>,
    depending on the button pressed or released.  In general, the select
    button is the left mouse button, the menu button is the right mouse
    button and the middle button is an optional third button usually
    located between the select and menu buttons.</p>
<p>
    Often, a mouse button event has extra meaning to Intuition, and the
    application may hear about it through a more specific message, for
    example a gadget or menu event.  Other times, no event is generated
    at all, such as when the user depth-arranges a screen by clicking on
    the screen depth gadget.  Note that menu button events are normally
    consumed by Intuition for menu handling.  If an application wishes to
    hear <i>IDCMP_MOUSEBUTTONS</i> events for the menu button, it must set the
    <link id="WA_RMBTrap"/>> attribute for its window.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_MOUSEMOVE">
<short>IDCMP class: Reports about mouse movements</short>
<descr>
<p>Reports about mouse movements, sent in the form of x and y
    coordinates relative to the upper left corner of the window.  One
    message will be sent to the application for each "tick" of the mouse.</p>
<p>
    The application can opt to receive <i>IDCMP_MOUSEMOVE</i> events only while
    certain gadgets are active, or during normal window operation.  These
    events are sent whenever a gadget with <link id="GACT_FOLLOWMOUSE"/> gadget is
    active, or for any window that has the <link id="WA_ReportMouse"/> attribute set.
    This window attribute can be set or cleared by the application at
    will.</p>
<p>
    Requesting <i>IDCMP_MOUSEMOVE</i> messages can create a very large volume of
    messages arriving at the window's IDCMP.  Do not request these
    messages unless the program is prepared to keep up with them.
    Intuition limits the number of mouse move events
    that pile up at your IDCMP.</p>
<p>
    All IDCMP messages contain a mouse x and y position that can be
    absolute values or delta values.  See <link id="IDCMP_DELTAMOVE"/>. If the
    application requires a less frequent reporting of the mouse position,
    consider using <link id="IDCMP_INTUITICKS"/>.  While <i>IDCMP_MOUSEMOVE</i> events are
    generated by changes in the mouse's position, <link id="IDCMP_INTUITICKS"/>
    IntuiMessages are based on a timer.  Since they contain mouse
    coordinates, they effectively sample the mouse position.  These
    message come often enough for many applications, but not so
    frequently as to swamp the application.</p>
<p>
    The program will not be sent <i>IDCMP_MOUSEMOVE</i> messages while Intuition
    has the layers of the screen locked (during menu operations and
    window sizing/dragging).  This avoids problems of messages
    accumulating while the program is blocked, waiting to render into a
    locked layer.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_GADGETDOWN">
<short>IDCMP class: user selects a gadget</short>
<descr>
<i>IDCMP_GADGETDOWN</i> messages are sent when the user selects a gadget
  that was created with the <link id="GACT_IMMEDIATE"/>GACT_IMMEDIATE flag set.
  The <link id="TIntuiMessage">IAddress</link> field will contain a pointer to the selected gadget.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_GADGETUP">
<short>IDCMP class: user selects a gadget</short>
<descr>
<i>IDCMP_GADGETUP</i> messages are sent when the user selects a gadget that
  was created with the <link id="GACT_RELVERIFY"/> flag set.
  The <link id="TIntuiMessage">IAddress</link> field will contain a pointer to the selected gadget.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_REQSET">
<short>IDCMP class: Recive message when a requester opens</short>
<descr> With this flag set, the program will receive a message whenever a
    requester opens in its window.  The application will receive one
    <i>IDCMP_REQSET</i> event for each requester opened in the window.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_MENUPICK">
<short>IDCMP class: User opened the menu</short>
<descr>This flag indicates that the user has pressed the menu button.  If a
    menu item was selected, the menu number of the menu item can be found
    in the <link id="TIntuiMessage">Code</link> field.  If no item was selected, the
    <link id="TIntuiMessage">Code</link> field will be equal to <link id="MENUNULL"/>.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_CLOSEWINDOW">
<short>IDCMP class: User pressed close button of window</short>
<descr>
  <i>IDCMP_CLOSEWINDOW</i> messages are sent when the user selects the
  window's close gadget.  Intuition does not close the window when the
  close gadget is selected.  Rather, an <i>IDCMP_CLOSEWINDOW</i> message is
  sent to the window's IDCMP.  It is up to the application to clean up
  and close the window itself.  If closing a window means losing some
  data (perhaps the spreadsheet the user was working on), it would be
  appropriate for the application to first confirm that the user really
  meant to close the window.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_RAWKEY">
<short>IDCMP class: Raw keycodes from keyboard</short>
<descr>
<p><i>IDCMP_RAWKEY</i> messages give the raw keycodes from the keyboard. The
    numeric value of the keycode is sent in the <link id="TIntuiMessage">Code</link> field. Separate
    codes are returned for key down and key up.  Qualifier codes, such as
    Shift or Alt and whether this key is a repeat, may be found in the
    <link id="TIntuiMessage">Qualifier</link> field of the message.</p>
<p>
    In general, the application should not assume any correspondence
    between the keycode and the key value.  Character positions on the
    keyboard change from country to country, and the application should
    respect the keymap set by the user.</p>
<p>
    Programs using <i>IDCMP_RAWKEY</i> messages should perform their own key
    mapping by calling the console.device function RawKeyConvert(), or
    the keymap.library function <link id="keymap.MapRawKey">MapRawKey()</link>.
    (The latter is a bit more convenient). The Autodoc
    for the <link id="keymap.MapRawKey">MapRawKey()</link> function shows how you can process so-called dead
    keys.  A dead key is a key combination that has no immediate effect,
    but instead modifies a subsequent keystroke.  For example, on the
    default keymap, Alt-F is a dead key for the acute accent mark.  The
    sequence of Alt-F followed by the E key yields an é with an acute
    accent.</p>
<p>
    The application can assume that certain keys will always return the
    same raw keycode, these keys do not have to be mapped.  In general
    these keys are in the high part of the keymap, above $40, and
    includes all non-alphanumeric keys.  The fixed keys include the
    function keys, backspace, delete, help and cursor keys.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_REQVERIFY">
<short>IDCMP class: Verify intuition is ready to render a requester</short>
<descr>
<p>Set this flag to allow the application to ensure it is prepared for
    Intuition to render a requester in the window.  With this flag set,
    Intuition sends the application a message that a requester is
    pending, and then waits for the application to reply before drawing
    the requester in the window.</p>
<p>
    If several requesters open in the window, Intuition asks the
    application to verify only the first one.  After that, Intuition
    assumes that all output is being held off until all the requesters
    are gone.</p>
<p>
    By setting the <link id="IDCMP_REQSET"/> and <link id="IDCMP_REQCLEAR"/> flags, the application
    can track how many requesters are open in the window and when the
    last requester is cleared.  Once all of the requesters are cleared
    from the window, it is safe to write to the window until another
    <i>IDCMP_REQVERIFY</i> is received.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_REQCLEAR">
<short>IDCMP class: Requester is cleared</short>
<descr>
Intuition sends an <i>IDCMP_REQCLEAR</i> message to the window each time a
requester is cleared from that window.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_MENUVERIFY">
<short>IDCMP class: Verify ready to show menu</short>
<descr>
<p>This is a special verification mode which allows the program to
    confirm that it is prepared to handle Intuition rendering, in this
    case, allowing menus to be drawn in the screen.</p>
<p>
    This is a special kind of verification, in that any window in the
    entire screen that has this flag set must respond before the menu
    operations may proceed.  Also, the active window of the screen is
    allowed to cancel the menu operation.  This is unique to
    <i>IDCMP_MENUVERIFY</i>.  Refer to the "Intuition Menus" for a complete
    description.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_NEWPREFS">
<short>IDCMP class: Preferences are changed</short>
<descr>
<p><i>IDCMP_NEWPREFS</i> messages are sent when the system Preferences are
    changed by a call to <link id="SetPrefs">SetPrefs()</link>.  The program can learn of these
    changes by setting this flag.</p>
<p>
    After receiving a message of class <i>IDCMP_NEWPREFS</i>, the application
    should call <link id="GetPrefs">GetPrefs()</link> to obtain a copy of the new Preferences.</p>
<p>
    Under the new Preferences scheme used an <i>IDCMP_NEWPREFS</i> message
    will not always be sent when the
    user changes a Preferences setting. Only Preferences values
    that can be modified by a call to  <link id="SetPrefs">SetPrefs()</link>, will cause an
    <i>IDCMP_NEWPREFS</i> message to be sent.  New
    Preferences items such as overscan or font settings rely on
    filesystem notification for monitoring changes.</p>
<p>
    This message type is broadcast to all IDCMP that have this flag set,
    not just to the active window.  If the application has this flag set,
    it should be prepared to handle the event even if it is not active.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_DISKINSERTED">
<short>IDCMP class: Floppy disk inserted</short>
<descr>
  When the user inserts a floppy disk from any drive,
  Intuition will send one of these message types.

  This message type is broadcast to all IDCMP that have this flag set,
  not just to the active window.  If the application has this flag set,
  it should be prepared to handle the event even if it is not active.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_DISKREMOVED">
<short>IDCMP class: Floppy disk removed</short>
<descr>
  When the user removes a floppy disk from any drive,
  Intuition will send one of these message types.

  This message type is broadcast to all IDCMP that have this flag set,
  not just to the active window.  If the application has this flag set,
  it should be prepared to handle the event even if it is not active.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_WBENCHMESSAGE">
<short>IDCMP class: private</short>
<descr>Special messages for Workbench, system use only.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_ACTIVEWINDOW">
<short>IDCMP class: Window is activated</short>
<descr>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_INACTIVEWINDOW">
<short>IDCMP class: Window is deactivated</short>
<descr>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_DELTAMOVE">
<short>IDCMP class:</short>
<descr>
<p><i>IDCMP_DELTAMOVE</i> is not a message type, and events will never be sent
    to the application with this IDCMP identifier.  This flag is a
    modifier, which changes how mouse movements are reported.  When this
    flag is set, mouse movements are sent as delta values rather than as
    absolute positions.</p>
<p>
    The deltas are the amount of change of the mouse position from the
    last reported position.  If the mouse does not move, then the delta
    values will be zero.</p>
<p>
    This flag works in conjunction with the <link id="IDCMP_MOUSEMOVE"/> flag.  When
    <i>IDCMP_DELTAMOVE</i> is set, <link id="IDCMP_MOUSEBUTTONS"/> messages will also have
    relative values, instead of the absolute window position of the mouse.</p>
<p>
    Delta mouse movements are reported even after the Intuition pointer
    has reached the limits of the display.  That is, if the pointer has
    reached the edge of the display and the user continues to move the
    mouse in the same direction, the <link id="IDCMP_MOUSEMOVE"/> messages will
    continue to report changes in the mouse position even though the
    pointer is no longer moving.
</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_VANILLAKEY">
<short>IDCMP class: keyboard events</short>
<descr>
<p><i>IDCMP_VANILLAKEY</i> messages return keyboard events translated into the
    current default character keymap. The mapped character value is
    returned in the <link id="TIntuiMessage">Code</link> field.</p>
<p>
    An <i>IDCMP_VANILLAKEY</i> message is sent only if the translation results
    in a single byte value, therefore the program cannot read the Help or
    function keys using <i>IDCMP_VANILLAKEY</i>.</p>
<p>
    Programs using <i>IDCMP_VANILLAKEY</i> which also require
    the additional information of special keys, such as the Help key and
    the function keys, may set both <i>IDCMP_VANILLAKEY</i> and <link id="IDCMP_RAWKEY"/>.
    When this combination is used, all keypresses that map to single
    character values will be returned as <i>IDCMP_VANILLAKEY</i> events; all
    other keyboard events will be sent as <link id="IDCMP_RAWKEY"/> messages.  Note
    that <i>IDCMP_VANILLAKEY</i> processing uses all of the key-up events, so
    the application will only receive key-down events in the <link id="IDCMP_RAWKEY"/>
    format.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_INTUITICKS">
<short>IDCMP Class: Time ticks</short>
<descr>
<p>Intuition sends these messages to the active window based on an
    internal timer which "ticks" roughly ten times a second. This
    provides the application with simple timer events from Intuition.</p>
<p>
    Intuition does not allow <i>IDCMP_INTUITICKS</i> events to accumulate at a
    port.  After an <i>IDCMP_INTUITICKS</i> message has been sent to a port,
    Intuition will not send another until the application replies to the
    first.  This means that an application that has not been able to
    service the IDCMP for an extended period can expect at most one
    <i>IDCMP_INTUITICKS</i> message to be waiting at the port.</p>
<p>
    These events are to be used as "prods", and not as time counters.  Do
    not rely on the timing accuracy of the event, or on the exact
    frequency at which they appear.  Remember, <i>IDCMP_INTUITICKS</i> will only
    be sent to the active window.  If the user selects another window,
    the events will no longer be received at the first window.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_IDCMPUPDATE">
<short>IDCMP Class: gadget notification</short>
<descr>
  Used for notification from Boopsi custom gadgets. The <link id="TIntuiMessage">IAddress</link> field contains a pointer
  to a tag item list.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_MENUHELP">
<short>IDCMP Class: Help key pressed</short>
<descr>
<p>This message is sent by Intuition when the user selects the Help key
    while the menu system is activated.  If a menu item was selected, the
    menu number of the menu item can be found in the <link id="TIntuiMessage">Code</link> field.
    If no item was selected, the <link id="TIntuiMessage">Code</link> field will be equal
    to <link id="MENUNULL"/>.</p>
<p>
    These messages will only be sent if the <link id="WA_MenuHelp"/> attribute is set
    for the window.</p>
<p>
    The menu number returned in <i>IDCMP_MENUHELP</i> may specify a position
    that cannot be generated through normal menu activity.  For instance,
    the menu number may indicate one of the menu headers with no item or
    sub-item.</p>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_CHANGEWINDOW">
<short>IDCMP class: Window changed size or position</short>
<descr>
This message provides the window with notification of any change in
    the size or position of a window.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_GADGETHELP">
<short>IDCMP class</short>
<descr>
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDCMP_LONELYMESSAGE">
<short>IDCMP class: Private</short>
<descr>For internal tracking by Intuition, system use only.
</descr>
<seealso>
<link id="TIntuiMessage"/>
<link id="TWindow"/>
<link id="TNewWindow"/>
<link id="TExtNewWindow"/>
<link id="WA_IDCMP"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CWCODE_MOVESIZE">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_CHANGEWINDOW"/> Window was moved and/or sized</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CWCODE_DEPTH">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_CHANGEWINDOW"/> Window was depth-arranged</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUHOT">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_MENUVERIFY"/> Intuition wants verification or <link id="MENUCANCEL"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUCANCEL">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_MENUVERIFY"/> HOT Reply of this cancels Menu operation</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUWAITING">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_MENUVERIFY"/> Intuition simply wants a <link id="Exec.ReplyMsg">ReplyMsg()</link> ASAP</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OKOK">
<short>Internal token to represent state of verification attempts shown here as a clue. guy didn't care</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OKABORT">
<short>Internal token to represent state of verification attempts shown here as a clue. window rendered question moot</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OKCANCEL">
<short>Internal token to represent state of verification attempts shown here as a clue. window sent cancel reply</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WBENCHOPEN">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_WBENCHMESSAGE"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WBENCHCLOSE">
<short><link id="TIntuiMessage">Code</link> for <link id="IDCMP_WBENCHMESSAGE"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PNewWindow">
<short>Pointer to structure describes a new window</short>
<descr>
</descr>
<seealso>
<link id="OpenWindow"/>
<link id="OpenWindowTagList"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TNewWindow">
<short>New window structure</short>
<descr>
</descr>
<seealso>
<link id="OpenWindow"/>
<link id="OpenWindowTagList"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.LeftEdge">
<short>Left edge of window</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.TopEdge">
<short>Top edge of window</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.Width">
<short>Width of window</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.Height">
<short>Height of window</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.DetailPen">
<short>For bar/border/gadget rendering </short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.BlockPen">
<short>For bar/border/gadget rendering </short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.IDCMPFlags">
<short>User-selected IDCMP flags (IDCMP_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.Flags">
<short>Window Flags (WFLG_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.FirstGadget">
<short>You supply a linked-list of Gadgets for your Window. This list <b>does not</b> include system Gadgets.</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.CheckMark">
<short>A Pointer to the imagery that will be used when rendering MenuItems of this Window that want to be checkmarked
if this is equal to nil, you'll get the default imagery</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.Title">
<short>The title text for this window</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.Screen">
<short>Only if you've defined a CUSTOMSCREEN and
want this Window to open in it.  If so, you pass the Pointer of the
Custom Screen structure in this variable.  Otherwise, this variable
is ignored and doesn't have to be initialized.</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.BitMap">
<short>SUPER_BITMAP Window?  If so, put the Pointer of your BitMap structure
in this variable.  If not, this variable is ignored and doesn't have to be initialized</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.MinWidth">
<short>Minimum / maximum size of your window, only if <link id="WFLG_SIZEGADGET"/> is set,</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.MinHeight">
<short>if MinWidth/Height = 0 then its set to the opening size.</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.MaxWidth">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.MaxHeight">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TNewWindow.WType">
<short>Describes the Screen in which you want this Window to
open.  The type value can either be <link id="CUSTOMSCREEN_f"/> or one of the
system standard Screen Types such as <link id="WBENCHSCREEN_f"/>.  See the
type definitions under the Screen structure</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtNewWindow">
<short>Pointer to Future <link id="TNewWindow"/>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExtNewWindow">
<short>Future <link id="TNewWindow"/></short>
<descr>
  Compatibility issues require that the size of NewWindow not change.
  Data in the common part (NewWindow) indicates the the extension
  fields are being used.
  NOTE WELL: This structure may be subject to future extension.
  Writing code depending on its size is not allowed.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.LeftEdge">
<short>see <link id="TNewWindow"/> for the field explanations</short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.TopEdge">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.Height">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.DetailPen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.BlockPen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.IDCMPFlags">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.Flags">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.FirstGadget">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.CheckMark">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.Title">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.WScreen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.WBitMap">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.MinWidth">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.MinHeight">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.MaxWidth">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.MaxHeight">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.WType">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewWindow.Extension">
<short>
  If the <link id="TNewWindow">Flags</link> value <link id="WFLG_NW_EXTENDED"/> is set, then
  this field is assumed to point to an array ( or chain of arrays)
  of TagItem structures.  See also <link id="TExtNewScreen"/> for another
  use of TagItems to pass optional data.</short>
</element>

<!-- constant Visibility: default -->
<element name="WA_Dummy">
<short>Starting for window TagItems</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Left">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. The initial x position</short>
<descr><p>
  Describe where the window will first appear on the screen and how
  large it will be initially. These dimensions are relative to the top
  left corner of the screen, which has the coordinates (0,0).</p>
<p>  <i>WA_Left</i> is the initial x position, or offset, from the left edge of
    the screen.  The leftmost pixel is pixel 0, and values increase to
    the right. Equivalent to <link id="TNewWindow"/>.LeftEdge.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Top">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. The initial y position</short>
<descr><p>
  Describe where the window will first appear on the screen and how
  large it will be initially. These dimensions are relative to the top
  left corner of the screen, which has the coordinates (0,0).</p>
<p><i>WA_Top</i> is the initial y position, or offset, from the top edge of the
    screen.  The topmost pixel is pixel 0, and values increase to the
    bottom.  Equivalent to <link id="TNewWindow"/>.TopEdge.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Width">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. The initial window width in pixels</short>
<descr>
Equivalent to <link id="TNewWindow"/>.Width
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Height">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. The initial window height in pixels</short>
<descr>
Equivalent to <link id="TNewWindow"/>.Height
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_DetailPen">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Specifies the pen number for the rendering of window details like gadgets or text in the title bar.</short>
<descr>
  Equivalent to <link id="TNewWindow"/>.DetailPen
  The specific color associated with each pen number depends on the
  screen.  Specifying -1 for these values sets the window's detail and
  block pen the same as the screen's detail and block pen.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_BlockPen">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Specifies the pen number for window block fills, like the title bar.</short>
<descr>
  Equivalent to <link id="TNewWindow"/>.BlockPen
  The specific color associated with each pen number depends on the
  screen.  Specifying -1 for these values sets the window's detail and
  block pen the same as the screen's detail and block pen.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_IDCMP">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Which events should be reported</short>
<descr><p>IDCMP flags tell Intuition what user input events the application
    wants to be notified about. (see IDCMP_*) Equivalent to
    <link id="TNewWindow"/>.IDCMPFlags</p>
<p>
    If any of these flags are set, Intuition creates a pair of message
    ports for the window (one internal to Intuition and one used by the
    application). These ports are for handling messages about user input
    events.  If <i>WA_IDCMP</i> is nil or unspecified, no IDCMP is created for
    this window.</p>
<p>
    The <link id="ModifyIDCMP">ModifyIDCMP()</link> function can be used to change the window's IDCMP
    flags after it is open.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Flags">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Window Flags (WFLG_*)</short>
<descr>Multiple initialization of window flags, equivalent to
    <link id="TNewWindow"/>.Flags. Use the WFLG_* constants to initialize this field,
    multiple bits may be set by ORing the values together.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Gadgets">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. List of Gadgets</short>
<descr>A pointer to the first in the linked list of Gadget structures that
    are to be included in this window.  These gadgets are application
    gadgets, not system gadgets. Equivalent to
    <link id="TNewWindow"/>.FirstGadget
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Checkmark">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Image for Menu entries</short>
<descr>
A pointer to an Image structure, which is to be used as the checkmark
    image in this window's menus.  To use the default checkmark, do not
    specify this tag or set this field to nil. Equivalent to
    <link id="TNewWindow"/>.CheckMark
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Title">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Title for window</short>
<descr>
<p>A pointer to a #0 terminated text string, which is used as the
    window title and is displayed in the window's title bar.</p>
<p>
    Intuition draws the text using the colors defined in the DrawInfo pen
    array (<link id="TDrawInfo">TDrawInfo.dri_Pens</link>) and displays as much as possible of the
    window title, depending upon the current width of the title bar.</p>
<p>
    The title is rendered in the screen's default font.</p>
<p>
    A title bar is added to the window if any of the properties
    <link id="WA_DragBar"/> (<link id="WFLG_DRAGBAR"/>), <link id="WA_DepthGadget"/> (<link id="WFLG_DEPTHGADGET"/>),
    <link id="WA_CloseGadget"/> (<link id="WFLG_CLOSEGADGET"/>) or <link id="WA_Zoom"/> are specified, or if
    text is specified for a window title.  If no text is provided for the
    title, but one or more of these system gadgets are specified, the
    title bar will be blank.  Equivalent to <link id="TNewWindow"/>.Title.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_ScreenTitle">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Title for screen when window is activated</short>
<descr>
  A pointer to a #0 terminated text string, which is used as the
  screen title and is displayed, when the window is active, in the
  screen's title bar.  After the screen has been opened the screen's
  title may be changed by calling <link id="SetWindowTitles">SetWindowTitles()</link>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_CustomScreen">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Open the window on a specific screen</short>
<descr>
  A pointer to the Screen structure of a screen created by this
  application.  The window will be opened on this screen.  The custom
  screen must already be opened when the <link id="OpenWindowTagList">OpenWindowTagList()</link> call is
  made.  Equivalent to NewWindow.Screen, also implies <link id="TNewWindow"/>.Type of <link id="CUSTOMSCREEN_f"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_SuperBitMap">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. SuperBitmap for scrolling windows</short>
<descr>This is a pointer to a BitMap structure for a SuperBitMap window. The
    application will be allocating and maintaining its own bitmap.
    Equivalent to <link id="TNewWindow"/>.BitMap.  Setting this tag implies the
    <link id="WFLG_SUPER_BITMAP"/> property.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_MinWidth">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Minimum width for resizeable windows</short>
<descr><p>
  This tag set the minimum value to which the user may
  size the window.  If the flag <link id="WFLG_SIZEGADGET"/> is not set, then
  these variables are ignored.</p>
<p>
  Setting this variable to 0, will take the setting for that
  dimension from its initial value.</p>
<p>
  Equivalent to <link id="TNewWindow"/>.MinWidth Use the <link id="WindowLimits">WindowLimits()</link>
  function to change window size limits after the window is opened.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_MinHeight">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Minimum height for resizeable windows</short>
<descr>
<p>
  This tag set the minimum value to which the user may
  size the window.  If the flag <link id="WFLG_SIZEGADGET"/> is not set, then
  these variables are ignored.</p>
<p>
  Setting this variable to 0, will take the setting for that
  dimension from its initial value.</p>
<p>
  Equivalent to <link id="TNewWindow"/>.MinHeight Use the <link id="WindowLimits">WindowLimits()</link>
  function to change window size limits after the window is opened.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_MaxWidth">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Maximum width for resizeable windows</short>
<descr>
<p>
  This tag set the minimum value to which the user may
  size the window.  If the flag <link id="WFLG_SIZEGADGET"/> is not set, then
  these variables are ignored.  Values are measured in pixels.  Use
  -1 for this value to allow for a window as wide
  as the screen.  This is the complete screen, not the visible
  part or display clip.</p>
<p>
  Setting this variable to 0, will take the setting for that
  dimension from its initial value.</p>
<p>
  Equivalent to <link id="TNewWindow"/>.MaxWidth Use the <link id="WindowLimits">WindowLimits()</link>
  function to change window size limits after the window is opened.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_MaxHeight">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Minimum height for resizeable windows</short>
<descr>
<p>
  This tag set the minimum value to which the user may
  size the window.  If the flag <link id="WFLG_SIZEGADGET"/> is not set, then
  these variables are ignored.  Values are measured in pixels.  Use
  -1 for this value to allow for a window as tall as the screen.
  This is the complete screen, not the visible part or display clip.</p>
<p>
  Setting this variable to 0, will take the setting for that
  dimension from its initial value.</p>
<p>
  Equivalent to <link id="TNewWindow"/>.MaxHeight Use the <link id="WindowLimits">WindowLimits()</link>
  function to change window size limits after the window is opened.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_InnerWidth">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Inner width for the window</short>
<descr><p>Specify the dimensions of the interior region of the window, i.e.,
    inside the border, independent of the border widths.  When using
    this flag an application will probably want to
    set <link id="WA_AutoAdjust"/>.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_InnerHeight">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Inner height of window</short>
<descr><p>Specify the dimensions of the interior region of the window, i.e.,
    inside the border, independent of the border widths. When using
    this flag an application will probably want to
    set <link id="WA_AutoAdjust"/>.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_PubScreenName">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Choose screen by name</short>
<descr><p>Declares that the window is to be opened as a visitor on the public
    screen whose name is pointed to by the ti_Data field of the
    <i>WA_PubScreenName</i> TagItem. The <link id="OpenWindowTagList">OpenWindowTagList()</link> call will fail if
    it cannot obtain a lock on the named public screen and no fall back
    name (<link id="WA_PubScreenFallBack"/>) is specified.  Setting this tag implies
    screen type of <link id="PUBLICSCREEN_f"/>.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_PubScreen">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Specify screen to open window on</short>
<descr><p>Open the window as a visitor window on the public screen whose
    address is in the <link id="utility.TTagitem">ti_Data</link> field of the <i>WA_PubScreen</i> TagItem.  To
    ensure that this screen remains open until <link id="OpenWindowTagList">OpenWindowTagList()</link> has
    completed, the application must either be the screen's owner, have a
    window open on the screen, or use <link id="LockPubScreen">LockPubScreen()</link>.  Setting this tag
    implies screen type of <link id="PUBLICSCREEN_f"/>.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_PubScreenFallBack">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Fallback screen to default</short>
<descr>A Boolean, specifies whether a visitor window should "fall back" to
    the default public screen (or Workbench) if the named public screen
    isn't available This tag is only meaningful when used in conjunction
    with <link id="WA_PubScreenName"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_WindowName">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Colors">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>
  A ColorSpec array for colors to be set when this window is active.
  <b>This is not implemented</b>, and may not be, since the default
  values to restore would be hard to track. We'd like to at least
  support per-window colors for the mouse pointer sprite.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Zoom">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Define zoom size for window</short>
<descr><p>
    Pointer to an array of four SmallInts, the initial LeftEdge, TopEdge,
    Width and Height values for the alternate zoom position and size.  It
    also specifies that the application wants a zoom gadget for the
    window, whether or not it has a sizing gadget.</p>
<p>
    A zoom gadget is always supplied to a window if it has both depth and
    sizing gadgets.  This tag allows the application to open a window
    with a zoom gadget when the window does not have both the depth and
    sizing gadgets.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_MouseQueue">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Mouse event queue size</short>
<descr>An initial value for the mouse message backlog limit for this window.
    The <link id="SetMouseQueue">SetMouseQueue()</link> function will change this limit after the window
    is opened.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_BackFill">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. BackFill hook</short>
<descr>Provides a "backfill hook" for your window's layer.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_RptQueue">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Key event queue size</short>
<descr>An initial value of repeat key backlog limit for this window.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_SizeGadget">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>
  Specifying this flag tells Intuition to add a sizing gadget to the
  window.  Intuition places the sizing gadget in the lower right corner
  of the window.  By default, the right border is adjusted to
  accommodate the sizing gadget, but the application can specify one of
  the following two flags to change this behavior.  The <link id="WFLG_SIZEBRIGHT"/>
  flag puts the sizing gadget in the right border.  The
  <link id="WFLG_SIZEBBOTTOM"/> flag puts the sizing gadget in the bottom border.
  Both flags may be specified, placing the gadget in both borders.
  Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_SIZEGADGET"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_DragBar">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Titlebar used to drag window</short>
<descr>This flag turns the entire title bar of the window into a drag
    gadget, allowing the user to position the window by clicking in the
    title bar and dragging the mouse.  Equivalent to <link id="TNewWindow"/>.Flags with set
    <link id="WFLG_DRAGBAR"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_DepthGadget">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Add Depthgadget to window</short>
<descr>Setting this flag adds a depth gadget to the window.  This allows the
    user to change the window's depth arrangement with respect to other
    windows on the screen.  Intuition places the depth gadget in the
    upper right corner of the window.  Equivalent to <link id="TNewWindow"/>.Flags with set
    <link id="WFLG_DEPTHGADGET"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_CloseGadget">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Add CloseGadget to window</short>
<descr>
Setting this flag attaches a close gadget to the window.  When the
    user selects this gadget, Intuition transmits a message to the
    application.  It is up to the application to close the window with a
    CloseWindow() call. Intuition places the close gadget in the upper
    left corner of the window. Equivalent to <link id="TNewWindow"/>.Flags with set
    <link id="WFLG_CLOSEGADGET"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Backdrop">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Make this window a backdrop window</short>
<descr>Make this window a Backdrop window. Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_BACKDROP"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_ReportMouse">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Report mouse events</short>
<descr><p>
    Send mouse movement events to the window as x,y coordinates. Also
    see the description of the IDCMP flag <link id="IDCMP_MOUSEMOVE"/>.
    Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_REPORTMOUSE"/>.</p>
<p>
    The <i>WFLG_REPORTMOUSE</i> flag in the Flags field of the Window structure
    may be modified on the fly  by the program.  Changing this flag must
    be done as an atomic operation. If you are unsure of getting an
    atomic operation from your compiler, you may wish to do this
    operation in assembler, or bracket the code with a <link id="exec.Forbid">Forbid()</link>/<link id="exec.Permit">Permit()</link>
    pair.</p>
<p>
    The use of the <link id="ReportMouse">ReportMouse()</link> function is strongly discouraged, due to
    historic confusion over the parameter ordering.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_NoCareRefresh">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Do not need Refresh message</short>
<descr>
  This window does not want <link id="IDCMP_REFRESHWINDOW"/> events.  Set this flag
  to prevent the window from receiving refresh window messages.
  Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_NOCAREREFRESH"/>. Intuition will
  manage <link id="BeginRefresh">BeginRefresh()</link> and <link id="EndRefresh">EndRefresh()</link> internally.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Borderless">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Make window borderless</short>
<descr>
<p>Open a window with no borders rendered by Intuition. Equivalent to
   <link id="TNewWindow"/>.Flags with set <link id="WFLG_BORDERLESS"/>.</p>
<p>
  Use caution setting this flag, as it may cause visual confusion on
  the screen.  Also, some borders may be rendered if any of the system
  gadgets are requested, if text is supplied for the window's title
  bar, or if any of application gadgets are in the borders.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Activate">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Activate the window when it opens.</short>
<descr>Activate the window when it opens.  Equivalent to <link id="TNewWindow"/>.Flags with set
  <link id="WFLG_ACTIVATE"/>. Use this flag carefully, as it can change where the user's input is going.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_RMBTrap">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>
<p>Catch right mouse button events for application use.  Set this flag
  to disable menu operations for the window.  When set, right mouse
  button events will be received as <link id="IDCMP_MOUSEBUTTONS"/> with the <link id="MENUUP"/>
  and <link id="MENUDOWN"/> qualifiers.  Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_RMBTRAP"/>.</p>
<p>
  The <link id="WFLG_RMBTRAP"/> flag in the Window structure Flags field may be
  modified on the fly by the program.  Changing this flag must be done
  as an atomic operation, as Intuition can preempt a multistep set or
  clear operation.  An atomic operation can be done in assembler, using
  instructions that operate directly on memory.  If you are
  unsure of generating such an instruction, place the operation within
  a <link id="exec.Forbid">Forbid()</link>/<link id="exec.Permit">Permit()</link> pair.  This will ensure proper operation by
  disabling multitasking while the flag is being changed.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_WBenchWindow">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Private</short>
<descr>Private tag
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_SimpleRefresh">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>The application program takes complete responsibility for updating
    the window.  Only specify if True.  Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_SIMPLE_REFRESH"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_SmartRefresh">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>
<p>
  Intuition handles all window updating, except for parts of the window
  revealed when the window is sized larger.  Only specify if True.
  Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_SMART_REFRESH"/>.</p>
<p>
  <i>WA_SmartRefresh</i> windows without a sizing gadget will never receive
  refresh events due to the user sizing the window.  However, if the
  application sizes the window through a call like <link id="ChangeWindowBox">ChangeWindowBox()</link>,
  <link id="ZipWindow">ZipWindow()</link> or <link id="SizeWindow">SizeWindow()</link>, a refresh event may be generated.  Use
  <link id="WA_NoCareRefresh"/> to disable refresh events.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_SizeBRight">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Place the size gadget in the right border.</short>
<descr>Place the size gadget in the right border.  Equivalent to
    <link id="TNewWindow"/>.Flags with set <link id="WFLG_SIZEBRIGHT"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_SizeBBottom">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Place the size gadget in the bottom border.</short>
<descr>Place the size gadget in the bottom border.  Equivalent to
    <link id="TNewWindow"/>.Flags with set <link id="WFLG_SIZEBBOTTOM"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_AutoAdjust">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>.Auto adjust window size to screen maximum.</short>
<descr>Allow Intuition to change the window's position and dimensions in
    order to fit it on screen.  The window's position is adjusted first,
    then the size. This property may be especially important when using
    <link id="WA_InnerWidth"/> and <link id="WA_InnerHeight"/> as border size depends on a user
    specified font.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_GimmeZeroZero">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Zero-Zero window</short>
<descr>
  Set this tag to create a GimmeZeroZero window. GimmeZeroZero windows
  have the window border and border gadgets rendered into an extra
  layer. This extra layer slows down window operations, thus it is
  recommended that applications only use GimmeZeroZero windows when
  they are required. For clipping graphics to the area within the
  borders of a window. Equivalent to <link id="TNewWindow"/>.Flags with set <link id="WFLG_GIMMEZEROZERO"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_MenuHelp">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Enabled Help button for Menu</short>
<descr>Enables <link id="IDCMP_MENUHELP"/>: pressing Help during menus will return
    <link id="IDCMP_MENUHELP"/> message.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_NewLookMenus">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Activate NewLook menus</short>
<descr>Set to True if you want NewLook menus.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_AmigaKey">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Amiga key image for Menus</short>
<descr>Pointer to image for Amiga-key equiv in menus
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_NotifyDepth">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. </short>
<descr>Requests <link id="IDCMP_CHANGEWINDOW"/> message when window is depth arranged (<link id="TIntuiMessage">imsg^.Code</link> = <link id="CWCODE_DEPTH"/>)
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_Pointer">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Custom Pointer for window.</short>
<descr>Allows you to specify a custom pointer for your window. <link id="utility.TTagItem">ti_Data</link> points to a pointer object you obtained via
"pointerclass". Nil signifies the default pointer. This tag may be passed to <link id="OpenWindowTagList">OpenWindowTagList()</link> or <link id="SetWindowPointerA">SetWindowPointerA()</link>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_BusyPointer">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Request standard busy pointer</short>
<descr><link id="utility.TTagItem">ti_Data</link> is a boolean.  Set to True to request the standard busy pointer. This tag may be passed to <link id="OpenWindowTagList">OpenWindowTagList()</link> or <link id="SetWindowPointerA">SetWindowPointerA()</link>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_PointerDelay">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Delay of pointer change</short>
<descr><link id="utility.TTagItem">ti_Data</link> is a boolean.  Set to True to request that the changing of the pointer be slightly delayed.  The change
  will be called off if you call <link id="SetPointer">SetPointer()</link> before the delay expires.
  This allows you to post a busy-pointer even if you think the busy-time may be very short, without fear of a flashing pointer.
  This tag may be passed to <link id="OpenWindowTagList">OpenWindowTagList()</link> or <link id="SetWindowPointerA">SetWindowPointerA()</link>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_TabletMessages">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Enabled tablet messages </short>
<descr><link id="utility.TTagItem">ti_Data</link> is a boolean. Set to True to request that tablet information be included in <link id="TIntuiMessage"/> sent to your window.
  For a pointer to the TabletData, examine the <link id="TExtIntuiMessage">ExtIntuiMessage^.eim_TabletData</link> field.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_HelpGroup">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Form Help groups</short>
<descr>
  When the active window has gadget help enabled, other windows of the same HelpGroup number will also get GadgetHelp.  This allows GadgetHelp
  to work for multi-windowed applications. Pass the ID as <link id="utility.TTagItem">ti_Data</link> to all your windows.
</descr>
<seealso>
<link id="HelpControl"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WA_HelpGroupWindow">
<short>Tag for <link id="OpenWindowTagList">OpenWindowTagList()</link>. Form Help group windows</short>
<descr>
  When the active window has gadget help enabled, other windows of the same HelpGroup will also get GadgetHelp.  This allows GadgetHelp to work
  for multi-windowed applications.  As an alternative to <link id="WA_HelpGroup"/>, you can pass a pointer to any other window of the same group to join its help
  group.  Defaults to nil, which has no effect.
</descr>
<seealso>
<link id="HelpControl"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_SIZEGADGET">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Include sizing system-gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_DRAGBAR">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Include dragging system-gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_DEPTHGADGET">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Include depth arrangement gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_CLOSEGADGET">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Include close-box system-gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_SIZEBRIGHT">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Size gadget uses right border</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_SIZEBBOTTOM">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Size gadget uses bottom border</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_SMART_REFRESH">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Enable smart Refresh</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_SIMPLE_REFRESH">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Enable Simple Refresh</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_SUPER_BITMAP">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Has super bitmap</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_OTHER_REFRESH">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Simple refresh and super bitmap</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_REFRESHBITS">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Simple refresh and super bitmap</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_BACKDROP">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. This is a backdrop window</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_REPORTMOUSE">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Fire an event for every mouse move</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_GIMMEZEROZERO">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. A GimmeZeroZero window</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_BORDERLESS">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Get a window sans border.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_ACTIVATE">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. When window opens, it is active.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_WINDOWACTIVE">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Private. This window is the active one.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_INREQUEST">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Private. This window is in request mode.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_MENUSTATE">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Private. Window is active with menus on.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_RMBTRAP">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Fire right mouse button events</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_NOCAREREFRESH">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Not to be bothered with REFRESH</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_NW_EXTENDED">
<short>Flag for <link id="TNewWindow"/>.Flags. Extension data provided see <link id="TExtNewWindow"/>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_NEWLOOKMENUS">
<short>Flag for <link id="WA_Flags"/> or <link id="TNewWindow"/>.Flags. Window has NewLook menus.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_WINDOWREFRESH">
<short>Flag for <link id="TWindow"/>.Flags. Window is currently refreshing</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_WBENCHWINDOW">
<short>Flag for <link id="TWindow"/>.Flags. Workbench tool <b>only</b> Window</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_WINDOWTICKED">
<short>Flag for <link id="TWindow"/>.Flags. Only one timer tick at a time</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_VISITOR">
<short>Flag for <link id="TWindow"/>.Flags. Visitor window.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_ZOOMED">
<short>Flag for <link id="TWindow"/>.Flags. Identifies "Zoom State"</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WFLG_HASZOOM">
<short>Flag for <link id="TWindow"/>.Flags. Window has a zoom gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DEFAULTMOUSEQUEUE">
<short>Window value, No more mouse messaged</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HC_GADGETHELP">
<short>Flag for <link id="HelpControl">HelpControl()</link> Set this flag to enable Gadget-Help for one or more windows.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTREL">
<short>Flag for <link id="TRequester"/>.Flags. If set TopLeft is relative to pointer to the coordinates of either the pointer or the window.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PREDRAWN">
<short>Flag for <link id="TRequester"/>.Flags. If set, ImageBMap points to a custom bitmap.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOISYREQ">
<short>Flag for <link id="TRequester"/>.Flags. Requester does not filter input.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIMPLEREQ">
<short>Flag for <link id="TRequester"/>.Flags. If set, a SIMPLEREFRESH layer is used.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="USEREQIMAGE">
<short>Flag for <link id="TRequester"/>.Flags. Render linked list ReqImage after BackFill but before gadgets and text</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NOREQBACKFILL">
<short>Flag for <link id="TRequester"/>.Flags. Don't bother filling requester with <link id="TRequester"/>.BackFill pen</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REQOFFWINDOW">
<short>Flag for <link id="TRequester"/>.Flags. Read-Only. Part of one of the Gadgets was offwindow</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="REQACTIVE">
<short>Flag for <link id="TRequester"/>.Flags. Read-Only. This requester is active</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSREQUEST">
<short>Flag for <link id="TRequester"/>.Flags. Read-Only. This requester caused by system</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DEFERREFRESH">
<short>Flag for <link id="TRequester"/>.Flags. Read-Only. This Requester stops a Refresh broadcast</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_Dummy">
<short>Tablet Tag Base</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_TabletZ">
<short>Tag for <link id="TTabletData"/>.td_TagList. The current value of the tablet in the Z direction.</short>
<descr>The current value of the tablet in the Z direction.
This unsigned value should typically be in the natural units of the tablet. You should also provide <link id="TABLETA_RangeZ"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_RangeZ">
<short>Tag for <link id="TTabletData"/>.td_TagList. The maximum value of the tablet in the Z direction.</short>
<descr>The maximum value of the tablet in the Z direction. Normally specified along with <link id="TABLETA_TabletZ"/>, this allows the
 application to scale the actual Z value across its range.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_AngleX">
<short>Tag for <link id="TTabletData"/>.td_TagList. The angle of rotation or tilt about the X-axis.</short>
<descr>The angle of rotation or tilt about the X-axis. This number should be normalized to fill a signed long LongInt.  Positive
values imply a clockwise rotation about the X-axis when viewing from +X towards the origin.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_AngleY">
<short>Tag for <link id="TTabletData"/>.td_TagList. The angle of rotation or tilt about the Y-axis.</short>
<descr>The angle of rotation or tilt about the Y-axis. This number should be normalized to fill a signed long LongInt. Positive
values imply a clockwise rotation about the Y-axis when viewing from +Y towards the origin.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_AngleZ">
<short>Tag for <link id="TTabletData"/>.td_TagList. The angle of rotation or tilt about the Z axis.</short>
<descr>The angle of rotation or tilt about the Z axis. This number should be normalized to fill a signed long LongInt. Positive
values imply a clockwise rotation about the Z-axis when viewing from +Z towards the origin.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_Pressure">
<short>Tag for <link id="TTabletData"/>.td_TagList. The pressure reading of the stylus.</short>
<descr>The pressure reading of the stylus.  The pressure should be normalized to fill a signed long LongInt.  Typical devices
won't generate negative pressure, but the possibility is not precluded. The pressure threshold which is considered to cause a button-click is
expected to be set in a Preferences program supplied by the tablet vendor.  The tablet driver would send <link id="inputevent.IECODE_LBUTTON"/>-type events as
the pressure crossed that threshold.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_ButtonBits">
<short>Tag for <link id="TTabletData"/>.td_TagList. Button States</short>
<descr><link id="utility.TTagItem">ti_Data</link> is a long LongInt whose bits are to be interpreted at the state of the first 32 buttons of the tablet.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_InProximity">
<short>Tag for <link id="TTabletData"/>.td_TagList. For tablets that support proximity,</short>
<descr><link id="utility.TTagItem">ti_Data</link> is a boolean.  For tablets that support proximity, they should send the (<link id="TABLETA_InProximity"/>, False) tag item
when the stylus is out of proximity.  One possible use we can forsee is a mouse-blanking commodity which keys off this to blank the
mouse.  When this tag is absent, the stylus is assumed to be in proximity.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_ResolutionX">
<short>Tag for <link id="TTabletData"/>.td_TagList. X-axis resolution</short>
<descr><link id="utility.TTagItem">ti_Data</link> is an unsigned long LongInt which is the x-axis resolution in dots per inch.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TABLETA_ResolutionY">
<short>Tag for <link id="TTabletData"/>.td_TagList. Y-axis resolution</short>
<descr><link id="utility.TTagItem">ti_Data</link> is an unsigned long LongInt which is the y-axis resolution in dots per inch.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PRemember">
<short>Pointer to Memory allocating remember structure</short>
<descr>
</descr>
<seealso>
<link id="AllocRemember"/>
<link id="FreeRemember"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRemember">
<short>Structure to remember memory allocations</short>
<descr>This structure is used for remembering what memory has been allocated to date by a given routine,
so that a premature abort or systematic exit can deallocate memory cleanly, easily, and completely
</descr>
<seealso>
<link id="AllocRemember"/>
<link id="FreeRemember"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TRemember.NextRemember">
<short>Next memory block in List</short>
</element>

<!-- variable Visibility: default -->
<element name="TRemember.RememberSize">
<short>Size of Memory Block</short>
</element>

<!-- variable Visibility: default -->
<element name="TRemember.Memory">
<short>Pointer to the allocated memory</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PColorSpec">
<short>Pointer to Color table entry</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TColorSpec">
<short>Color table entry</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TColorSpec.ColorIndex">
<short>-1 terminates an array of ColorSpec</short>
</element>

<!-- variable Visibility: default -->
<element name="TColorSpec.Red">
<short>Only the <b>bottom</b> 4 bits recognized</short>
</element>

<!-- variable Visibility: default -->
<element name="TColorSpec.Green">
<short>Only the <b>bottom</b> 4 bits recognized</short>
</element>

<!-- variable Visibility: default -->
<element name="TColorSpec.Blue">
<short>Only the <b>bottom</b> 4 bits recognized</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PEasyStruct">
<short>The text and setup of an easy requester</short>
<descr>
</descr>
<seealso>
<link id="BuildEasyRequestArgs"/>
<link id="EasyRequestArgs"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TEasyStruct">
<short>The text and setup of an easy requester</short>
<descr>
</descr>
<seealso>
<link id="BuildEasyRequestArgs"/>
<link id="EasyRequestArgs"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TEasyStruct.es_StructSize">
<short>should be sizeof (TEasyStruct) Note that this size may change,
if you update the includes! Do not use absolute values as the size of pointers may vary on different platforms!</short>
</element>

<!-- variable Visibility: default -->
<element name="TEasyStruct.es_Flags">
<short>should be 0 for now</short>
</element>

<!-- variable Visibility: default -->
<element name="TEasyStruct.es_Title">
<short>Title of easy requester window.  If this is nil, the title will be
    taken to be the same as the title of the reference window, if one is
    specified in the <link id="EasyRequestArgs">EasyRequestArgs()</link> call, else the title will be "System
    Request".</short>
</element>

<!-- variable Visibility: default -->
<element name="TEasyStruct.es_TextFormat">
<short>'printf' style formatting string see <link id="exec.RawDoFmt">RawDoFmt()</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TEasyStruct.es_GadgetFormat">
<short>Text of the gadgets, separated by '|' (vertical bar) support no further formating. At least one
    gadget must be specified.</short>
</element>

<!-- constant Visibility: default -->
<element name="ALERT_TYPE">
<short>Alert Type for <link id="DisplayAlert">DisplayAlert()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RECOVERY_ALERT">
<short>Alert Type for <link id="DisplayAlert">DisplayAlert()</link> the system can recover from this</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DEADEND_ALERT">
<short>Alert Type for <link id="DisplayAlert">DisplayAlert()</link> no recovery possible, this is it</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AUTOFRONTPEN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AUTOBACKPEN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AUTODRAWMODE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AUTOLEFTEDGE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AUTOTOPEDGE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SELECTDOWN">
<short>RawMouse code for <link id="TIntuiMessage"/>.Code. Left Mouse Button down.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SELECTUP">
<short>RawMouse code for <link id="TIntuiMessage"/>.Code. Left Mouse Button up.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUDOWN">
<short>RawMouse code for <link id="TIntuiMessage"/>.Code. Right Mouse Button down.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUUP">
<short>RawMouse code for <link id="TIntuiMessage"/>.Code. Right Mouse Button up.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MIDDLEDOWN">
<short>RawMouse code for <link id="TIntuiMessage"/>.Code. Middle Mouse Button down.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MIDDLEUP">
<short>RawMouse code for <link id="TIntuiMessage"/>.Code. Middle Mouse Button up.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ALTLEFT">
<short>Qualifier for <link id="TIntuiMessage"/>.Qualifier. Left Alt Key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ALTRIGHT">
<short>Qualifier for <link id="TIntuiMessage"/>.Qualifier. Right Alt Key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AMIGALEFT">
<short>Qualifier for <link id="TIntuiMessage"/>.Qualifier. Left Amiga Key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AMIGARIGHT">
<short>Qualifier for <link id="TIntuiMessage"/>.Qualifier. Right Amiga Key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AMIGAKEYS">
<short>Qualifier for <link id="TIntuiMessage"/>.Qualifier. An Amiga Key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CURSORUP">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. Cursor up key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CURSORDOWN">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. Cursor Down key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CURSORRIGHT">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. Cursor right key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CURSORLEFT">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. Cursor left key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_Q">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. 'q' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_X">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. 'x' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_V">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. 'v' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_B">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. 'b' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_N">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. 'n' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_M">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. 'm' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_LESS">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. '&lt;' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="KEYCODE_GREATER">
<short>RawKeycode for <link id="TIntuiMessage"/>.Code. '&gt;' key pressed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIRESPICK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOWRESPICK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DMODECOUNT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIRESGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOWRESGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RESCOUNT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UPFRONTGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOWNBACKGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIZEGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CLOSEGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DRAGGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SUPFRONTGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SDOWNBACKGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SDRAGGADGET">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GADGETCOUNT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EVENTMAX">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PDrawInfo">
<short>Pointer to Draw info structure</short>
<descr>
</descr>
<seealso>
<link id="TGadgetInfo"/>
<link id="GA_DrawInfo"/>
<link id="TimpFrameBox"/>
<link id="TimpDraw"/>
<link id="DrawImageState"/>
<link id="FreeScreenDrawInfo"/>
<link id="GetScreenDrawInfo"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TDrawInfo">
<short>Graphical informations for the 3D look</short>
<descr>The DrawInfo structure
provides information Intuition uses to support the 3D look and specifies graphical
information for applications that use the
screen.  The information includes such items as aspect ratio (resolution),
font, number of colors and drawing pens.
</descr>
<seealso>
<link id="TGadgetInfo"/>
<link id="GA_DrawInfo"/>
<link id="TimpFrameBox"/>
<link id="TimpDraw"/>
<link id="DrawImageState"/>
<link id="FreeScreenDrawInfo"/>
<link id="GetScreenDrawInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Version">
<short>Version of the structure, will be <link id="DRI_VERSION"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_NumPens">
<short>Guaranteed to be >= numDrIPens </short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Pens">
<short>pointer to pen array</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Font">
<short>Screen default font</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Depth">
<short>(initial) depth of screen bitmap</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.y">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Resolution">
<short>from DisplayInfo database for initial display mode</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Flags">
<short>Draw Flags (DIRF_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_CheckMark">
<short>pointer to scaled checkmark image Will be nil if <link id="DRI_VERSION"/> &lt; 2</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_AmigaKey">
<short>pointer to scaled Amiga-key image Will be nil if <link id="DRI_VERSION"/> &lt; 2</short>
</element>

<!-- variable Visibility: default -->
<element name="TDrawInfo.dri_Reserved">
<short>Place for future extensions</short>
</element>

<!-- constant Visibility: default -->
<element name="DRI_VERSION">
<short>Version of the <link id="TDrawInfo"/> structure, can be found in <link id="TDrawInfo"/>.dri_Version</short>
<descr>If you find <link id="TDrawInfo"/>.dri_Version >= <i>DRI_VERSION</i>, you know this structure has at least the fields defined in this version of the include file
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DRIF_NEWLOOK">
<short>Flag for <link id="TDrawInfo"/>.dri_Flags specified <link id="SA_Pens"/>, full treatment</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DETAILPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. Compatible Intuition rendering pens</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BLOCKPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. compatible Intuition rendering pens</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TEXTPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. text on background</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHINEPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. bright edge on 3D objects</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHADOWPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. dark edge on 3D objects</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FILLPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. active-window/selected-gadget fill</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FILLTEXTPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. text over <link id="FILLPEN"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BACKGROUNDPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. always color 0</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGHLIGHTTEXTPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. special color text, on background</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BARDETAILPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. text/detail in screen-bar/menus</short>
<descr>Only present if <link id="DRI_VERSION"/> >= 2
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BARBLOCKPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. screen-bar/menus fill</short>
<descr>Only present if <link id="DRI_VERSION"/> >= 2
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BARTRIMPEN">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. trim under screen-bar</short>
<descr>Only present if <link id="DRI_VERSION"/> >= 2
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NUMDRIPENS">
<short>Rendering pen number indexes into <link id="TDrawInfo"/>.dri_Pens. </short>
<descr>Only present if <link id="DRI_VERSION"/> >= 2
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PEN_C3">
<short>Complement of color 3</short>
<descr>It is sometimes useful to specify that a pen value is to be the complement
of color three.  This "magic" number serve that purpose.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PEN_C2">
<short>Complement of color 2</short>
<descr>It is sometimes useful to specify that a pen value is to be the complement
of color two.  This "magic" number serve that purpose.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PEN_C1">
<short>Complement of color 1</short>
<descr>It is sometimes useful to specify that a pen value is to be the complement
of color one.  This "magic" number serve that purpose.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PEN_C0">
<short>Complement of color 0</short>
<descr>It is sometimes useful to specify that a pen value is to be the complement
of color zero.  This "magic" number serve that purpose.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSERR_NOMONITOR">
<short>Error code of <link id="OpenScreen">OpenScreen()</link> returned into the PLongInt at <link id="SA_ErrorCode"/> Named monitor spec not available</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSERR_NOCHIPS">
<short>Error code of <link id="OpenScreen">OpenScreen()</link> returned into the PLongInt at <link id="SA_ErrorCode"/> You need newer custom chips</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSERR_NOMEM">
<short>Error code of <link id="OpenScreen">OpenScreen()</link> returned into the PLongInt at <link id="SA_ErrorCode"/> Couldn't get normal memory</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSERR_NOCHIPMEM">
<short>Error code of <link id="OpenScreen">OpenScreen()</link> returned into the PLongInt at <link id="SA_ErrorCode"/> Couldn't get chipmem</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSERR_PUBNOTUNIQUE">
<short>Error code of <link id="OpenScreen">OpenScreen()</link> returned into the PLongInt at <link id="SA_ErrorCode"/> Public screen name already used</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSERR_UNKNOWNMODE">
<short>Error code of <link id="OpenScreen">OpenScreen()</link> returned into the PLongInt at <link id="SA_ErrorCode"/> Don't recognize mode asked for</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="WBENCHSCREEN_f">
<short>Screentype flag for <link id="TScreen"/>.Flags and <link id="TNewScreen"/>.SType. The Workbench itself</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PUBLICSCREEN_f">
<short>Screentype flag for <link id="TScreen"/>.Flags and <link id="TNewScreen"/>.SType.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CUSTOMSCREEN_f">
<short>Screentype flag for <link id="TScreen"/>.Flags and <link id="TNewScreen"/>.SType. For that special look</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SCREENTYPE_f">
<short>Screentype flag for <link id="TScreen"/>.Flags and <link id="TNewScreen"/>.SType. All Screenstypes available</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHOWTITLE_f">
<short>Flag for <link id="TScreen"/>.Flags. This gets set by a call to <link id="ShowTitle">ShowTitle()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BEEPING_f">
<short>Flag for <link id="TScreen"/>.Flags. Set when Screen is beeping</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CUSTOMBITMAP_f">
<short>Flag for <link id="TScreen"/>.Flags. If you are supplying your own BitMap</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SCREENBEHIND_f">
<short>Flag for <link id="TScreen"/>.Flags. If you want your screen to open behind already open screens</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SCREENQUIET_f">
<short>Flag for <link id="TScreen"/>.Flags. If you do not want Intuition to render into your screen (gadgets, title)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SCREENHIRES">
<short>Flag for <link id="TScreen"/>.Flags. Do no use lowres gadgets (private)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PENSHARED">
<short>Flag for <link id="TScreen"/>.Flags. Screen opener set (<link id="SA_SharePens"/>,True)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NS_EXTENDED">
<short>Flag for <link id="TScreen"/>.Flags. <link id="TExtNewScreen"/>.Extension is valid</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AUTOSCROLL">
<short>Flag for <link id="TScreen"/>.Flags. Screen is to autoscoll</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STDSCREENHEIGHT">
<short>Supply in <link id="TNewScreen"/>.Height Set Hight to standard height</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STDSCREENWIDTH">
<short>Supply in <link id="TNewScreen"/>.Width Set Hight to standard width</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Dummy">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Tags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Left">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> eqivalent to <link id="TNewWindow"/>.LeftEdge </short>
<descr>
<p>Initial screen position (left edge).  Data is a LongInt,
    signed value.  Offsets are relative to the text overscan rectangle.</p>
<p>
    If <i>SA_Left</i> is not specified and a <link id="TNewWindow"/> structure is not passed
    in the <link id="OpenScreenTagList">OpenScreenTagList()</link> call and <link id="SA_Width"/> is not specified
    or is specified as <link id="STDSCREENWIDTH"/>, then the left edge of the screen
    will default to the left edge of the actual display clip of the
    screen.  If the other conditions are met but some explicit SA_Width
    is specified, then the left edge defaults to zero (text overscan
    rectangle left edge).  Likewise, the top edge may, independent of the
    left edge value, default to zero or to the top edge of the actual
    display clip.</p>
<p>
    When opening a full sized overscan screen, <i>SA_Left</i> should be set to
    the MinX value of the display clip Rectangle used for the screen and
    This may be taken from the defaults, as explained above, or explicitly set by
    the application.</p>
<p>
    If your screen is larger than your display clip, you may wish to set
    the <i>SA_Left</i> to a value less than your display clip MinX in order to center
    a large screen on a smaller display.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Top">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> eqivalent to <link id="TNewWindow"/>.TopEdge </short>
<descr><p>Initial screen position (top edge).  Data is a LongInt,
    signed value.  Offsets are relative to the text overscan rectangle.</p>
<p>
    If <i>SA_Top</i> is not specified and a <link id="TNewWindow"/> structure
    is not passed in the <link id="OpenScreenTagList">OpenScreenTagList()</link> call and <link id="SA_Width"/> is
    not specified or specified as <link id="STDSCREENHEIGHT"/>, then the top edge of
    the screen will default to the top edge of the actual display clip of
    the screen.  If the other conditions are met but some explicit
    SA_Height is specified, then the top edge defaults to zero (text
    overscan rectangle top edge).</p>
<p>
    When opening a full sized overscan screen,
    <i>SA_Top</i> should be set to the MinY value of the display clip.  This may
    be taken from the defaults, as explained above, or explicitly set by
    the application.</p>
<p>
    If your screen is larger than your display clip, you may wish to set
    the <i>SA_Top</i> to a value less than your display clip
    MinY in order to center a large screen on a smaller display.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Width">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> eqivalent to <link id="TNewWindow"/>.Width </short>
<descr><p>Screen dimensions.  Data is a LongWord.  These may be
    larger, smaller or the same as the dimensions of the display clip
    Rectangle.  The use of <link id="STDSCREENWIDTH"/> will make
    the screen size equal to the display clip size.</p>
<p>
    To calculate the width of the display clip Rectangle, subtract the
    MinX value from the MaxX value plus one.  Similarly, the height of
    the display clip may be calculated by subtracting the MinY value from
    the MaxY value plus one.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Height">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> eqivalent to <link id="TNewWindow"/>.Height </short>
<descr><p>Screen dimensions.  Data is a LongWord.  These may be
    larger, smaller or the same as the dimensions of the display clip
    Rectangle.  The use of <link id="STDSCREENWIDTH"/> will make
    the screen size equal to the display clip size.</p>
<p>
    To calculate the width of the display clip Rectangle, subtract the
    MinX value from the MaxX value plus one.  Similarly, the height of
    the display clip may be calculated by subtracting the MinY value from
    the MaxY value plus one.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Depth">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Screen bitmap depth </short>
<descr><p>Screen bitmap depth.  Data is a LongWord.  The depth of
    the screen determines the number of available colors.
    Do not set the depth to a value greater than that
    supported by the specific display mode.  This information is
    available to the application through the graphics library display
    database.  The default is one bitplane.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_DetailPen">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> serves as default for windows, too</short>
<descr>Detail pen for the screen.  Data is a long, unsigned value.  Used for
    rendering details in the screen title bar and menus.  Use <link id="SA_Pens"/>
    for more control of pen specification.  If <link id="SA_Pens"/>
    is not specified, the screen will not get the new 3D look of
    Intuition.  Instead this value will be used as
    the detail pen.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_BlockPen">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> serves as default for windows, too</short>
<descr>Block pen for the screen.  Data is a long, unsigned value.  Used for
    rendering block fills in the screen title bar and menus.  Use <link id="SA_Pens"/>
    for more control of pen specification.  If <link id="SA_Pens"/>
    is not specified, the screen will not get the new 3D look and this
    value will be used as the block pen.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Title">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> default screen title</short>
<descr>Default screen title.  Data is a pointer to a character string.  This
    is the title displayed when the active window has no screen title or
    when no window is active on the screen.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Colors">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> <link id="utility.TTagItem">ti_Data</link>
is an array of <link id="TColorSpec"/>, terminated by ColorIndex = -1.  Specifies initial screen palette colors.</short>
<descr>Specifies initial screen palette colors.  Data is a pointer to an
    array of <link id="TColorSpec"/> structures, terminated by a ColorSpec structure
    with ColorIndex=-1. Screen colors may be changed after the screen is
    opened with the graphics library functions <link id="AGraphics.SetRGB4">SetRGB4()</link> and <link id="AGraphics.LoadRGB4">LoadRGB4()</link>.
    ColorSpec colors are right-justified, four bits per gun.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_ErrorCode">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> <link id="utility.TTagItem">ti_Data</link> points to LongInt error code</short>
<descr>Extended error code.  Data is a pointer to a LongInt which will contain
    the error code on return if <link id="OpenScreenTagList">OpenScreenTagList()</link> returns nil. The
    error codes are described above.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Font">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> equiv. to <link id="TNewScreen"/>.Font </short>
<descr>Data is a pointer to a <link id="AGraphics.TTextAttr"/> structure which specifies the font, size and style to use
    for the screen.  Equivalent to <link id="TNewScreen"/>.Font.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_SysFont">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Selects one of the preferences system fonts: 0 - old DefaultFont, fixed-width 1 - WB Screen preferred font</short>
<descr>
<p>Alternative to <link id="SA_Font"/>. Selects one of the preferences system fonts.
Data is a LongWord, with the following values defined:</p>
<dl>
  <dt>0</dt><dd>Open screen with the user's preferred fixed width font (the default).</dd>
  <dt>1</dt><dd>Open screen with the user's preferred font, which may be proportional.</dd>
</dl>
<p>
  The Workbench screen is opened with [<link id="SA_SysFont"/>, 1]. Table
  summarizes how the font selected at <link id="OpenScreen">OpenScreen()</link> time effects
  subsequent text operations in screens and windows.</p>
<table border="1">
  <th><td> </td><td>What you tell OpenScreen()</td><td>Screen font</td><td>Window.RPort font</td></th>
  <tr><td><b>A.</b></td><td><link id="TNewScreen"/>.Font = myfont</td><td>myfont</td><td>myfont</td></tr>
  <tr><td><b>B.</b></td><td><link id="TNewScreen"/>.Font = nil</td><td><link id="AGraphics.TGfxBase"/>.DefaultFont</td><td><link id="AGraphics.TGfxBase"/>.DefaultFont</td></tr>
  <tr><td><b>C.</b></td><td>[<link id="SA_Font"/>, myfont]</td><td>myfont</td><td>myfont</td></tr>
  <tr><td><b>D.</b></td><td>[<link id="SA_SysFont"/>, 0]</td><td><link id="AGraphics.TGfxBase"/>.DefaultFont</td><td><link id="AGraphics.TGfxBase"/>.DefaultFont</td></tr>
  <tr><td><b>E.</b></td><td>[<link id="SA_SysFont"/>, 1]</td><td>Font Prefs Screen text</td><td><link id="AGraphics.TGfxBase"/>.DefaultFont</td></tr>
</table>
<p><b>Notes:</b></p>
<ul>
  <li><b>A</b> and <b>B</b> are the options that existed in V34 and earlier OS versions.</li>
  <li><b>C</b> and <b>D</b> are tags in Release 2 equivalent to A and B respectively.</li>
  <li><b>E</b> is a new option for V36.  The Workbench screen uses this option.</li>
  <li>For `myfont', any font may be used including a proportional one.
       This is true under all releases of the OS.</li>
  <li><link id="AGraphics.TGfxBase"/>.DefaultFont is always monospace.  (This is the "System
       Default Text" from Font Preferences.)</li>
  <li>Font Prefs Screen text (the "Screen Text" choice from Font
       Preferences) can be monospace or proportional.</li>
</ul>
<p>
    The screen's font may not legally be changed after a screen is
    opened. The menu bar, window titles, menu items, and the contents of
    a string gadget all use the screen's font.  The font used for menu
    items can be overridden in the menu item's IntuiText structure.
    Under V36 and higher, the font used in a string gadget can be
    overridden through the StringExtend structure.  The font of the menu
    bar and window titles cannot be overridden.</p>
<p>
    The Window.RPort font shown above is the initial font that Intuition
    sets in your window's RastPort.  It is legal to change that
    subsequently with <link id="AGraphics.SetFont">SetFont()</link>.  IntuiText rendered into a window
    (either through <link id="PrintIText">PrintIText()</link> or as a <link id="TGadget"/>.GadgetText) defaults to
    the window's RastPort font, but can be overridden using its <link id="TGadget"/>.TITextFont
    field.  Text rendered with the graphics library call <link id="AGraphics.GfxText">GfxText()</link> uses the
    window's RastPort font.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Type">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> equiv. to <link id="TNewScreen"/>.SType</short>
<descr>
Equivalent to the <link id="SCREENTYPE_f"/> bits of the <link id="TNewScreen"/>.SType field.  Data
is a LongWord, which may be set to either <link id="CUSTOMSCREEN_f"/> or
<link id="PUBLICSCREEN_f"/> (<link id="WBENCHSCREEN_f"/> is reserved for system use).  See the tags
<link id="SA_BitMap"/>, <link id="SA_Behind"/>, <link id="SA_Quiet"/>, <link id="SA_ShowTitle"/> and <link id="SA_AutoScroll"/> for
the other attributes of the <link id="TNewScreen"/>.SType field.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_BitMap">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> <link id="utility.TTagItem">ti_Data</link> is pointer to custom BitMap.  This implies <link id="TNewScreen">TNewScreen.SType</link> of <link id="CUSTOMBITMAP_f"/></short>
<descr>
  Use a custom bitmap for this screen.  Data is a <link id="AGraphics.PBitMap"/>.
  This tag is equivalent to <link id="TNewScreen"/>.CustomBitMap and
  implies the <link id="CUSTOMBITMAP_f"/> flag of the NewScreen.Type field.  The
  application is responsible for allocating and freeing the screen's bitmap.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_PubName">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Presence of this tag means that the screen is to be a public screen. Please specify <b>before</b> <link id="SA_PubSig"/> and <link id="SA_PubTask"/></short>
<descr>
Presence of this tag means that the screen is to be a public screen.
Data is a PChar.  The string is the name of the public
screen which is used by other applications to find the screen.  This
tag is order dependent, specify before <link id="SA_PubSig"/> and <link id="SA_PubTask"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_PubSig">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> </short>
<descr>
Signal for notification that the
last window has closed on a public screen. Data is a
LongWord. This tag is order dependent, and must be specified
 after the tag <link id="SA_PubName"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_PubTask">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Task ID and signal for being notified that the last window has closed on a public screen.</short>
<descr>
Task (returned by <link id="Exec.FindTask">FindTask()</link>) notification that the
last window has closed on a public screen. Data is a
long, unsigned value. Data is a pointer to a <link id="exec.TTask"/>
structure. This tag is order dependent, and must be specified
 after the tag <link id="SA_PubName"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_DisplayID">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> <link id="utility.TTagItem">ti_Data</link> is new extended display ID</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_DClip">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> <link id="utility.TTagItem">ti_Data</link> points to a rectangle which defines screen display clip region </short>
<descr>
Custom display clip specification.  Data is a pointer to a Rectangle
structure that defines the screen display clip region.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Overscan">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Set Overscan defaults to <link id="OSCAN_TEXT"/></short>
<descr>
Set to one of the OSCAN_* specifiers to get a system standard
verscan region for your display clip, screen dimensions (unless otherwise specified),
and automatically centered position (partial support only so far).
If you use this, you shouldn't specify <link id="SA_DClip"/>.  <i>SA_Overscan</i> is for "standard"
overscan dimensions, <link id="SA_DClip"/> is for your custom numeric specifications.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_ShowTitle">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> boolean equivalent to flag <link id="SHOWTITLE"/></short>
<descr><p>
Setting this flag places the screen's title bar in front of any
backdrop windows that are opened on the screen.  Data is a boolean
value (True to set flag).  This tag is equivalent to the <link id="SHOWTITLE"/>
flag of the <link id="TNewScreen"/>.SType field. The title bar of the screen is
always displayed behind any non-backdrop windows on that screen.
This attribute can be changed after the screen is open with the
<link id="ShowTitle">ShowTitle()</link> function.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Behind">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> boolean equivalent to flag <link id="SCREENBEHIND_f"/></short>
<descr>
Open this screen behind all other screens in the system.  Data is a
boolean value (True to set flag).  This tag is equivalent to the
<link id="SCREENBEHIND_f"/> flag of the NewScreen.Type field.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Quiet">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> boolean equivalent to flag <link id="SCREENQUIET_f"/></short>
<descr>
Disable Intuition rendering into screen.  Data is a boolean value
(True to set flag).  This tag is equivalent to the <link id="SCREENQUIET_f"/> flag
of the <link id="TNewScreen"/>.SType field. The screen will have no visible title
bar or gadgets, but dragging and depth arrangement still function.
In order to completely prevent Intuition from rendering into the
screen, menu operations must be disabled for each window in the
screen using <link id="WFLG_RMBTRAP"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_AutoScroll">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> boolean equivalent to flag <link id="AUTOSCROLL"/></short>
<descr>
<p>Setting this flag will enable autoscroll for this screen when it is
   the active screen.  (Currently, the screen may only be made active by
   activating a window in that screen either under user or application
   control.)  Data is a boolean value (True to set flag).  This tag is
   equivalent to the <link id="AUTOSCROLL"/> flag of the <link id="TNewScreen"/>.SType field.</p>
<p>
   Autoscroll means that screens larger than the visible display will
   automatically scroll when the user moves the mouse to the edge of the
   screen.  Without this tag, the user moves the screen either by using
   the screen drag bar, or by pressing the mouse select button anywhere
   within the screen while holding down the left Amiga key and moving
   the mouse.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Pens">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> pointer to $FFFFFFFF terminated LongWord array, as found in <link id="TDrawInfo"/></short>
<descr>
Pen specification for the screen.  Data is a pointer to a LongWord array
terminated with $FFFFFFFF, as found in the DrawInfo structure.  Specifying
the SA_Pens tag informs the system that the application is prepared
to handle a screen rendered with the new 3D look of Intuition. Omitting this tag
produces a screen with a flat look, but whose color usage is more
backwards compatible.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_FullPalette">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> boolean: initialize color table to entire preferences palette, rather than compatible pens 0-3, 17-19, with remaining palette as returned by <link id="AGraphics.GetColorMap">GetColorMap()</link> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_ColorMapEntries">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Allows you to override the number of entries in the ColorMap for your screen.</short>
<descr> Intuition normally allocates ((1 shl depth) or 32), whichever is more, but you may require even more if you
 use certain graphics.library features (eg. palette-banking).
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Parent">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Pointer to a "parent" screen to attach this one to.  Attached screens slide and depth-arrange together.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Draggable">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Boolean tag allowing non-draggable screens. Do not use without good reason! (Defaults to True).</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Exclusive">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Boolean tag allowing screens that won't share the display. (Defaults to False)</short>
<descr>Use sparingly! Attached screens may be <link id="SA_Exclusive"/>.
Setting <link id="SA_Exclusive"/> for each screen will produce an exclusive family.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_SharePens">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Allocate pens as shared</short>
<descr>
For those pens in the screen's DrawInfo^.dri_Pens, Intuition obtains them in shared mode (see
<link id="agraphics.ObtainPen">ObtainPen()</link>).  For compatibility, Intuition obtains the other pens of a public
screen as <link id="agraphics.PEN_EXCLUSIVE">PEN_EXCLUSIVE</link>.  Screens that wish to manage the pens themselves should generally set
this tag to True. This instructs Intuition to leave the other pens unallocated.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_BackFill">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> provides a "backfill hook" for your screen's <link id="Layers.TLayer_Info">TLayer_Info</link>. See <link id="Layers.InstallLayerInfoHook">Layers.InstallLayerInfoHook()</link></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Interleaved">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Boolean tag requesting that the bitmap allocated for you be interleaved. (Defaults to False).</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Colors32">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> set the screen's initial palette colors at 32 bits-per-gun.</short>
<descr>
<link id="utility.TTagItem">ti_Data</link> is a pointer
to a table to be passed to the <link id="agraphics.LoadRGB32">LoadRGB32()</link> function. This format supports both runs of color
registers and sparse registers.  See the autodoc for that function for full details. Any color set here has
precedence over the same register set by <link id="SA_Colors"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_VideoControl">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Pointer to a taglist that Intuition will pass to <link id="agraphics.VideoControl">VideoControl()</link>, upon opening the screen.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_FrontChild">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Pointer to an already open screen that is to be the child of the screen being opened. The child screen will be moved to the front of its family.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_BackChild">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Pointer to an already open screen that is to be the child of the screen being opened. The child screen will be moved to the back of its family.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_LikeWorkbench">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> 1  = request a screen which is just like the Workbench.  This gives you the same screen mode, depth, size, colors, etc., as the Workbench screen.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_Reserved">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> Reserved for private Intuition use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SA_MinimizeISG">
<short>Tag start for <link id="OpenScreenTagList">OpenScreenTagList()</link> inter-screen gap is at least three non-interlaced lines</short>
<descr>
For compatibility, Intuition always ensures that the inter-screen gap is at least three non-interlaced lines.  If your application
would look best with the smallest possible inter-screen gap, set <link id="utility.TTagItem">ti_Data</link> to True. If you use the <link id="Agraphics.VideoControl">VideoControl()</link>
<link id="AGraphics.VC_NoColorPaletteLoad">VC_NoColorPaletteLoad</link> tag for your screen's ViewPort, you should also set this tag.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="NSTAG_EXT_VPMODE">
<short>this is an obsolete tag included only for compatibility with V35 interim release for the A2024 and Viking monitors</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSCAN_TEXT">
<short>Identifier for <link id="SA_Overscan"/> entirely visible</short>
<descr>
</descr>
<seealso>
<link id="OpenScreenTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSCAN_STANDARD">
<short>Identifier for <link id="SA_Overscan"/> just past edges</short>
<descr>
</descr>
<seealso>
<link id="OpenScreenTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSCAN_MAX">
<short>Identifier for <link id="SA_Overscan"/> as much as possible</short>
<descr>
</descr>
<seealso>
<link id="OpenScreenTagList"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OSCAN_VIDEO">
<short>Identifier for <link id="SA_Overscan"/> even more than is possible</short>
<descr>
</descr>
<seealso>
<link id="OpenScreenTagList"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PNewScreen">
<short>pointer to an instance of a NewScreen structure.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TNewScreen">
<short>Description of a new screen</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.LeftEdge">
<short>initial position of your screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.TopEdge">
<short>Left and Top are specified relative to the Intuition's view,
    in same resolution as the screen pixels.</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.Width">
<short>the width for this screen's RastPort, or the constant <link id="STDSCREENWIDTH"/> to get the current default width</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.Height">
<short>the height for his screen's RastPort, or the constant <link id="STDSCREENHEIGHT"/> to get the current default height</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.Depth">
<short>number of bitplanes</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.DetailPen">
<short>pen number for details (like gadgets or text in title bar/border/gadget) The common value for this pen is 0.</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.BlockPen">
<short>pen number for block fills (like title bar/border/gadget) The common value for this pen is 1.</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.ViewModes">
<short>the Modes for the ViewPort (and View)</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.SType">
<short>the Screen type <link id="CUSTOMSCREEN_f"/>, <link id="CUSTOMBITMAP_f"/> (Type in C-Include)</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.Font">
<short>this Screen's default text attributes</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.DefaultTitle">
<short>the default title for this Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.Gadgets">
<short>your own Gadgets for this Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TNewScreen.CustomBitMap">
<short>if you have your own display memory that you
       want used for this screen, the CustomBitMap field should point to
        the BitMap structure that describes your display memory.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtNewScreen">
<short>Pointer to Extended New Screen structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExtNewScreen">
<short>Extended <link id="TNewScreen"/> structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.LeftEdge">
<short>see at <link id="TNewScreen"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.TopEdge">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.Width">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.Height">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.Depth">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.DetailPen">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.BlockPen">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.ViewModes">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.ens_Type">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.Font">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.DefaultTitle">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.Gadgets">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.CustomBitMap">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TExtNewScreen.Extension">
<short><i>TExtNewScreen</i> specific extension SA_*</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPubScreenNode">
<short>Pointer to Public Shared Screen Node</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TPubScreenNode">
<short>Public Shared Screen Node</short>
<descr>
This is the representative of a public shared screen.
  This is an internal data structure, but some functions may
  present a copy of it to the calling application.  In that case,
  be aware that the screen pointer of the structure can NOT be
  used safely, since there is no guarantee that the referenced
  screen will remain open and a valid data structure.
  Never change one of these.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_Node">
<short><link id="Exec.TNode">ln_Name</link> is screen name</short>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_Screen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_Flags">
<short>Flags (PSNF_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_Size">
<short>includes name buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_VisitorCount">
<short>how many visitor windows</short>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_SigTask">
<short>who to signal when visitors gone</short>
</element>

<!-- variable Visibility: default -->
<element name="TPubScreenNode.psn_SigBit">
<short>which signal</short>
</element>

<!-- constant Visibility: default -->
<element name="PSNF_PRIVATE">
<short>Flag for <link id="TPubScreenNode"/>.psn_Flags Private</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAXPUBSCREENNAME">
<short>Maximum length of public screen names. The buffers containing these strings must have a length of <i>MAXPUBSCREENNAME</i> + 1.</short>
<descr>
</descr>
<seealso>
<link id="TPubScreenNode"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHANGHAI">
<short>Pub Screen mode. put workbench windows on pub screen</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POPPUBSCREEN">
<short>Pub screen mode. pop pub screen to front when visitor opens</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SDEPTH_TOFRONT">
<short>Flag for <link id="ScreenDepth">ScreenDepth()</link>. Bring screen to front</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SDEPTH_TOBACK">
<short>Flag for <link id="ScreenDepth">ScreenDepth()</link>. Send screen to back</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPOS_RELATIVE">
<short>Flag for <link id="ScreenPosition">ScreenPosition()</link>. The x1 and y1 parameters to <link id="ScreenPosition">ScreenPosition()</link> describe the offset in coordinates you wish to move the screen by. Coordinates are relative </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPOS_ABSOLUTE">
<short>Flag for <link id="ScreenPosition">ScreenPosition()</link>. The x1 and y1 parameters to <link id="ScreenPosition">ScreenPosition()</link> describe the absolute coordinates you wish to move the screen to. Coordinates are expressed as absolutes, not relatives.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPOS_MAKEVISIBLE">
<short>Flag for <link id="ScreenPosition">ScreenPosition()</link>. Coordinates describe a box on the screen you wish to be made visible by autoscrolling (x1,y1)-(x2,y2) describes a rectangle on the screen which you would like autoscrolled into view. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPOS_FORCEDRAG">
<short>Flag for <link id="ScreenPosition">ScreenPosition()</link>. Move non-draggable screen, You may additionally set <i>SPOS_FORCEDRAG</i> along with any of the above.
 Set this if you wish to reposition an [<link id="SA_Draggable"/>, False] screen that you opened.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PScreenBuffer">
<short>Pointer to screen buffer</short>
<descr>
</descr>
<seealso>
<link id="AGraphics.AllocDBufInfo"/>
<link id="AllocScreenBuffer"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TScreenBuffer">
<short>Screen buffer structure</short>
<descr>Intuition supports double-buffering in screens, with friendly interaction with menus and certain gadgets.
  For each buffer, you need to get one of these structures from the <link id="AllocScreenBuffer">AllocScreenBuffer()</link> call.
  Never allocate your own ScreenBuffer structures!
  The sb_DBufInfo field is for your use.
</descr>
<seealso>
<link id="AGraphics.AllocDBufInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TScreenBuffer.sb_BitMap">
<short>BitMap of this buffer</short>
</element>

<!-- variable Visibility: default -->
<element name="TScreenBuffer.sb_DBufInfo">
<short>DBufInfo for this buffer</short>
</element>

<!-- constant Visibility: default -->
<element name="SB_SCREEN_BITMAP">
<short>Flag for <link id="AllocScreenBuffer">AllocScreenBuffer()</link>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SB_COPY_BITMAP">
<short>Flag for <link id="AllocScreenBuffer">AllocScreenBuffer()</link>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FILENAME_SIZE">
<short>Filename size for printer configuration</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DEVNAME_SIZE">
<short>Devicename size for printer configuration</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERSIZE">
<short>Size of Pointer data buffer for printer configuration</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TOPAZ_EIGHTY">
<short>default font size</short>
<descr>
This actually describe the
  height of the default font.  The default font type is the topaz
  font, which is a fixed width font that can be used in either
  eighty-column or sixty-column mode.  The Preferences structure reflects
  which is currently selected by the value found in the variable FontSize,
  which may have either of the values defined below.  These values actually
  are used to select the height of the default font.  By changing the
  height, the resolution of the font changes as well.
</descr>
<seealso>
<link id="TOPAZ_SIXTY"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="TOPAZ_SIXTY">
<short>default font size</short>
<descr>
This actually describe the
  height of the default font.  The default font type is the topaz
  font, which is a fixed width font that can be used in either
  eighty-column or sixty-column mode.  The Preferences structure reflects
  which is currently selected by the value found in the variable FontSize,
  which may have either of the values defined below.  These values actually
  are used to select the height of the default font.  By changing the
  height, the resolution of the font changes as well.
</descr>
<seealso>
<link id="TOPAZ_EIGHTY"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPreferences">
<short>Pointer to old style Preferences</short>
<descr>
</descr>
<seealso>
<link id="GetDefPrefs"/>
<link id="GetPrefs"/>
<link id="SetPrefs"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TPreferences">
<short>Old Style Preferences</short>
<descr>
</descr>
<seealso>
<link id="GetDefPrefs"/>
<link id="GetPrefs"/>
<link id="SetPrefs"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.FontHeight">
<short>height for system default font</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrinterPort">
<short>printer port connection constant describing what's hooked up to the port </short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.BaudRate">
<short>baud rate for the serial port</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.KeyRptSpeed">
<short>repeat speed for keyboard</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.KeyRptDelay">
<short>Delay before keys repeat</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.DoubleClick">
<short>Interval allowed between clicks</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PointerMatrix">
<short>Mouse Data: Definition of pointer sprite</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.XOffset">
<short>Mouse Data: X-Offset for active 'bit'</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.YOffset">
<short>Mouse Data: Y-Offset for active 'bit'</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color17">
<short>Mouse Data: Colours for sprite pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color18">
<short>Mouse Data: </short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color19">
<short>Mouse Data: </short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PointerTicks">
<short>Mouse Data: Sensitivity of the pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color0">
<short>Workbench Screen colors</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color1">
<short>Standard default colours</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color2">
<short>Used in the Workbench</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.color3">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.ViewXOffset">
<short>Offset for top lefthand corner</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.ViewYOffset">
<short>Y dimensions</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.ViewInitX">
<short>X dimensions</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.ViewInitY">
<short>View initial offset values</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.EnableCLI">
<short>CLI availability switch</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrinterType">
<short>printer type</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrinterFilename">
<short>file for printer</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintPitch">
<short>print pitch</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintQuality">
<short>print quality</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintSpacing">
<short>number of lines per inch</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintLeftMargin">
<short>left margin in characters</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintRightMargin">
<short>right margin in characters</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintImage">
<short>positive or negative</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintAspect">
<short>horizontal or vertical</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintShade">
<short>b/w, half-tone, or color</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintThreshold">
<short>darkness ctrl for b/w dumps</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PaperSize">
<short>paper size</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PaperLength">
<short>paper length in number of lines</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PaperType">
<short>continuous or single sheet</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.SerRWBits">
<short>Serial Setting: upper nibble = (8-number of read bits), lower nibble = (8-number of write bits)</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.SerStopBuf">
<short>Serial Setting: upper nibble = (number of stop bits - 1), lower nibble = (table value for BufSize)</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.SerParShk">
<short>Serial Setting: upper nibble = (value for Parity setting), lower nibble = (value for Handshake mode)</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.LaceWB">
<short>if workbench is to be interlaced </short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.Pad">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrtDevName">
<short>Device used by printer.device (leave out the ".device")</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.DefaultPrtUnit">
<short>Default unit opened by printer.device</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.DefaultSerUnit">
<short>Default serial unit</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.RowSizeChange">
<short>Affect NormalDisplayRows/Columns</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.ColumnSizeChange">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintFlags">
<short>user preference flags</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintMaxWidth">
<short>max width of printed picture in 10ths/inch</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintMaxHeight">
<short>max height of printed picture in 10ths/inch</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintDensity">
<short>print density</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.PrintXOffset">
<short>offset of printed picture in 10ths/inch</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.wb_Width">
<short>override default workbench width</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.wb_Height">
<short>override default workbench height</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.wb_Depth">
<short>override default workbench depth</short>
</element>

<!-- variable Visibility: default -->
<element name="TPreferences.ext_size">
<short>extension information -- do not touch! extension size in blocks of 64 bytes DO NOT TOUCH</short>
</element>

<!-- constant Visibility: default -->
<element name="LACEWB">
<short>Interlace define for <link id="TPreferences"/>.LaceWB</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LW_RESERVED">
<short>internal use only for <link id="TPreferences"/>.LaceWB</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PARALLEL_PRINTER">
<short>Value for <link id="TPreferences"/>.PrinterPort</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SERIAL_PRINTER">
<short>Value for <link id="TPreferences"/>.PrinterPort</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_110">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_300">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_1200">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_2400">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_4800">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_9600">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_19200">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BAUD_MIDI">
<short>Value for <link id="TPreferences"/>.BaudRate</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PICA">
<short>Value for <link id="TPreferences"/>.PrintPitch</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ELITE">
<short>Value for <link id="TPreferences"/>.PrintPitch</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FINE">
<short>Value for <link id="TPreferences"/>.PrintPitch</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DRAFT">
<short>Value for <link id="TPreferences"/>.PrintQuality</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LETTER">
<short>Value for <link id="TPreferences"/>.PrintQuality</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIX_LPI">
<short>Value for <link id="TPreferences"/>.PrintSpacing</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EIGHT_LPI">
<short>Value for <link id="TPreferences"/>.PrintSpacing</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IMAGE_POSITIVE">
<short>Value for <link id="TPreferences"/>.PrintImage</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IMAGE_NEGATIVE">
<short>Value for <link id="TPreferences"/>.PrintImage</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ASPECT_HORIZ">
<short>Value for <link id="TPreferences"/>.PrintAspect</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ASPECT_VERT">
<short>Value for <link id="TPreferences"/>.PrintAspect</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHADE_BW">
<short>Value for <link id="TPreferences"/>.PrintShade</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHADE_GREYSCALE">
<short>Value for <link id="TPreferences"/>.PrintShade</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHADE_COLOR">
<short>Value for <link id="TPreferences"/>.PrintShade</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="US_LETTER">
<short>Value for <link id="TPreferences"/>.PaperSize</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="US_LEGAL">
<short>Value for <link id="TPreferences"/>.PaperSize</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="N_TRACTOR">
<short>Value for <link id="TPreferences"/>.PaperSize</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="W_TRACTOR">
<short>Value for <link id="TPreferences"/>.PaperSize</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CUSTOM_PAPER">
<short>Value for <link id="TPreferences"/>.PaperSize</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A0">
<short>Value for <link id="TPreferences"/>.PaperSize European size A0: 841 x 1189</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A1">
<short>Value for <link id="TPreferences"/>.PaperSize European size A1: 594 x 841</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A2">
<short>Value for <link id="TPreferences"/>.PaperSize European size A2: 420 x 594</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A3">
<short>Value for <link id="TPreferences"/>.PaperSize European size A3: 297 x 420</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A4">
<short>Value for <link id="TPreferences"/>.PaperSize European size A4: 210 x 297</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A5">
<short>Value for <link id="TPreferences"/>.PaperSize European size A5: 148 x 210</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A6">
<short>Value for <link id="TPreferences"/>.PaperSize European size A6: 105 x 148</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A7">
<short>Value for <link id="TPreferences"/>.PaperSize European size A7: 74 x 105</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EURO_A8">
<short>Value for <link id="TPreferences"/>.PaperSize European size A8: 52 x 74</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CUSTOM_NAME">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ALPHA_P_101">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BROTHER_15XL">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CBM_MPS1000">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DIAB_630">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DIAB_ADV_D25">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DIAB_C_150">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EPSON">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EPSON_JX_80">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OKIMATE_20">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="QUME_LP_20">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HP_LASERJET">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HP_LASERJET_PLUS">
<short>Value for <link id="TPreferences"/>.PrinterType</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUF_512">
<short>Value for <link id="TPreferences"/>.SerStopBuf Lower Nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUF_1024">
<short>Value for <link id="TPreferences"/>.SerStopBuf Lower Nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUF_2048">
<short>Value for <link id="TPreferences"/>.SerStopBuf Lower Nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUF_4096">
<short>Value for <link id="TPreferences"/>.SerStopBuf Lower Nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUF_8000">
<short>Value for <link id="TPreferences"/>.SerStopBuf Lower Nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUF_16000">
<short>Value for <link id="TPreferences"/>.SerStopBuf Lower Nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SREAD_BITS">
<short>Mask for <link id="TPreferences"/>.SerRWBits Upper nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SWRITE_BITS">
<short>Mask for <link id="TPreferences"/>.SerRWBits Lower nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SSTOP_BITS">
<short>Mask for <link id="TPreferences"/>.SerStopBuf Upper nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SBUFSIZE_BITS">
<short>Mask for <link id="TPreferences"/>.SerStopBuf lower nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPARITY_BITS">
<short>Mask for <link id="TPreferences"/>.SerParShk upper nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHSHAKE_BITS">
<short>Mask for <link id="TPreferences"/>.SerParShk Lower nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPARITY_NONE">
<short>Serial Parity <link id="TPreferences"/>.SerParShk (upper nibble)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPARITY_EVEN">
<short>Serial Parity <link id="TPreferences"/>.SerParShk (upper nibble)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SPARITY_ODD">
<short>Serial Parity <link id="TPreferences"/>.SerParShk (upper nibble)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHSHAKE_XON">
<short>Serial Handshake Mode <link id="TPreferences"/>.SerParShk (lower nibble</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHSHAKE_RTS">
<short>Serial Handshake Mode <link id="TPreferences"/>.SerParShk (lower nibble)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SHSHAKE_NONE">
<short>Serial Handshake Mode <link id="TPreferences"/>.SerParShk (lower nibble)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CORRECT_RED">
<short>Flag for <link id="TPreferences"/>.PrintFlags color correct red shades</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CORRECT_GREEN">
<short>Flag for <link id="TPreferences"/>.PrintFlags color correct green shades</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CORRECT_BLUE">
<short>Flag for <link id="TPreferences"/>.PrintFlags color correct blue shades</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CENTER_IMAGE">
<short>Flag for <link id="TPreferences"/>.PrintFlags center image on paper</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IGNORE_DIMENSIONS">
<short>Flag for <link id="TPreferences"/>.PrintFlags ignore max width/height settings</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BOUNDED_DIMENSIONS">
<short>Flag for <link id="TPreferences"/>.PrintFlags use max width/height as boundaries</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ABSOLUTE_DIMENSIONS">
<short>Flag for <link id="TPreferences"/>.PrintFlags use max width/height as absolutes</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PIXEL_DIMENSIONS">
<short>Flag for <link id="TPreferences"/>.PrintFlags use max width/height as prt pixels</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MULTIPLY_DIMENSIONS">
<short>Flag for <link id="TPreferences"/>.PrintFlags use max width/height as multipliers</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="INTEGER_SCALING">
<short>Flag for <link id="TPreferences"/>.PrintFlags force integer scaling</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ORDERED_DITHERING">
<short>Flag for <link id="TPreferences"/>.PrintFlags ordered dithering</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HALFTONE_DITHERING">
<short>Flag for <link id="TPreferences"/>.PrintFlags halftone dithering</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FLOYD_DITHERING">
<short>Flag for <link id="TPreferences"/>.PrintFlags Floyd-Steinberg dithering</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ANTI_ALIAS">
<short>Flag for <link id="TPreferences"/>.PrintFlags anti-alias image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GREY_SCALE2">
<short>Flag for <link id="TPreferences"/>.PrintFlags for use with hi-res monitor</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CORRECT_RGB_MASK">
<short>Mask for <link id="TPreferences"/>.PrintFlags color corrections RGB</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DIMENSIONS_MASK">
<short>Mask for <link id="TPreferences"/>.PrintFlags Dimensions mask</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DITHERING_MASK">
<short>Mask for <link id="TPreferences"/>.PrintFlags Dithering mask</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntuitionBase">
<short>Pointer to Intution basic structures</short>
<descr>
</descr>
<seealso>
<link id="TIntuitionBase"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIntuitionBase">
<short>Intuition basic structure</short>
<descr><p>It is sometimes necessary to examine the <i>IntuitionBase</i> structure.  Items
such as the address of the active screen and window, current mouse
coordinates and more can be found there.  It is never a good idea to
simply read these fields, as they are prone to sudden change.  The
<i>IntuitionBase</i> structure must always be locked before looking at its fields.</p>
<p>
It is necessary to inform Intuition that an application is about to
examine <i>IntuitionBase</i> so that Intuition will not change any variables and
<i>IntuitionBase</i> will remain static during the access.  The call <link id="LockIBase">LockIBase(0)</link>
will lock the state of <i>IntuitionBase</i> so that it may be examined.  During
the time that the application has <i>IntuitionBase</i> locked, all Intuition
input processing is frozen.  Make every effort to examine <i>IntuitionBase</i>
and release the lock as quickly as possible.
When done call <link id="UnlockIBase">UnlockIBase(lock)</link> where lock is what <link id="LockIBase">LockIBase(0)</link> returned.
</p>
<p><b>The values in <i>IntuitionBase</i> are read-only.  Applications should never write values to <i>IntuitionBase</i>.</b></p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.LibNode">
<short>Standard Libnode</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.ViewLord">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.ActiveWindow">
<short>Currently active Window</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.ActiveScreen">
<short>Currently Active Screen</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.FirstScreen">
<short>for linked list of all screens, the <i>FirstScreen</i> variable points to the frontmost Screen.
Screens are then maintained in a front to back order using <link id="TScreen">TScreen.NextScreen</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.Flags">
<short>values are all system private</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.MouseY">
<short>Current Mouse position</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.MouseX">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.Seconds">
<short>timestamp of most current input event [s]</short>
</element>

<!-- variable Visibility: default -->
<element name="TIntuitionBase.Micros">
<short>The data beyond this point has changed, is changing, and will continue to change.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PGadgetInfo">
<short>Pointer to Gadget Render Info</short>
<descr>
</descr>
<seealso>
<link id="TopSet"/>
<link id="TopUpdate"/>
<link id="TgpHitTest"/>
<link id="TgpRender"/>
<link id="TgpInput"/>
<link id="TgpGoInactive"/>
<link id="TgpLayout"/>
<link id="TgpDomain"/>
<link id="TSGWork"/>
<link id="GadgetMouse"/>
<link id="ObtainGIRPort"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TGadgetInfo">
<short>The TGadgetInfo structure contains information
about the display on which the gadget needs to render itself</short>
<descr>
<p>All the fields in this structure are read only.</p>
<p>Although this structure contains a pointer to the gadget's RastPort
structure, applications should not use it for rendering.  Instead, use the
intuition.library function <link id="ObtainGIRPort">ObtainGIRPort()</link> to obtain a copy of the
GadgetInfo's RastPort.  When the gadget is finished with this RastPort, it
should call <link id="ReleaseGIRPort">ReleaseGIRPort()</link> to relinquish the RastPort.</p>
</descr>
<seealso>
<link id="TopSet"/>
<link id="TopUpdate"/>
<link id="TgpHitTest"/>
<link id="TgpRender"/>
<link id="TgpInput"/>
<link id="TgpGoInactive"/>
<link id="TgpLayout"/>
<link id="TgpDomain"/>
<link id="TSGWork"/>
<link id="GadgetMouse"/>
<link id="ObtainGIRPort"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Screen">
<short>ScreenPtr</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Window">
<short>nil for screen gadgets</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Requester">
<short>nil IF not <link id="GTYP_REQGADGET"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_RastPort">
<short>Rendering information: don't use these without cloning/locking. Official way is to call <link id="ObtainGIRPort">ObtainGIRPort()</link></short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Layer">
<short>LayerPtr</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Domain">
<short>Copy of dimensions of screen/window/g00/req(/group) that gadget resides in.</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.DetailPen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.BlockPen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Pens">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_DrInfo">
<short>the Detail and Block pens in <i>gi_DrInfo^.dri_Pens[]</i> are for the screen. Use the above for window-sensitive colors.</short>
</element>

<!-- variable Visibility: default -->
<element name="TGadgetInfo.gi_Reserved">
<short></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPGX">
<short>Pointer to System private data structure for now
   prop gadget extra info</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TPGX">
<short>System private data structure for now
   prop gadget extra info</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TPGX.pgx_Container">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TPGX.pgx_NewKnob">
<short></short>
</element>

<!-- alias type Visibility: default -->
<element name="Object_">
<short>Handle for an BOOPSI Objects / Classes / Messages</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PObject_">
<short>Pointer to an BOOPSI Object / Classe / Message Handle</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPObject_">
<short>Pointer to an BOOPSI Object / Classe / Message Pointer Handle</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ClassID">
<short>Name of the Object class</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PMsg">
<short></short>
<descr>
  You can use this type to point to a 'generic' message,
  in the object-oriented programming parlance.  Based on
  the value of <i>MethodID</i>, you dispatch to processing
  for the various message types. The meaningful parameter
  packet structure definitions are defined below.
</descr>
<seealso>
<link id="DoGadgetMethodA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TMsg">
<short></short>
<descr>
</descr>
<seealso>
<link id="DoGadgetMethodA"/>
<link id="TopSet"/>
<link id="TopGet"/>
<link id="TopAddTail"/>
<link id="TopMember"/>
<link id="TopUpdate"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TMsg.MethodID">
<short>Message ID OM_*</short>
</element>

<!-- constant Visibility: default -->
<element name="ROOTCLASS">
<short>Root Class identifier, This is the universal base class for all other classes.</short>
<descr><p>All Classes are descendants of the
rootclass. There are three primary classes that descend directly from
rootclass: <link id="imageclass"/>, <link id="gadgetclass"/>, and <link id="icclass"/>.</p>
<p><b>SuperClass:</b> None</p>
<p><b>New Methods:</b></p>
<p>
<link id="OM_NEW"/>, <link id="OM_ADDTAIL"/>, <link id="OM_DISPOSE"/>, <link id="OM_REMOVE"/></p>
<p>
The following methods are described at the rootclass level although its up
to the subclasses to actually implement them.  If a class does not
implement these methods, it should either return zero, indicating that
this class does not support the method, or defer processing on to its
superclass.</p>
<p>
<link id="OM_ADDMEMBER"/>, <link id="OM_GET"/>, <link id="OM_UPDATE"/>,
<link id="OM_REMMEMBER"/>, <link id="OM_SET"/>, <link id="OM_NOTIFY"/></p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IMAGECLASS">
<short>Class identifier. This class is the base class for Boopsi Images.</short>
<descr>
<p><b>SuperClass:</b><link id="rootclass"/></p>
<p>This class is the base class for Boopsi Images.  These images are
backwards compatible with the conventional Intuition Images.  Every Boopsi
image has an Intuition Image structure embedded in it so Intuition can
access the Boopsi image as a conventional Image structure when necessary.
Normally there are no direct instances of this class, only instances of
subclasses of imageclass.</p>
<p><b>New Methods:</b></p>
<p>
<link id="IM_DRAW"/>, <link id="IM_ERASE"/>, <link id="IM_HITFRAME"/>, <link id="IM_FRAMEBOX"/>,
<link id="IM_HITTEST"/>, <link id="IM_DRAWFRAME"/>, <link id="IM_ERASEFRAME"/> </p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_NEW"/>, <link id="OM_SET"/></p>
<p><b>Attributes:</b></p>
<p><link id="IA_Left"/> (ISG)</p>
<p><link id="IA_Top"/> (ISG)</p>
<p><link id="IA_Width"/> (ISG)</p>
<p><link id="IA_Height"/> (ISG)</p>
<p><link id="IA_FGPen"/> (ISG)</p>
<p><link id="IA_BGPen"/> (ISG)</p>
<p><link id="IA_Data"/> (ISG)</p>
<p><link id="IA_Pens"/> ()</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FRAMEICLASS">
<short>Class identifier. This is a class of framing image, which can optionally fill itself.</short>
<descr>
<p><b>SuperClass:</b><link id="imageclass"/></p>
<p>This is a class of framing image, which can optionally fill itself.  Its
purpose is to frame other display elements using an embossed or recessed
rectangular frame.  The frame renders itself using the appropriate
<link id="TDrawInfo"/> pens (<link id="SHINEPEN"/>, <link id="SHADOWPEN"/>, etc.).  This class is intelligent
enough to bound or center its contents.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="IM_DRAW"/>,
<link id="IDS_NORMAL"/>, <link id="IDS_INACTIVENORMAL"/>, <link id="IDS_DISABLED"/>,
<link id="IDS_SELECTED"/>, <link id="IDS_INACTIVESELECTED"/>,
<link id="IM_DRAWFRAME"/>,
<link id="IM_FRAMEBOX"/></p>
<p><b>Attributes:</b></p>
<p><link id="IA_Recessed"/> (IS)</p>
<p><link id="IA_EdgesOnly"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSICLASS">
<short>Class identifier. The class of system images.  The class includes the images for the
    system and GadTools gadgets.</short>
<descr>
<p><b>SuperClass:</b><link id="imageclass"/></p>
<p>This is a class of system images and standard application images.  There are 11 possible sysiclass image glyphs to
choose from:</p>
<dl>
  <dt>DEPTHIMAGE</dt><dd>Window depth arrangement image.</dd>
  <dt>ZOOMIMAGE</dt><dd>Window Zoom image.</dd>
  <dt>SIZEIMAGE</dt><dd>Window Sizing image.</dd>
  <dt>CLOSEIMAGE</dt><dd>Window close image.</dd>
  <dt>SDEPTHIMAGE</dt><dd>Screen depth arrangement image.</dd>
  <dt>LEFTIMAGE</dt><dd>Left arrow image.</dd>
  <dt>RIGHTIMAGE</dt><dd>Right arrow image.</dd>
  <dt>UPIMAGE</dt><dd>Up arrow image.</dd>
  <dt>DOWNIMAGE</dt><dd>Down arrow image.</dd>
  <dt>CHECKIMAGE</dt><dd>Checkmark image.</dd>
  <dt>MXIMAGE</dt><dd>Radio button image.</dd>
</dl>
<p>The class caches the image's bitmap to improve rendering speed.
</p>
<p><b>Attributes:</b></p>
<p><link id="SYSIA_DrawInfo"/> (I)</p>
<p><link id="SYSIA_Which"/> (I)</p>
<p><link id="SYSIA_Size"/> (I)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FILLRECTCLASS">
<short>Class identifier</short>
<descr>
<p><b>SuperClass:</b><link id="imageclass"/></p>
<p>This is a class of filled rectangles.  The fillrectclass object can use a
pattern to fill in its interior.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="IM_DRAW"/></p>
<p><b>Attributes:</b></p>
<p><link id="IA_APattern"/> (IS)</p>
<p><link id="IA_APatSize"/> (IS)</p>
<p><link id="IA_Mode"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GADGETCLASS">
<short>Class identifier. This is a base class for Intuition compatible gadget objects.</short>
<descr>
<p><b>SuperClass:</b><link id="rootclass"/></p>
<p>This is a base class for Intuition compatible gadget objects.  The
dispatcher for this class takes care of creating an Intuition Gadget
structure as part of its local instance data.  All of the standard Boopsi
gadget classes build on this class.  Normally there are no direct
instances of this class, only instances of subclasses of gadgetclass.</p>
<p>
The behavior of a Boopsi gadget depends on how it handles the five Boopsi
gadget methods: <link id="GM_HITTEST"/>, <link id="GM_RENDER"/>, <link id="GM_GOACTIVE"/>, <link id="GM_HANDLEINPUT"/>, and
<link id="GM_GOINACTIVE"/>.  Intuition controls a Boopsi gadget by sending it these
types of messages.  The structures that these methods use for their
messages begin with the method's ID followed by a pointer to a <link id="TGadgetInfo"/>
structure .  The GadgetInfo structure is
a read-only structure that contains information about the gadget's
rendering environment.  The gadget uses this to find things like its
window, screen, or pen array.  Although this structure does contain a
pointer to a RastPort for the gadget, the gadget must not use this
RastPort for rendering.  The gadget can obtain a RastPort for rendering by
calling the Intuition function <link id="ObtainGIRPort">ObtainGIRPort()</link> using the GadgetInfo
structure.</p>
<p>
These methods are not defined directly by gadgetclass. It is up to
subclasses of gadgetclass to implement them.</p>
<p>
Like all Boopsi methods, these methods run on the context of the task that
called the method.  Normally, Intuition is the only entity that calls
these methods, so these normally operate in the input.device's task.
Because a gadget may have to process a large number of input events, poor
implementations of gadget methods (especially the <link id="GM_HANDLEINPUT"/> method)
can degrade system performance.</p>

<p><b>New Methods:</b></p>
<p>
<link id="GM_HITTEST"/>, <link id="GM_GOACTIVE"/>, <link id="GM_GOINACTIVE"/>, <link id="GM_RENDER"/>,
<link id="GM_HANDLEINPUT"/></p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_NEW"/>, <link id="OM_NOTIFY"/></p>
<p><b>Attributes:</b></p>
<p><link id="GA_Previous"/> (I)</p>
<p><link id="ICA_TARGET"/> (IS)</p>
<p><link id="ICA_MAP"/> (IS)</p>
<p><link id="GA_Left"/> (IS)</p>
<p><link id="GA_Top"/> (IS)</p>
<p><link id="GA_Width"/> (IS)</p>
<p><link id="GA_Height"/> (IS)</p>
<p><link id="GA_RelRight"/> (IS)</p>
<p><link id="GA_RelBottom"/> (IS)</p>
<p><link id="GA_RelWidth"/> (IS)</p>
<p><link id="GA_RelHeight"/> (IS)</p>
<p>
The remaining attributes defined by gadgetclass are used to set the fields
in the Gadget structure of the Boopsi gadget.  Some Boopsi gadgets do not
pay attention to many of the fields in its Gadget structure, so most
applications will not have to worry about the majority of these
attributes.  Some gadget classes assign special meanings to these
attributes.  See the documentation of the specific gadget classes for more
details.</p>
<p><link id="GA_IntuiText"/> (IS)</p>
<p><link id="GA_Text"/> (IS)</p>
<p><link id="GA_LabelImage"/> (IS)</p>
<p><link id="GA_Image"/> (IS)</p>
<p><link id="GA_Border"/> (IS)</p>
<p><link id="GA_SelectRender"/> (IS)</p>
<p><link id="GA_ID"/> (IS)</p>
<p><link id="GA_UserData"/> (IS)</p>
<p><link id="GA_SpecialInfo"/> (IS)</p>
<p><link id="GA_GZZGadget"/> (IS)</p>
<p><link id="GA_SysGadget"/> (IS)</p>
<p><link id="GA_Disabled"/> (IS)</p>
<p><link id="GA_Selected"/> (IS)</p>
<p><link id="GA_EndGadget"/> (IS)</p>
<p><link id="GA_Immediate"/> (IS)</p>
<p><link id="GA_RelVerify"/> (IS)</p>
<p><link id="GA_FollowMouse"/> (IS)</p>
<p><link id="GA_RightBorder"/> (IS)</p>
<p><link id="GA_LeftBorder"/> (IS)</p>
<p><link id="GA_TopBorder"/> (IS)</p>
<p><link id="GA_BottomBorder"/> (IS)</p>
<p><link id="GA_ToggleSelect"/> (IS)</p>
<p><link id="GA_TabCycle"/> (IS)</p>
<p><link id="GA_Highlight"/> (IS)</p>
<p><link id="GA_SysGType"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PROPGCLASS">
<short>Class identifier. An easy to implement, horizontal or vertical proportional gadget.</short>
<descr>
<p><b>SuperClass:</b><link id="gadgetclass"/></p>
<p>A Boopsi proportional ("prop") gadget.  The Boopsi prop gadget is similar
to the conventional prop gadget, but extends its function to make it
easier to use.  The Boopsi prop gadget keeps its current integer value in
its <link id="PGA_Top"/> attribute.
</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="GM_HANDLEINPUT"/></p>
<p><b>Attributes:</b></p>
<p><link id="GA_Image"/> (I)</p>
<p><link id="GA_Border"/> (I)</p>
<p><link id="GA_Highlight"/> (I)</p>
<p><link id="PGA_Freedom"/> (IG)</p>
<p><link id="PGA_Top"/> (ISGNU)</p>
<p><link id="PGA_NewLook"/> (I)</p>
<p><link id="PGA_Visible"/> (ISU)</p>
<p><link id="PGA_Total"/> (ISU)</p>
<p><link id="PGA_Borderless"/> (I)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="StrgClass">
<short>Class identifier. A string gadget.</short>
<descr>
<p><b>SuperClass:</b><link id="gadgetclass"/></p>
<p>Intuition compatible string gadgets.  The Boopsi string gadget can either
be a plain string gadget or an integer string gadget.  An integer gadget
filters out all characters except those that make up integer values.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_NEW"/></p>
<p><b>Attributes:</b></p>
<p><link id="STRINGA_LongVal"/> (ISGNU)</p>
<p><link id="STRINGA_TextVal"/> (ISGNU)</p>
<p>The remaining strgclass attributes correspond to the flags and fields that
the conventional Intuition string gadget uses.</p>
<p><link id="STRINGA_MaxChars"/> (I)</p>
<p><link id="STRINGA_Buffer"/> (I)</p>
<p><link id="STRINGA_UndoBuffer"/> (I)</p>
<p><link id="STRINGA_WorkBuffer"/> (I)</p>
<p><link id="STRINGA_BufferPos"/> (ISU)</p>
<p><link id="STRINGA_DispPos"/> (ISU)</p>
<p><link id="STRINGA_AltKeyMap"/> (IS)</p>
<p><link id="STRINGA_Font"/> (IS)</p>
<p><link id="STRINGA_Pens"/> (IS)</p>
<p><link id="STRINGA_ActivePens"/> (IS)</p>
<p><link id="STRINGA_EditHook"/> (I)</p>
<p><link id="STRINGA_EditModes"/> (IS)</p>
<p><link id="STRINGA_ReplaceMode"/> (IS)</p>
<p><link id="STRINGA_FixedFieldMode"/> (IS)</p>
<p><link id="STRINGA_NoFilterMode"/> (IS)</p>
<p><link id="STRINGA_Justification"/> (IS)</p>
<p><link id="STRINGA_ExitHelp"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="BUTTONGCLASS">
<short>Class identifier. A button gadget that keeps sending button presses while the user holds it down.</short>
<descr>
<p><b>SuperClass:</b><link id="gadgetclass"/></p>
<p>A class of button gadget that continually sends interim <link id="OM_UPDATE"/> messages
to its target while the user holds down the button.  The button sends a
final <link id="OM_UPDATE"/> message when the user lets  go of the button. The imagery
for these objects is not built directly into the gadget.  Instead, a
buttongclass object uses a Boopsi image object, which it gets from its
<link id="GA_Image"/> attribute.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="GM_HITTEST"/>, <link id="GM_HANDLEINPUT"/>, <link id="GM_RENDER"/></p>
<p><b>Attributes:</b></p>
<p><link id="GA_Image"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FRBUTTONCLASS">
<short>Class identifier. A <link id="buttongclass"/> gadget that outlines its imagery with a frame.
</short>
<descr>
<p>This is a special class of button gadget that puts a Boopsi framing image
around some other display element.  This display element can be one of
three things: plain text from the <link id="GA_Text"/> attribute, an IntuiText from the
<link id="GA_IntuiText"/> attribute, or an Image from the <link id="GA_LabelImage"/> attribute.</p>
<p>
The user activates the gadget by clicking within the bounds of the
gadget's framing image, which it gets from the <link id="GA_Image"/> attribute.
Usually the framing image is an instance of an image class that supports
the <link id="IM_FRAMEBOX"/> method (like <link id="frameiclass"/>).  If the framing image supports
the <link id="IM_FRAMEBOX"/> method, the frbuttonclass object centers the frame image
around the display element.  See the imageclass description of <link id="IM_FRAMEBOX"/>
for more information.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_NEW"/>,
<link id="GM_HITTEST"/>,
<link id="GM_RENDER"/></p>
<p><b>Attributes:</b></p>
<p><link id="GA_Width"/> (S)</p>
<p><link id="GA_Height"/> (S)</p>
<p><link id="GA_DrawInfo"/> (I)</p>
<p><link id="GA_Text"/> (IS)</p>
<p><link id="GA_IntuiText"/> (IS)</p>
<p><link id="GA_LabelImage"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GROUPGCLASS">
<short>Class identifier. A special gadget class that creates one composite gadget out of several others.</short>
<descr>
<p><b>SuperClass:</b><link id="gadgetclass"/></p>
<p>This is a class of objects that maintains an internal list of gadgets.
Its purpose is to make it easier to layout a group of gadgets.  Any
gadgets that are a member of a groupgclass object are rendered relative to
the groupgclass object's <link id="GA_Left"/> and <link id="GA_Top"/> attributes. As new gadgets
are added to the groupgclass object, the groupgclass object's dimensions
grow to enclose the new gadgets.  When the groupgclass object receives an
<link id="OM_DISPOSE"/> message, it not only disposes of itself, it also disposes of
all the gadgets in its list.  Groupgclass does not support the gadget
relative flags (<link id="GA_RelWidth"/>, <link id="GA_RelHeight"/>,
<link id="GA_RelBottom"/>, and <link id="GA_RelRight"/>).</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_SET"/>,
<link id="GM_HITTEST"/>,
<link id="OM_ADDMEMBER"/>,
<link id="GM_RENDER"/>,
<link id="OM_REMMEMBER"/>,
<link id="GM_GOACTIVE"/>,
<link id="GM_GOINACTIVE"/>,
<link id="GM_HANDLEINPUT"/>,
<link id="OM_DISPOSE"/></p>
<p><b>Attributes:</b></p>
<p><link id="GA_Left"/> (IS)</p>
<p><link id="GA_Top"/> (IS)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICCLASS">
<short>Class identifier. Interconnection class</short>
<descr>
<p><b>SuperClass:</b><link id="rootclass"/></p>
<p>
Base class of simple <link id="OM_UPDATE"/> forwarding objects.  When an icclass object
gets an <link id="OM_UPDATE"/> message, it maps the attributes in the <link id="OM_UPDATE"/> message
according to its mapping list (its <link id="ICA_MAP"/> attribute) and forwards the
<link id="OM_UPDATE"/> to its target (its <link id="ICA_TARGET"/> attribute).</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_SET"/>,
<link id="OM_UPDATE"/>,
<link id="OM_NOTIFY"/></p>
<p><b>Attributes:</b></p>
<p><link id="ICA_TARGET"/> (IS)</p>
<p><link id="ICA_MAP"/> (IS)</p>
<p><link id="ICSPECIAL_CODE"/> (*)</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MODELCLASS">
<short>Class identifier. Multiple Targets</short>
<descr>
<p><b>SuperClass:</b><link id="icclass"/></p>
<p>A class of <link id="OM_UPDATE"/> forwarding objects that have multiple targets.  In
addition to the features the modelclass object inherits from <link id="icclass"/>, when
a modelclass object gets an <link id="OM_UPDATE"/> message, it forwards that <link id="OM_UPDATE"/>
message to all of the objects in its broadcast list.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="OM_ADDMEMBER"/>,
<link id="OM_REMMEMBER"/>,
<link id="OM_DISPOSE"/>,
<link id="OM_NOTIFY"/>,
<link id="OM_UPDATE"/>
</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ITEXTICLASS">
<short>Class identifier. A specialized image class used for rendering text.
</short>
<descr>
<p><b>SuperClass:</b><link id="imageclass"/></p>
<p>This is a class of image objects that render an IntuiText structure.
Using some of the imageclass attributes, the object can override some of
the parameters in the IntuiText structure.  This class makes it easy to
share an IntuiText structure between objects.</p>
<p><b>Changed Methods:</b></p>
<p>
<link id="IM_DRAW"/>,
<link id="IM_DRAWFRAME"/>
</p>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERCLASS">
<short>Class identifier</short>
<descr>
</descr>
<seealso>
<link id="ClassID"/>
<link id="TIClass"/>.cl_ID
<link id="MakeClass"/>
<link id="NewObjectA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_Dummy">
<short>Start of dispatched method ID's</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_NEW">
<short>This method creates a new object.</short>
<descr>
<p>This method tells a class to create a new instance of itself.  If <i>OM_NEW</i>
is successful, it returns a pointer to the new object, otherwise it
returns nil.</p>
<p>
For programmers who are only creating Boopsi objects rather than creating
custom classes, use the intuition.library function <link id="NewObject">NewObject()</link></p>
<p>
The <i>OM_NEW</i> method receives the arguments via <link id="PopSet"/>.</p>
<p>
The <link id="TopSet">ops_AttrList</link> field contains a pointer to a tag list of attribute/value
pairs.  Each pair contains an attribute ID and the initial value of the
corresponding attribute.</p>
<p>
The <link id="TopSet">ops_GInfo</link> field is always nil for the <i>OM_NEW</i> method.</p>
<p>
Unlike other methods, when the dispatcher gets an <i>OM_NEW</i> message, the
object pointer does not point to an object, since the idea is to create a new object.
The pointer normally used to pass a Boopsi object is instead used to pass
the address of the object's "true class" (the class of which the object
is an instance).</p>
<p>
The first thing the dispatcher does when it processes an OM_NEW message is
pass the <i>OM_NEW</i> message on to its superclass's dispatcher.  It does this
using function <link id="DoSuperMethodA">DoSuperMethodA()</link>.</p>
<p>
Each superclass's dispatcher does this until the message gets to the
<link id="rootclass"/> dispatcher.</p>
<p>
Each class keeps a record of how much memory its local instance data
requires.  The <link id="rootclass"/> dispatcher's <i>OM_NEW</i> method looks at the object's
true class (newobject from the prototype) to find out how much memory to
allocate for the object's instance data.  The <link id="rootclass"/> dispatcher
allocates enough memory for the true class's local instance data, plus
enough memory for the local instance data of each of the true class's
superclasses.  If all goes well, the <link id="rootclass"/> dispatcher increments the
true class's internal count of instances of true class, and returns a
pointer to the newly created object.  it passes control back to the
subclass dispatcher that called it.  If there was a problem, the <link id="rootclass"/>
dispatcher passes back a nil.</p>
<p>
When the <link id="rootclass"/> dispatcher returns, the subclass dispatcher regains
control from <link id="DoSuperMethodA">DoSuperMethodA()</link>.
<link id="DoSuperMethodA">DoSuperMethodA()</link> will return either a
pointer to the new object or nil if there was an error.  Although the
<link id="rootclass"/> dispatcher allocated all the memory the object needs, it did not
set up any of that memory.  Now its the the subclass dispatcher's turn to
do some work.  It has to initialize the instance data that is local to its
class.  A dispatcher finds its local instance data by using the
<link id="INST_DATA">INST_DATA()</link> macro.</p>
<p>
After initializing its local instance data, the subclass dispatcher passes
control down to its subclass dispatcher, which in turn, initializes its
local instance data.  Control passes down from class to subclass until the
true class dispatcher regains control.</p>
<p>
Now the true class dispatcher has to initialize its local instance data.
It has to scan through the tag list of attribute/value pairs passed in the
<i>OM_NEW</i> message (<link id="TopSet">TopSet.ops_AttrList</link>).  If the dispatcher finds any
attributes that the true class recognizes, it has to initialize them to
the value passed in the attribute/value pair.</p>
<p>
At this point, the new object can allocate other resources it needs that
it did not allocate as part of its instance data.  For example, the new
Boopsi object might need a frame image around itself, so it can create a
new one using a Boopsi frame image.  If the object allocates any resources
in this step, it must deallocate these resources later when it is disposed
in the <link id="OM_DISPOSE"/> method.</p>
<p>
Finally, the dispatcher can return.  When the dispatcher returns from an
<i>OM_NEW</i> method, it returns a pointer to the new object.</p>
</descr>
<seealso>
<link id="TopSet"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_DISPOSE">
<short>This method tells an object to dispose of itself.</short>
<descr>
<p>This method instructs an object to delete itself.  The rootclass
dispatcher's <i>OM_DISPOSE</i> method decrements the true class's internal count
of instances of true class.  The return value for this method is not
explicitly defined.</p>
<p>
This method uses the <link id="TMsg">default Boopsi message</link>.</p>
<p>
Applications should not call this method directly.  Instead they should
use the function <link id="DisposeObject">DisposeObject()</link>.</p>
<p>
For the <i>OM_DISPOSE</i> method, an object should do the following:</p>
<p>
Free any additional resources the object explicitly allocated itself in
the <link id="OM_NEW"/> method (this does not include the instance data).</p>
<p>
Pass the message up to the superclass, which will eventually reach
<link id="rootclass"/>, which will free the instance data allocated for the object.</p>
<p>
If a class does not allocate any extra resources when it creates an
object, it can defer all <i>OM_DISPOSE</i> processing to its superclass.</p>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_SET">
<short>This method tells an object to set one or more of its attribute values.</short>
<descr>
<p>This method tells an object to set one or more of its attributes.
Applications should not call this method directly.  Instead, use the
intuition.library functions SetAttrs() and SetGadgetAttrs() to call this
method.  The return value for this method is not explicitly defined.</p>
<p>
The return value for this method is not explicitly defined.  However, in
general, when implementing the OM_SET method, if setting an object
attribute causes some sort of visual state change, the OM_SET method
should return a value greater than zero.  If changing an attribute does
not affect the visual state, OM_SET should return zero.</p>
<p>
This method uses a <link id="TopSet"/> Message.</p>
<p>
The <link id="TopSet">ops_AttrList</link> field contains a pointer to a tag list of attribute/value
pairs.  These pairs contain the IDs and the new values of the attributes
to set.  The dispatcher has to look through this list (see
<link id="Utility.NextTagItem">NextTagItem()</link> function) for attributes its class
recognizes and set the attribute's value accordingly. The dispatcher
should let its superclass handle any attributes it does not recognize.</p>
<p>
If the object is a gadget, the <link id="TopSet">ops_GInfo</link> field contains a pointer to a
<link id="TGadgetInfo"/> structure. Otherwise, the value in <link id="TopSet">ops_GInfo</link> is undefined.
Intuition use the <link id="TGadgetInfo"/> structure to pass display information to
gadgets.  See the <link id="gadgetclass"/> methods for more details.</p>
</descr>
<seealso>
<link id="TopSet"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_GET">
<short>This method tells an object to report an attribute value.</short>
<descr>
<p>Tells an object to report an attribute's value.  Applications should not
call this method directly.  Instead, use the intuition.library function
<link id="GetAttr">GetAttr()</link>. The return value for this method is not explicitly defined.</p>
<p>
This method uses <link id="TopGet"/> message.</p>
<p>
If the object's dispatcher recognizes <link id="TopGet">opg_AttrID</link> as one of the attributes
defined by this class, the dispatcher should copy the value of that
attribute to where <link id="TopGet">opg_Storage</link> points.</p>
<p>
If the dispatcher does not recognize <link id="TopGet">opg_AttrID</link>, it should pass the
message on to the superclass.</p>
</descr>
<seealso>
<link id="TopGet"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_ADDTAIL">
<short>This method tells an object to add itself to the end of an Exec list.</short>
<descr>
<p>This method tells an object to add itself to the end of a specified Exec
list.  Boopsi objects contain a MinNode structure used for this purpose.
The return value for this method is not explicitly defined.</p>
<p>
The method uses <link id="TopAddTail"/> message</p>
<p>
The <link id="TopAddTail">opat_List</link> can be any Exec list.  Use the Intuition function
<link id="NextObject">NextObject()</link> to step through this list.</p>
</descr>
<seealso>
<link id="TopAddTail"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_REMOVE">
<short>This method tells an object to remove itself from an Exec list.</short>
<descr>
<p>Remove an object from an Exec list.  The return value for this method is
not explicitly defined.  This method uses the <link id="TMsg">default Boopsi message</link>.
</p>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_NOTIFY">
<short>This method tells an object to broadcast an attribute change to its broadcast list.</short>
<descr>
<p>This method tells an object to broadcast an attribute change to a set of
target objects using <link id="OM_UPDATE"/> messages.  The return value for this method
is not explicitly defined.</p>
<p>
The <i>OM_NOTIFY</i> method uses the <link id="TopUpdate"/> message structure.</p>
<p>
Most dispatchers do not handle the <i>OM_NOTIFY</i> message directly.  Normally
they inherit this method from a superclass, so they pass the <i>OM_NOTIFY</i>
message on to the superclass dispatcher.</p>
<p>
Although most dispatchers don't have to process <i>OM_NOTIFY</i> messages, most
do have to send them.  Whenever an object receives an <link id="OM_SET"/> or <link id="OM_UPDATE"/>
about one of its attributes, it may need to notify other objects of the
change.  For example, when a prop gadget's <link id="PGA_Top"/> value changes, its
target object(s) need to hear about it.</p>
<p>
If an object needs to notify other objects about a change to one or more
of its attributes, it sends itself an <i>OM_NOTIFY</i> message.  The <i>OM_NOTIFY</i>
message will eventually end up in the hands of a superclass that
understands <i>OM_NOTIFY</i> and it will send <link id="OM_UPDATE"/> messages to the target
objects.</p>
</descr>
<seealso>
<link id="TopUpdate"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_UPDATE">
<short>This method tells an object to update one or more of its attribute values.</short>
<descr>
<p>This method tells an object to update one or more of its attributes.  No
application should call this method.  Only Boopsi objects send <i>OM_UPDATE</i>
messages. The return value for this method is not explicitly defined.</p>
<p>
A Boopsi object uses an <i>OM_UPDATE</i> message to notify another Boopsi object
about transitory changes to one or more attributes.</p>
<p>
From the point of view of most objects, an <i>OM_UPDATE</i> message is almost
identical to <link id="OM_SET"/>.  Because the methods are so similar, When a typical
dispatcher receives an <i>OM_UPDATE</i> message, it processes the <i>OM_UPDATE</i> the
same way it would process an <link id="OM_SET"/> message, usually using the same code.</p>
<p>
There are actually two kinds of <i>OM_UPDATE</i>, an interim and final one.
While a Boopsi object's attribute is in a transient state, it can send out
interim <i>OM_UPDATE</i> messages to its target(s).  For example, while the user
is sliding a Boopsi prop gadget, the prop gadget sends interim <i>OM_UPDATE</i>
message about changes to its <link id="PGA_Top"/> value (the integer value of the prop
gadget is the <link id="PGA_Top"/> attribute) to some target object.  When the user
lets go of the prop gadget, the gadget is no longer in a transient state,
so the gadget sends out a final <i>OM_UPDATE</i> about its <link id="PGA_Top"/> attribute.
The target object can choose to change one of its attributes based on the
<i>OM_UPDATE</i> messages it receives.</p>
<p>
The layout of the <i>OM_UPDATE</i> message is almost identical to the <link id="OM_SET"/>
message</p>
<p>
Some dispatchers need to know the difference between an interim and final
<i>OM_UPDATE</i>.  A dispatcher can tell the difference between an interim and
final <i>OM_UPDATE</i> message because the <i>OM_UPDATE</i> message has an extra field
for flags.  If the low order bit (the <link id="OPUF_INTERIM"/> bit) is set, this is an
interim <i>OM_UPDATE</i> message.  The interim flag is useful to a class that
wants to ignore any interim messages, processing only final attribute
values.</p>
</descr>
<seealso>
<link id="TopUpdate"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_ADDMEMBER">
<short>This method tells an object to add an object to its broadcast list.</short>
<descr>
<p>Tells an object to add another object to its personal Exec list.  What the
list is for depends on the class.  The return value for this method is not
explicitly defined.</p>
<p>
One class that uses this method is modelclass.  A modelclass object
maintains a broadcast list.  When a modelclass object gets an <link id="OM_NOTIFY"/>
message, it broadcasts an <link id="OM_UPDATE"/> message about the <link id="OM_NOTIFY"/> to every
object in its broadcast list.</p>
<p>
This method uses <link id="TopMember"/> message.</p>
<p>
<link id="TopMember">opam_Object</link> is the object to add to the list.  A dispatcher typically
implements <i>OM_ADDMEMBER</i> by sending the <link id="OM_ADDTAIL"/> message to the
<link id="TopMember">opam_Object</link> object.</p>
</descr>
<seealso>
<link id="TopMember"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="OM_REMMEMBER">
<short>This method tells an object to remove an object from its broadcast list.</short>
<descr>
<p>Tells an object to remove a member object from its personal list.  The
member object should have already been added with <link id="OM_ADDMEMBER"/>.  This
method uses the <link id="TopMember"/> message.  Normally a
dispatcher implements <link id="OM_REMMEMBER"/> by sending the <link id="OM_REMOVE"/> message to the
<link id="TopMember">opam_Object</link> object.  The return value for this method is not explicitly
defined.</p>
</descr>
<seealso>
<link id="TopMember"/>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PopSet">
<short>Pointer to message structure for <link id="OM_NEW"/>/<link id="OM_SET"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TopSet">
<short>Message structure for <link id="OM_NEW"/>/<link id="OM_SET"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TopSet.MethodID">
<short><link id="OM_NEW"/> or <link id="OM_SET"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TopSet.ops_AttrList">
<short>new attributes</short>
</element>

<!-- variable Visibility: default -->
<element name="TopSet.ops_GInfo">
<short>Always there for gadgets, when <link id="SetGadgetAttrsA">SetGadgetAttrsA()</link> is used, but will be nil for <link id="OM_NEW"/></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PopGet">
<short>Pointer to message structure for <link id="OM_GET"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TopGet">
<short>Message structure for <link id="OM_GET"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="topGet.MethodID">
<short><link id="OM_GET"/></short>
</element>

<!-- variable Visibility: default -->
<element name="topGet.opg_AttrID">
<short>ID of attribute to get</short>
</element>

<!-- variable Visibility: default -->
<element name="topGet.opg_Storage">
<short>may be other types, but 'integer' types are all LongWord</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PopAddTail">
<short>Pointer to message structure for <link id="OM_ADDTAIL"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TopAddTail">
<short>Message structure for <link id="OM_ADDTAIL"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TopAddTail.MethodID">
<short><link id="OM_ADDTAIL"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TopAddTail.opat_List">
<short>The exec list to add the object to</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PopMember">
<short>Pointer to message structure for <link id="OM_ADDMEMBER"/>/<link id="OM_REMMEMBER"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TopMember">
<short>Message structure for <link id="OM_ADDMEMBER"/>/<link id="OM_REMMEMBER"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TopMember.MethodID">
<short><link id="OM_ADDMEMBER"/> or <link id="OM_REMMEMBER"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TopMember.opam_Object">
<short>add or remove this object</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PopUpdate">
<short>Pointer to message structure for <link id="OM_NOTIFY"/>/<link id="OM_UPDATE"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TopUpdate">
<short>Message structure for <link id="OM_NOTIFY"/>/<link id="OM_UPDATE"/></short>
<descr>
</descr>
<seealso>
<link id="TMsg"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TopUpdate.MethodID">
<short><link id="OM_NOTIFY"/> or <link id="OM_UPDATE"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TopUpdate.opu_AttrList">
<short>tag list of new attributes</short>
</element>

<!-- variable Visibility: default -->
<element name="TopUpdate.opu_GInfo">
<short>Non-nil when <link id="SetGadgetAttrsA">SetGadgetAttrsA()</link> <b>or</b> notification resulting from gadget input occurs.</short>
</element>

<!-- variable Visibility: default -->
<element name="TopUpdate.opu_Flags">
<short>Additional flags (OPUF_*)</short>
</element>

<!-- constant Visibility: default -->
<element name="OPUF_INTERIM">
<short>Flag for <link id="TopUpdate"/>.opu_Flags</short>
<descr>
  This flag means that the update message is being issued from
  something like an active gadget, a la <link id="GACT_FOLLOWMOUSE"/>.  When
  the gadget goes inactive, it will issue a final update
  message with this bit cleared.  Examples of use are for
  <link id="GACT_FOLLOWMOUSE"/> equivalents for <link id="propgclass"/>, and repeat strobes
  for buttons.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PIClass">
<short>This structure is READ-ONLY, and allocated only by Intuition</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIClass">
<short>This structure is READ-ONLY, and allocated only by Intuition</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_Dispatcher">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_Reserved">
<short>must be 0</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_Super">
<short>Super Class</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_ID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_InstOffset">
<short>where within an object is the instance data for this class?</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_InstSize">
<short>Size of instance data</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_UserData">
<short>per-class data of your choice, application specific</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_SubclassCount">
<short># of direct suclasses</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_ObjectCount">
<short># of objects, made from this class must be 0, if the class is to be deleted</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_Flags">
<short> Flags (<link id="CLF_INLIST"/>)</short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_ObjectSize">
<short>Overall size of object: <i>cl_InstOffset</i> + <i>cl_InstSize</i> + <i>SizeOf(_Object)</i></short>
</element>

<!-- variable Visibility: default -->
<element name="TIClass.cl_MemoryPool">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="CLF_INLIST">
<short> class is in public class list (<link id="TIClass"/>.cl_Flags)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="P_Object">
<short>Pointer to an Boopsi Object</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="T_Object">
<short>Boopsi Object structure</short>
<descr>
  We have this, the instance data of the root class, PRECEDING
  the 'object'.  This is so that Gadget objects are Gadget pointers,
  and so on.  If this structure grows, it will always have o_Class
  at the end, so the macro <link id="OCLASS">OCLASS(o)</link> will always have the same
  offset back from the pointer returned from <link id="NewObject">NewObject()</link>.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="T_Object.o_Node">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="T_Object.o_Class">
<short>Class pointer</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PClassLibrary">
<short>Pointer to a BOOPSI class libraries</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TClassLibrary">
<short>BOOPSI class libraries structure</short>
<descr>
  BOOPSI class libraries should use this structure as the base for their
  library data.  This allows developers to obtain the class pointer for
  performing object-less inquiries.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TClassLibrary.cl_Lib">
<short>Embedded library</short>
</element>

<!-- variable Visibility: default -->
<element name="TClassLibrary.cl_Pad">
<short>Align the structure</short>
</element>

<!-- variable Visibility: default -->
<element name="TClassLibrary.cl_Class">
<short>Class pointer</short>
</element>

<!-- constant Visibility: default -->
<element name="GA_Dummy">
<short><link id="GadgetClass"/> Start Tag.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Left">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Left edge of gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RelRight">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Left edge of gadget, depending on right window border: Left := Win^.Width - this - 1</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Top">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Top edge of gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RelBottom">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Top edge of gadget, depending on bottom window border: Top := Win^.Height - this - 1</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Width">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Width of gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RelWidth">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Width of gadget, depending on window width: Width := Win^.Width - this</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Height">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Height of gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RelHeight">
<short><link id="GadgetClass"/> Tag. [ISG] (LongInt) Height of gadget, depending on window height: Height := Win^.Height - this</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Text">
<short><link id="GadgetClass"/> Tag. [IS.] (PChar) Label text. This is mutually exclusive with GA_IntuiText and GA_LabelImage.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Image">
<short><link id="GadgetClass"/> Tag. (<link id="PImage">PImage</link>) Gadget imagry is an image </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Border">
<short><link id="GadgetClass"/> Tag. (<link id="PBorder"/>) Gadget imagry is a border</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_SelectRender">
<short><link id="GadgetClass"/> Tag. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Highlight">
<short><link id="GadgetClass"/> Tag. [IS.] (<link id="PImage">PImage</link>) Gadgets' image in selected state.</short>
<descr>
  Note that if
  this is nil and <link id="GA_Image"/> is in fact an image object, <link id="GA_Image"/> may be
  tried to be drawn with <link id="IDS_SELECTED"/>. So you do not need to fill this in,
  if you wish to have a special selected image and <link id="GA_Image"/> is an image
  object that supports the selected state.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Disabled">
<short><link id="GadgetClass"/> Tag. [IS.] (LongWord) Takes GFLG_GADGH* flags as argument. Used to specify the highlighting technique.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_GZZGadget">
<short><link id="GadgetClass"/> Tag. [ISG] (LongBool) If this is set to true, the gadget is not selectable.</short>
<descr>
Often this is visually represented by using a special disabled pattern.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_ID">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) The Gadget is a GimmeZeroZero gadget. Default = False</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_UserData">
<short><link id="GadgetClass"/> Tag. (LongInt) Gadget ID assigned by the application (prevent double numbers)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_SpecialInfo">
<short><link id="GadgetClass"/> Tag. [ISG] (IPTR) Fill with whatever you want to. This field is ignored by the system.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Selected">
<short><link id="GadgetClass"/> Tag. (APTR) Pointer to additional information</short>
<descr>
  Needed by some gadgets
  (like string or integer gadgets). This field should generally only be set
  by subclasses of GadgetClass. Applications should keep their hands off it.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_EndGadget">
<short><link id="GadgetClass"/> Tag. [ISG] (LongBool) Indicate whether the gadget is selected or not. Default = False</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Immediate">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) Only used for requester gadgets. Default = False</short>
<descr>
This tells intuition that the requester is to be closed, when the gadget is released.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RelVerify">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) If set the gadget responds immediatly, when the gadget is selected. Default = False</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_FollowMouse">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) If this is set, the gadget receives information about the movement of the mouse as long as it is activated. Default = False</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RightBorder">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) Indicate whether the gadget is in the right border or not. Default = False.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_LeftBorder">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) Indicate whether the gadget is in the left border or not. Default = False.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_TopBorder">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) Indicate whether the gadget is in the top border or not. Default = False.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_BottomBorder">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) Indicate whether the gadget is in the bottom border or not. Default = False.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_ToggleSelect">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) Indicate whether the gadget is toggle-selected or not.  Default = False. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_SysGadget">
<short><link id="GadgetClass"/> private Tag. [IS.] (LongBool) Set, if gadget is a system-gadget e.g. a standard window border gadget. Default = False.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_SysGType">
<short><link id="GadgetClass"/> private Tag. [IS.] (LongWord) Reserved for system use to indicate the gadget type.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Previous">
<short><link id="GadgetClass"/> Tag. [I..] (<link id="PGadget"/>) Pointer to previous gadget.</short>
<descr>
This is used to link
the current gadget into a gadget list, before this list is used. It can
not be used to add a gadget to a list of an open window or requester!
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Next">
<short><link id="GadgetClass"/> Tag. [I..] (<link id="PGadget"/>) Next gadget in the linked list. Currently not implemented.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_DrawInfo">
<short><link id="GadgetClass"/> Tag. [I..] (<link id="PDrawInfo"/>) Some gadgets need a DrawInfo structure to be able to perform correct rendering.</short>
<descr>
Read the documentation of the
subclasses to learn, which need this attribute. To be on the safe side,
you can always supply it.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_IntuiText">
<short><link id="GadgetClass"/> Tag. [IS.] (<link id="PIntuiText"/>) Label is an IntuiText.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_LabelImage">
<short><link id="GadgetClass"/> Tag. [IS.] (<link id="PObject_"/>) Label is an image object. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_TabCycle">
<short><link id="GadgetClass"/> Tag. [IS.] (LongBool) If set to true that gadget participates in TAB handling, i.e. if tab is pressed, the next gadget is activated.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_GadgetHelp">
<short><link id="GadgetClass"/> Tag. [..G] (LongBool) If this is set by the gadget, the sends GADGETHELP messages.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Bounds">
<short><link id="GadgetClass"/> Tag. [IS.] (<link id="PIBox">PIBox</link>) Bounds to be copied into the ExtGadget structure.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_RelSpecial">
<short><link id="GadgetClass"/> Tag. [IS.] (LongInt) This attribute should only be set by subclasses of GadgetClass.</short>
<descr>
Applications should keep their hands away!
If set this means, that <link id="GM_LAYOUT"/> is called, when the window it is in is
opened or its size changes. This allows gadgets to make their own size
dependent on the size of the window.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_TextAttr">
<short><link id="GadgetClass"/> Tag. [IS.] (<link id="agraphics.PTextAttr">PTextAttr</link>) Indicate the font to use for the gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_ReadOnly">
<short><link id="GadgetClass"/> Tag. (LongBool) Indicate that the gadget is read-only (non-selectable). Default = False</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_Underscore">
<short><link id="GadgetClass"/> Tag. (Char) Underscore/escape character for keyboard shortcuts. Defaults = '_'</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_ActivateKey">
<short><link id="GadgetClass"/> Tag. (PChar) Set/Get the gadgets shortcut/activation key(s) Default = nil</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_BackFill">
<short><link id="GadgetClass"/> Tag. (<link id="utility.PHook">PHook</link>) Backfill pattern hook. Defaults to nil.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_GadgetHelpText">
<short><link id="GadgetClass"/> Tag. (PChar) RESERVERD/PRIVATE DO NOT USE. Default = nil</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GA_UserInput">
<short><link id="GadgetClass"/> Tag. (LongBool) Notification tag indicates this notification is from the activite gadget receiving user input - an attempt to make IDCMPUPDATE more efficient.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_Dummy">
<short><link id="PropGClass"/> Start Tag. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_Freedom">
<short><link id="PropGClass"/> Tag. [IS.] (LongWord) Define in which the direction gadget should stretch.</short>
<descr>
Possible values are <link id="FREEVERT"/> and <link id="FREEHORIZ"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_Borderless">
<short><link id="PropGClass"/> Tag. (LongBool) If set, no border will be rendered.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_HorizPot">
<short><link id="PropGClass"/> Tag. [ISG] (Word) Should not be used with <link id="PGA_Total"/>, <link id="PGA_Visible"/> and <link id="PGA_Top"/>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_HorizBody">
<short><link id="PropGClass"/> Tag. [ISG] (Word) Should not be used with <link id="PGA_Total"/>, <link id="PGA_Visible"/> and <link id="PGA_Top"/>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_VertPot">
<short><link id="PropGClass"/> Tag. [ISG] (Word) Should not be used with <link id="PGA_Total"/>, <link id="PGA_Visible"/> and <link id="PGA_Top"/>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_VertBody">
<short><link id="PropGClass"/> Tag. [ISG] (Word) Should not be used with <link id="PGA_Total"/>, <link id="PGA_Visible"/> and <link id="PGA_Top"/>. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_Total">
<short><link id="PropGClass"/> Tag. [IS.] (Word) The total number of positions in the gadget.</short>
<descr>
Should not be used with <link id="PGA_HorizPot"/>, <link id="PGA_HorizBody"/>, <link id="PGA_VertPot"/> and <link id="PGA_VertBody"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_Visible">
<short><link id="PropGClass"/> Tag. [IS.] (Word) The number of visible positions in the gadget.</short>
<descr>
Should not be used with <link id="PGA_HorizPot"/>, <link id="PGA_HorizBody"/>, <link id="PGA_VertPot"/> and <link id="PGA_VertBody"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_Top">
<short><link id="PropGClass"/> Tag. [ISG] (Word) The first visible position.</short>
<descr>
Should not be used with <link id="PGA_HorizPot"/>, <link id="PGA_HorizBody"/>, <link id="PGA_VertPot"/> and <link id="PGA_VertBody"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PGA_NewLook">
<short><link id="PropGClass"/> Tag. [IS.] (LongBool) If set, this indicated that the new look should be used for rendering.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_Dummy">
<short><link id="StrgClass"/> Start Tag. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_MaxChars">
<short><link id="StrgClass"/> Tag. [I..] (SmallInt) Maximum number of characters the string gadget accepts. Default SG_DEFAULTMAXCHARS.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_Buffer">
<short><link id="StrgClass"/> Tag. [I..] (STRPTR) Buffer for storing the current string of the gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_UndoBuffer">
<short><link id="StrgClass"/> Tag. [I..] (STRPTR) Buffer for storing the old (undo) string of the gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_WorkBuffer">
<short><link id="StrgClass"/> Tag. [I..] (STRPTR) Buffer for the class to work with.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_BufferPos">
<short><link id="StrgClass"/> Tag. [IS.] (SmallInt) Current position of cursor (relative to the beginning of the buffer).</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_DispPos">
<short><link id="StrgClass"/> Tag. [IS.] (SmallInt) FIXME</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_AltKeyMap">
<short><link id="StrgClass"/> Tag. [IS.] (<link id="keymap.PKeyMap">PKeyMap</link>) KeyMap to use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_Font">
<short><link id="StrgClass"/> Tag. [IS.] (<link id="Agraphics.PTextFont">PTextFont</link>) Font to use for displaying the string</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_Pens">
<short><link id="StrgClass"/> Tag. [IS.] (LongInt) The lower 16 bits specify the background-pen, the upper 16 bits the foreground-pen. The gadget is rendered, using these pens, if the gadget is inactive</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_ActivePens">
<short><link id="StrgClass"/> Tag. [IS.] (LongInt) Like <link id="STRINGA_Pens"/>. These pens are used, if the gadget is active. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_EditHook">
<short><link id="StrgClass"/> Tag. [I..] (<link id="utility.PHook">PHook</link>) FIXME</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_EditModes">
<short><link id="StrgClass"/> Tag. [IS.] (LongWord) FIXME</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_ReplaceMode">
<short><link id="StrgClass"/> Tag. [IS.] (LongBool) If this is True, the current character is overwritten, if the use presses a key. Otherwise, the new character is inserted.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_FixedFieldMode">
<short><link id="StrgClass"/> Tag. [IS.] (LongBool) FIXME</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_NoFilterMode">
<short><link id="StrgClass"/> Tag. [IS.] (LongBool) FIXME</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_Justification">
<short><link id="StrgClass"/> Tag. [IS.] (Word) Where should the text be justified? </short>
<descr>
Use one of <link id="GACT_STRINGCENTER"/>, <link id="GACT_STRINGLEFT"/> and <link id="GACT_STRINGRIGHT"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_LongVal">
<short><link id="StrgClass"/> Tag. [ISG] (LongInt) If this is set, the string gadget will only accept numeric values.</short>
<descr>
Argument is the number, the string gadget is to be set to. When getting this attribute, this number is returned.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_TextVal">
<short><link id="StrgClass"/> Tag. [ISG] (STRPTR) If this is set, the string gadget will accept strings.</short>
<descr>
Argument is a string that is to be copied into the string gadget and its buffer.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="STRINGA_ExitHelp">
<short><link id="StrgClass"/> Tag. [IS.] (LongBool) If this is set, pressing the "Help" key, while the gadget is active, will unselect the gadget.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SG_DEFAULTMAXCHARS">
<short>Maximal length of text in <link id="StrgClass"/>, if <link id="STRINGA_MaxChars"/> is not set.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LAYOUTA_Dummy">
<short><link id="GadgetClass"/> Layout start Tag. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LAYOUTA_LayoutObj">
<short><link id="GadgetClass"/> Layout Tag. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LAYOUTA_Spacing">
<short><link id="GadgetClass"/> Layout Tag. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LAYOUTA_Orientation">
<short><link id="GadgetClass"/> Layout Tag. (LongInt) Orientation LORIENT_*</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LAYOUTA_ChildMaxWidth">
<short><link id="GadgetClass"/> Layout Tag. (LongBool) Child objects are of equal width. Should default to True for gadgets with a horizontal orientation.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LAYOUTA_ChildMaxHeight">
<short><link id="GadgetClass"/> Layout Tag. (LongBool) Child objects are of equal height. Should default to True for gadgets with a vertical orientation.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LORIENT_NONE">
<short>Orientation values for <link id="LAYOUTA_Orientation"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LORIENT_HORIZ">
<short>Orientation values for <link id="LAYOUTA_Orientation"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LORIENT_VERT">
<short>Orientation values for <link id="LAYOUTA_Orientation"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_Dummy">
<short><link id="GadgetClass"/> Method IDs Start</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_HITTEST">
<short><link id="GadgetClass"/> Method ID. Returns <link id="GMR_GADGETHIT"/> if you are clicked on (whether or not you are disabled).</short>
<descr>
  This method is used to test, if a mouse-click hit the gadget. You return
  <link id="GMR_GADGETHIT"/>, if you were hit and 0 otherwise. Note that you
  have to test, if you were hit, no matter if you are disabled or not.
</descr>
<seealso>
<link id="PgpHitTest"/>
<link id="TgpHitTest"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_RENDER">
<short><link id="GadgetClass"/> Method ID. Draw yourself, in the appropriate state</short>
<descr>This method is invoked to draw the gadget into a rastport.
</descr>
<seealso>
<link id="PgpRender"/>
<link id="TgpRender"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_GOACTIVE">
<short><link id="GadgetClass"/> Method ID. You are now going to be fed input</short>
<descr>
  Tells the gadget that it has become active and will receive
  input from now on from the method <link id="GM_HANDLEINPUT"/>. This is stopped by using
  <link id="GM_GOINACTIVE"/>.
</descr>
<seealso>
<link id="PgpInput"/>
<link id="TgpInput"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_HANDLEINPUT">
<short><link id="GadgetClass"/> Method ID. </short>
<descr>
  <link id="GM_GOACTIVE"/> tells the gadget that it has become active and will receive
   input from now on from the method <i>>GM_HANDLEINPUT</i>. This is stopped by using
   <link id="GM_GOINACTIVE"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_GOINACTIVE">
<short><link id="GadgetClass"/> Method ID. Whether or not by choice, you are done</short>
<descr>
</descr>
<seealso>
<link id="PgpGoInactive"/>
<link id="TgpGoInactive"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_HELPTEST">
<short><link id="GadgetClass"/> Method ID. Will you send gadget help if the mouse is at the specified coordinates?  See below for possible GMR_ values.</short>
<descr>
</descr>
<seealso>
<link id="PgpHitTest"/>
<link id="TgpHitTest"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GM_LAYOUT">
<short><link id="GadgetClass"/> Method ID. Re-evaluate your size based on the GadgetInfo Domain.  Do NOT re-render yourself yet, you will be called when it is time...</short>
<descr>
  This method is called by intuition, if on of the GFLG_REL* flags or one of
  the GA_Rel* attributes is set and the window size changes or you are added to
  a window. In this method you should re-evaluate the size of yourself. You
  are not allowed to do any rendering operation during this method!
</descr>
<seealso>
<link id="PgpLayout"/>
<link id="TgpLayout"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpHitTest">
<short>Pointer to Message parameter passed for <link id="GM_HITTEST"/> or <link id="GM_HELPTEST"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TgpHitTest">
<short>Message parameter passed for <link id="GM_HITTEST"/> or <link id="GM_HELPTEST"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TgpHitTest.MethodID">
<short><link id="GM_HITTEST"/> or <link id="GM_HELPTEST"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpHitTest.gpht_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpHitTest.x">
<short><link id="GM_HELPTEST"/> they are relative to the bounding box (which is often</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpHitTest.y">
<short>equal to the select box).</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpHitTest.gpht_Mouse">
<short>These values are relative to the gadget select box for <link id="GM_HITTEST"/>. For</short>
</element>

<!-- constant Visibility: default -->
<element name="GMR_GADGETHIT">
<short>Result for <link id="GM_HITTEST"/> Hit</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_NOHELPHIT">
<short>Result for <link id="GM_HELPTEST"/> didn't hit</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_HELPHIT">
<short>Result for <link id="GM_HELPTEST"/> Hit, The gadget was hit.</short>
<descr>
The lower word of the Code field of the IntuiMessage will be set to -1.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_HELPCODE">
<short>Result for <link id="GM_HELPTEST"/> Hit, return low Word as code.</short>
<descr>
The gadget was hit. Pass the lower word, returned by this method to the application by using the Code field of the IntuiMessage.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpRender">
<short>Pointer to Message parameter passed for <link id="GM_RENDER"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TgpRender">
<short>Message parameter passed for <link id="GM_RENDER"/></short>
<descr>
This method is invoked to draw the gadget into a rastport.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TgpRender.MethodID">
<short><link id="GM_RENDER"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpRender.gpr_GInfo">
<short>Gadget context</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpRender.gpr_RPort">
<short>all ready for use</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpRender.gpr_Redraw">
<short>might be a "highlight pass" (GREDRAW_*) Not all of these values make sense for all gadgets.</short>
</element>

<!-- constant Visibility: default -->
<element name="GREDRAW_UPDATE">
<short><link id="TgpRender"/>.gpr_Redraw. Incremental update. Some data (e.g. the level of a slider) was updated. Just redraw the necessary parts.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GREDRAW_REDRAW">
<short><link id="TgpRender"/>.gpr_Redraw. Redraw the whole gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GREDRAW_TOGGLE">
<short><link id="TgpRender"/>.gpr_Redraw. Toggle highlight, <b>if</b> applicable </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpInput">
<short>Pointer to Message parameter passed for <link id="GM_GOACTIVE"/> or <link id="GM_HANDLEINPUT"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TgpInput">
<short>Message parameter passed for <link id="GM_GOACTIVE"/> or <link id="GM_HANDLEINPUT"/></short>
<descr>
   <link id="GM_GOACTIVE"/> tells the gadget that it has become active and will receive
   input from now on from the method <link id="GM_HANDLEINPUT"/>. This is stopped by using
   <link id="GM_GOINACTIVE"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.MethodID">
<short><link id="GM_GOACTIVE"/> or <link id="GM_HANDLEINPUT"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.gpi_GInfo">
<short>gadget context</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.gpi_IEvent">
<short>Pointer to the InputEvent that caused the method to be invoked.</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.gpi_Termination">
<short>Pointer to a variable that is to be set by the gadget class, if
<link id="GMR_VERIFY"/> is returned. The lower 16 bits of this value are returned
in the Code field of the IntuiMessage  passed back to the application</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.y">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.gpi_Mouse">
<short>This struct defines the current mouse position, relative to the gadgets' bounding box.</short>
</element>

<!-- variable Visibility: default -->
<element name="TgpInput.gpi_TabletData">
<short>Pointer to TabletData structure or nil,
         if this input event did not originate from a tablet.</short>
</element>

<!-- constant Visibility: default -->
<element name="GMR_MEACTIVE">
<short>Return Flags for <link id="GM_HANDLEINPUT"/> or <link id="GM_GOACTIVE"/> </short>
<descr>
Gadget is still alive.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_NOREUSE">
<short>Return Flags for <link id="GM_HANDLEINPUT"/> or <link id="GM_GOACTIVE"/></short>
<descr>
Gadget has become inactive, but the input event may not be used again.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_REUSE">
<short>Return Flags for <link id="GM_HANDLEINPUT"/> or <link id="GM_GOACTIVE"/></short>
<descr>
Gadget has become inactive, and the input event may be reused by intuition.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_VERIFY">
<short>Return Flags for <link id="GM_HANDLEINPUT"/> or <link id="GM_GOACTIVE"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_NEXTACTIVE">
<short>Return Flags for <link id="GM_HANDLEINPUT"/> or <link id="GM_GOACTIVE"/> Activate next gadget.</short>
<descr>the gadget has become
    inactive, but the next or previous gadget, which has the <link id="GFLG_TABCYCLE"/> flag
    set is to be activated.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_PREVACTIVE">
<short>Return Flags for <link id="GM_HANDLEINPUT"/> or <link id="GM_GOACTIVE"/> Activate previous gadget.</short>
<descr>the gadget has become
    inactive, but the next or previous gadget, which has the <link id="GFLG_TABCYCLE"/> flag
    set is to be activated.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpGoInactive">
<short>Pointer to Message parameter passed for <link id="GM_GOINACTIVE"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TgpGoInactive">
<short>Message parameter passed for <link id="GM_GOINACTIVE"/></short>
<descr>See <link id="GM_GOACTIVE"/>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TgpGoInactive.MethodID">
<short><link id="GM_GOINACTIVE"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpGoInactive.gpgi_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpGoInactive.gpgi_Abort">
<short>Boolean field to indicate, who wanted the gadget to go inactive. If
         this is 1 this method was sent, because intution wants the gadget to
         go inactive, if it is 0, it was the gadget itself that wanted it.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpLayout">
<short>Pointer to Message parameter passed for <link id="GM_LAYOUT"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TgpLayout">
<short>Message parameter passed for <link id="GM_LAYOUT"/></short>
<descr>
This method is called by intuition, if on of the GFLG_REL* flags or one of
the GA_Rel* attributes is set and the window size changes or you are added to
a window. In this method you should re-evaluate the size of yourself. You
are not allowed to do any rendering operation during this method!
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TgpLayout.MethodID">
<short><link id="GM_LAYOUT"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpLayout.gpl_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TgpLayout.gpl_Initial">
<short>Boolean that indicated, if this method was invoked, when you are added
         to a window (True) or if it is called, because the window was resized
         (False).</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICM_Dummy">
<short><link id="icclass"/> Methods start </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICM_SETLOOP">
<short><link id="icclass"/> Method. Set/increment loop counter</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICM_CLEARLOOP">
<short><link id="icclass"/> Method. Clear/decrement loop counter</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICM_CHECKLOOP">
<short><link id="icclass"/> Method. Set/increment loop</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICA_Dummy">
<short>Interconnection attributes start used by <link id="icclass"/>, <link id="modelclass"/> and <link id="gadgetclass"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICA_TARGET">
<short>Interconnection target used by <link id="icclass"/>, <link id="modelclass"/> and <link id="gadgetclass"/></short>
<descr>see <link id="ICTARGET_IDCMP"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICA_MAP">
<short>interconnection map tagitem list used by <link id="icclass"/>, <link id="modelclass"/> and <link id="gadgetclass"/></short>
<descr>see <link id="ICTARGET_IDCMP"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICSPECIAL_CODE">
<short>a "pseudo-attribute" used by <link id="icclass"/>, <link id="modelclass"/> and <link id="gadgetclass"/></short>
<descr>see <link id="ICTARGET_IDCMP"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICTARGET_IDCMP">
<short></short>
<descr>Normally, the value for <link id="ICA_TARGET"/> is some object pointer,
  but if you specify the special value <i>ICTARGET_IDCMP</i>, notification
  will be send as an <link id="IDCMP_IDCMPUPDATE"/> message to the appropriate window's
  IDCMP port.  See the definition of <link id="IDCMP_IDCMPUPDATE"/>.
  When you specify <link id="ICTARGET_IDCMP"/> for <link id="ICA_TARGET"/>, the map you
  specify will be applied to derive the attribute list that is
  sent with the <link id="IDCMP_IDCMPUPDATE"/> message.  If you specify a map list
  which results in the attribute tag id <link id="ICSPECIAL_CODE"/>, the
  lower sixteen bits of the corresponding <link id="utility.TTagItem">ti_Data</link> value will
  be copied into the Code field of the <link id="IDCMP_IDCMPUPDATE"/> IntuiMessage.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CUSTOMIMAGEDEPTH">
<short>if <link id="TImage"/>.Depth is this, it's a new Image class object</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Dummy">
<short><link id="ImageClass"/> Attributes start.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Left">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Top">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Width">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Height">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_FGPen">
<short><link id="ImageClass"/> Attribute. IA_FGPen also means "PlanePick"</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_BGPen">
<short><link id="ImageClass"/> Attribute. IA_BGPen also means "PlaneOnOff"</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Data">
<short><link id="ImageClass"/> Attribute. bitplanes, for classic image, other image classes may use it for other things</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_LineWidth">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Pens">
<short><link id="ImageClass"/> Attribute. pointer to Word pens[], ala <link id="TDrawInfo"/>.Pens, <b>must</b> be terminated by (not 0). Some classes can choose to have this, or <link id="SYSIA_DrawInfo"/>, or both.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Resolution">
<short><link id="ImageClass"/> Attribute. packed Words for x/y resolution into a LongWord ala <link id="TDrawInfo"/>.Resolution</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_APattern">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_APatSize">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Mode">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Font">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Outline">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Recessed">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_DoubleEmboss">
<short><link id="ImageClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_EdgesOnly">
<short><link id="ImageClass"/> Attribute. to specify that the interior of a frame should not be cleared</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSIA_Size">
<short><link id="SysIClass"/> Attribute. SYSISIZE_*</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSIA_Depth">
<short><link id="SysIClass"/> Attribute. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSIA_Which">
<short><link id="SysIClass"/> Attribute. System image identifier</short>
<descr>
Specifies which system gadget you want an image for. Some numbers correspond to internal Intuition
</descr>
<seealso>
<link id="DEPTHIMAGE"/>
<link id="ZOOMIMAGE"/>
<link id="SIZEIMAGE"/>
<link id="CLOSEIMAGE"/>
<link id="SDEPTHIMAGE"/>
<link id="LEFTIMAGE"/>
<link id="UPIMAGE"/>
<link id="RIGHTIMAGE"/>
<link id="DOWNIMAGE"/>
<link id="CHECKIMAGE"/>
<link id="MXIMAGE"/>
<link id="MENUCHECK"/>
<link id="AMIGAKEY"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSIA_DrawInfo">
<short><link id="SysIClass"/> Attribute. Must be specified</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSIA_ReferenceFont">
<short><link id="SysIClass"/> Attribute. Font to use as reference for scaling certain sysiclass images</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_SupportsDisable">
<short><link id="SysIClass"/> Attribute. Tell intuition to use IDS_*DISABLED instead of own code</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_FrameType">
<short><link id="SysIClass"/> Attribute. <link id="FrameIClass"/> recognizes several standard types of frame. </short>
<descr>
 Use one of the FRAME_* specifiers below.  Default = <link id="FRAME_DEFAULT"/>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSISIZE_MEDRES">
<short>Data value for <link id="SYSIA_Size"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSISIZE_LOWRES">
<short>Data value for <link id="SYSIA_Size"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SYSISIZE_HIRES">
<short>Data value for <link id="SYSIA_Size"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DEPTHIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Window depth gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ZOOMIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Window zoom gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SIZEIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Window sizing gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CLOSEIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Window close gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SDEPTHIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Screen depth gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LEFTIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Left-arrow gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UPIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Up-arrow gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RIGHTIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Right-arrow gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DOWNIMAGE">
<short><link id="SYSIA_Which"/> tag data values. Down-arrow gadget image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="CHECKIMAGE">
<short><link id="SYSIA_Which"/> tag data values. GadTools checkbox image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MXIMAGE">
<short><link id="SYSIA_Which"/> tag data values. GadTools mutual exclude "button" image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MENUCHECK">
<short><link id="SYSIA_Which"/> tag data values. Menu checkmark image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AMIGAKEY">
<short><link id="SYSIA_Which"/> tag data values. Menu Amiga-key image</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FRAME_DEFAULT">
<short>Data value for <link id="IA_FrameType"/> The standard V37-type frame, which has thin edges.</short>
<descr>
recognized by <link id="FrameIClass"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FRAME_BUTTON">
<short>Data value for <link id="IA_FrameType"/> Standard button gadget frames, having thicker sides and nicely edged corners.</short>
<descr>recognized by <link id="FrameIClass"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FRAME_RIDGE">
<short>Data value for <link id="IA_FrameType"/> A ridge such as used by standard string gadgets. You can recess the ridge to get a groove image.</short>
<descr>recognized by <link id="FrameIClass"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FRAME_ICONDROPBOX">
<short>Data value for <link id="IA_FrameType"/> A broad ridge which is the standard imagery for areas in AppWindows where icons may be dropped.</short>
<descr>recognized by <link id="FrameIClass"/>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_DRAW">
<short><link id="imageclass"/> message id. draw yourself, with "state" (IDS_*)</short>
<descr>
</descr>
<seealso>
<link id="PimpDraw"/>
<link id="TimpDraw"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_HITTEST">
<short><link id="imageclass"/> message id. return True if click hits image</short>
<descr>
</descr>
<seealso>
<link id="PimpHitTest"/>
<link id="TimpHitTest"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_ERASE">
<short><link id="imageclass"/> message id. erase yourself</short>
<descr>
</descr>
<seealso>
<link id="PimpErase"/>
<link id="TimpErase"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_MOVE">
<short><link id="imageclass"/> message id. draw new and erase old, smoothly</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_DRAWFRAME">
<short><link id="imageclass"/> message id. draw with specified dimensions</short>
<descr>
</descr>
<seealso>
<link id="PimpDraw"/>
<link id="TimpDraw"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_FRAMEBOX">
<short><link id="imageclass"/> message id. get recommended frame around some box</short>
<descr>
</descr>
<seealso>
<link id="PimpFrameBox"/>
<link id="TimpFrameBox"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_HITFRAME">
<short><link id="imageclass"/> message id. hittest with dimensions</short>
<descr>
</descr>
<seealso>
<link id="PimpHitTest"/>
<link id="TimpHitTest"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_ERASEFRAME">
<short><link id="imageclass"/> message id. hittest with dimensions</short>
<descr>
</descr>
<seealso>
<link id="PimpErase"/>
<link id="TimpErase"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_NORMAL">
<short>Image draw style for <link id="IM_DRAW"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_SELECTED">
<short>Image draw state for <link id="IM_DRAW"/> for selected gadgets</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_DISABLED">
<short>Image draw state for <link id="IM_DRAW"/> for disabled gadgets</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_BUSY">
<short>Image draw style for <link id="IM_DRAW"/> for future functionality</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_INDETERMINATE">
<short>Image draw style for <link id="IM_DRAW"/> for future functionality</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_INACTIVENORMAL">
<short>Image draw style for <link id="IM_DRAW"/> normal, in inactive window border</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_INACTIVESELECTED">
<short>Image draw style for <link id="IM_DRAW"/> selected, in inactive border</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_INACTIVEDISABLED">
<short>Image draw style for <link id="IM_DRAW"/> disabled, in inactive border</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_SELECTEDDISABLED">
<short>Image draw style for <link id="IM_DRAW"/> disabled and selected</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PimpFrameBox">
<short>Pointer to message argument for <link id="IM_FRAMEBOX"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TimpFrameBox">
<short>Message argument for <link id="IM_FRAMEBOX"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TimpFrameBox.MethodID">
<short><link id="IM_FRAMEBOX"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpFrameBox.imp_ContentsBox">
<short>input: relative box of contents</short>
</element>

<!-- variable Visibility: default -->
<element name="TimpFrameBox.imp_FrameBox">
<short>output: rel. box of encl frame</short>
</element>

<!-- variable Visibility: default -->
<element name="TimpFrameBox.imp_DrInfo">
<short>may be nil</short>
</element>

<!-- variable Visibility: default -->
<element name="TimpFrameBox.imp_FrameFlags">
<short><link id="FRAMEF_SPECIFY"/></short>
</element>

<!-- constant Visibility: default -->
<element name="FRAMEF_SPECIFY">
<short>Flag for <link id="TimpFrameBox"/>.imp_FrameFlags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PimpDraw">
<short>Pointer to message argument for <link id="IM_DRAW"/> or <link id="IM_DRAWFRAME"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TimpDraw">
<short>Message argument for <link id="IM_DRAW"/> or <link id="IM_DRAWFRAME"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TimpDraw.MethodID">
<short><link id="IM_DRAW"/> or <link id="IM_DRAWFRAME"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpDraw.imp_RPort">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpDraw.imp_Offset">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpDraw.imp_State">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpDraw.imp_DrInfo">
<short>May be nil</short>
</element>

<!-- variable Visibility: default -->
<element name="TimpDraw.imp_Dimensions">
<short>Only valid for <link id="IM_DRAWFRAME"/></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PimpErase">
<short>Pointer to message argument for <link id="IM_ERASE"/> or <link id="IM_ERASEFRAME"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TimpErase">
<short>Message argument for <link id="IM_ERASE"/> or <link id="IM_ERASEFRAME"/></short>
<descr>This is a subset of <link id="TimpDraw"/>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TimpErase.MethodID">
<short><link id="IM_ERASE"/> or <link id="IM_ERASEFRAME"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpErase.imp_RPort">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpErase.imp_Offset">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpErase.imp_Dimensions">
<short>Only valid for <link id="IM_DRAWFRAME"/></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PimpHitTest">
<short>Pointer to message argument for <link id="IM_HITTEST"/> or <link id="IM_HITFRAME"/> </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TimpHitTest">
<short>Message argument for <link id="IM_HITTEST"/> or <link id="IM_HITFRAME"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TimpHitTest.MethodID">
<short><link id="IM_HITTEST"/> or <link id="IM_HITFRAME"/></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpHitTest.imp_Point">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TimpHitTest.imp_Dimensions">
<short>only valid for <link id="IM_HITFRAME"/></short>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_Dummy">
<short><link id="PointerClass"/> Attributes start. </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_BitMap">
<short><link id="PointerClass"/> Attribute. (<link id="AGraphics.PBitmap">PBitmap</link>) Pointer to bitmap to get pointer imagery from.  Bitplane data need not be in chip RAM.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_XOffset">
<short><link id="PointerClass"/> Attribute. (LongInt) - X-offset of the pointer hotspot.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_YOffset">
<short><link id="PointerClass"/> Attribute. (LongInt) - Y-offset of the pointer hotspot.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_WordWidth">
<short><link id="PointerClass"/> Attribute. (LongWord) - designed width of the pointer in words</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_XResolution">
<short><link id="PointerClass"/> Attribute. (LongWord) - one of the POINTERXRESN_* flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERA_YResolution">
<short><link id="PointerClass"/> Attribute. (LongWord) - one of the POINTERYRESN_* flags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_DEFAULT">
<short>Value for <link id="POINTERA_XResolution"/> (ECS-compatible pointer width) = 70 ns if <link id="AGraphics.SUPERHIRES">SUPERHIRES</link>-type mode, 140 ns if not</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_140NS">
<short>Value for <link id="POINTERA_XResolution"/> (pointer always in 140 ns pixels) = 140 ns always</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_70NS">
<short>Value for <link id="POINTERA_XResolution"/> (pointer always in 70 ns pixels) = 70 ns always</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_35NS">
<short>Value for <link id="POINTERA_XResolution"/> (pointer always in 35 ns pixels) = 35 ns always</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_SCREENRES">
<short>Value for <link id="POINTERA_XResolution"/> Same as pixel speed of screen</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_LORES">
<short>Value for <link id="POINTERA_XResolution"/> (pointer always in lores-like pixels) = 140 ns in 15kHz modes, 70 ns in 31kHz modes</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERXRESN_HIRES">
<short>Value for <link id="POINTERA_XResolution"/> (pointer always in hires-like pixels) = 70 ns in 15kHz modes, 35 ns in 31kHz modes</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERYRESN_DEFAULT">
<short>Value for <link id="POINTERA_YResolution"/> Default pointer</short>
<descr>
  In 15 kHz modes, the pointer resolution will be the same
  as a non-interlaced screen.  In 31 kHz modes, the pointer
  will be doubled vertically.  This means there will be about
  200-256 pointer lines per screen.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERYRESN_HIGH">
<short>Value for <link id="POINTERA_YResolution"/> Highres pointer</short>
<descr>

</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERYRESN_HIGHASPECT">
<short>Value for <link id="POINTERA_YResolution"/> Highres pointer</short>
<descr>
  Where the hardware/software supports it, the pointer resolution
  will be high.  This means there will be about 400-480 pointer
  lines per screen.
  When the pointer comes out double-height due to hardware/software
  restrictions, its width would be doubled as well, if possible
  (to preserve aspect).
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERYRESN_SCREENRES">
<short>Value for <link id="POINTERA_YResolution"/> Highres pointer</short>
<descr>
  Will attempt to match the vertical resolution of the pointer
  to the screen's vertical resolution.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="POINTERYRESN_SCREENRESASPECT">
<short>Value for <link id="POINTERA_YResolution"/> Highres pointer</short>
<descr>
  Will attempt to match the vertical resolution of the pointer
  to the screen's vertical resolution.
  When the pointer comes out double-height due to
  hardware/software restrictions, its width would be doubled as well,
  if possible (to preserve aspect).
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PSGWork">
<short>Pointer to String gadget message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TSGWork">
<short>String gadget message</short>
<descr>
  The local (application) hook may only change the Code, Actions,
  WorkBuffer, NumChars, BufferPos and LongInt fields.  None of the other
  fields in the TSGWork structure may be modified.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.Gadget">
<short>the contestant itself</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.StringInfo">
<short>easy access to sinfo</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.WorkBuffer">
<short>intuition's planned result</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.PrevBuffer">
<short>what was there before</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.Modes">
<short>current mode (SGM_*)</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.IEvent">
<short>actual event: do not change</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.Code">
<short>character code, <b>if</b> one Byte</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.BufferPos">
<short>cursor position</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.NumChars">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.Actions">
<short>what Intuition will do</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.LongInt_">
<short>temp storage for LongInt</short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.GadgetInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="TSGWork.EditOp">
<short>from constants below</short>
</element>

<!-- constant Visibility: default -->
<element name="EO_NOOP">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>did nothing
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_DELBACKWARD">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>deleted some chars (maybe 0).
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_DELFORWARD">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>deleted some characters under and in front of the cursor
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_MOVECURSOR">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>moved the cursor
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_ENTER">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>"enter" or "return" key, terminate
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_RESET">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>current Intuition-style undo
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_REPLACECHAR">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>replaced one character and (maybe) advanced cursor
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_INSERTCHAR">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>inserted one char into string or added one at end
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_BADFORMAT">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>didn't like the text data, e.g., Bad LONGINT
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_BIGCHANGE">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>unused by Intuition complete or major change to the text, e.g. new string
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_UNDO">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>unused by Intuition  some other style of undo
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_CLEAR">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>clear the string
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="EO_SPECIAL">
<short>Value for <link id="TSGWork"/>.EditOp </short>
<descr>unused by Intuition some operation that doesn't fit into the categories here
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_REPLACE">
<short>Mode for <link id="TSGWork"/>.Mode replace mode please initialize <link id="TSGWork">StringInfo</link> with in-range value of <link id="TSGWork">BufferPos</link> if you are using <i>SGM_REPLACE</i> mode.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_FIXEDFIELD">
<short>Mode for <link id="TSGWork"/>.Mode fixed length buffer always set <link id="SGM_REPLACE"/>, too</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_NOFILTER">
<short>Mode for <link id="TSGWork"/>.Mode don't filter control chars</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_EXITHELP">
<short>Mode for <link id="TSGWork"/>.Mode exit with code = $5F <b>if help</b> hit</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_NOCHANGE">
<short>Internal Mode for <link id="TSGWork"/>.Mode no edit changes yet</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_NOWORKB">
<short>Internal Mode for <link id="TSGWork"/>.Mode Buffer = PrevBuffer</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_CONTROL">
<short>Internal Mode for <link id="TSGWork"/>.Mode control char escape mode</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGM_LONGINT">
<short>Internal Mode for <link id="TSGWork"/>.Mode an intuition LongInt gadget</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_USE">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions use contents of <link id="TSGWork"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_END">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions terminate gadget, code in Code field</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_BEEP">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions flash the screen for the user</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_REUSE">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions reuse input event</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_REDISPLAY">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions gadget visuals changed</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_NEXTACTIVE">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions Make next possible gadget active.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGA_PREVACTIVE">
<short>String Gadget Action Flag in <link id="TSGWork"/>.Actions Make previous possible gadget active.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGH_KEY">
<short>Function id for only existing custom string gadget edit hook. process editing keystroke</short>
<descr>
<p>There are no parameters following the command LongWord. Intuition will put its idea of proper values in the <link id="TSGWork"/>
   before calling you, and if you leave <link id="SGA_USE"/> set in the <link id="TSGWork"/>.Actions field, Intuition will use the values
   found in <link id="TSGWork"/> fields <i>WorkBuffer, NumChars, BufferPos,</i> and <i>LongInt_</i>, copying the <i>WorkBuffer</i> back to the <i>StringInfo</i>
   Buffer.</p>
<p>
  <b>Note</b>: You may <b>not</b> change other <link id="TSGWork"/> fields. If you clear <link id="SGA_USE"/>,
  the string gadget will be unchanged.</p>
<p>
  If you set <link id="SGA_END"/>, Intuition will terminate the activation of the string gadget.  If you also set <link id="SGA_REUSE"/>, Intuition
  will reuse the input event after it deactivates your gadget. In this case, Intuition will put the value found in <link id="TSGWork"/>.Code
  into the <link id="TIntuiMessage"/>.Code field of the <link id="IDCMP_GADGETUP"/> message it sends to the application.</p>
<p>
  If you set <link id="SGA_BEEP"/>, Intuition will call <link id="DisplayBeep">DisplayBeep()</link> use this if the user has typed in error, or buffer is full.</p>
<p>
  Set <link id="SGA_REDISPLAY"/> if the changes to the gadget warrant a gadget redisplay.  <b>Note</b>: cursor movement requires a redisplay.
  You may set <link id="SGA_PREVACTIVE"/> or <link id="SGA_NEXTACTIVE"/> when you set <link id="SGA_END"/>.  This tells Intuition that you want
  the next or previous gadget with <link id="GFLG_TABCYCLE"/> to be activated.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGH_CLICK">
<short>Function id for only existing custom string gadget edit hook. process mouse click cursor position </short>
<descr>
<p>This hook command is called when Intuition wants to position the cursor in response to a mouse click in the string gadget.
   Again, here are no parameters following the command LongWord. This time, Intuition has already calculated the mouse position
   character cell and put it in <link id="TSGWork"/>.BufferPos. The previous BufferPos value remains in the <link id="TSGWork"/>.StringInfo.BufferPos.</p>
<p>
   Intuition will again use the <link id="TSGWork"/> fields listed above for <link id="SGH_KEY"/>.  One restriction is that you are <b>not</b> allowed to set
   <link id="SGA_END"/> or <link id="SGA_REUSE"/> for this command. Intuition will not stand for a gadget which goes inactive when you click in it.</p>
<p>
   You should always leave the <link id="SGA_REDISPLAY"/> flag set, since Intuition uses this processing when activating a string gadget.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="IntuitionBase">
<short>Library Base for intuition.library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ActivateGadget">
<short>Activate a (string or custom) gadget.</short>
<descr>
<p>Activates a string or custom gadget.  If successful, this means
  that the user does not need to click in the gadget before typing.</p>
<p>
  The window parameter must point to the window which contains the gadget.
  If the gadget is actually in a requester, the window must contain
  the requester, and a pointer to the requester must also be
  passed. The requester parameter must only be valid if the gadget
  has the <link id="GTYP_REQGADGET"/> flag set, a requirement for all requester
  gadgets.</p>
<p>
  The success of this function depends on a rather complex set
  of conditions.  The intent is that the user is never interrupted from
  what interactions he may have underway.</p>
<p>
  The current set of conditions includes:</p>
<ul>
  <li>The window must be active.  If you are opening a new window
      and want an active gadget in it, it is not sufficient to
      assume that the <link id="WFLG_ACTIVATE"/> flag has taken effect by the time
      <link id="OpenWindow">OpenWindow()</link> returns, even if you insert a delay of some
      finite amount of time.  Use the <link id="IDCMP_ACTIVEWINDOW"/> IntuiMessage
      to tell when your window really becomes active.  Many
      programs use an event loop that calls <i>ActivateGadget()</i>
      whenever they receive the <link id="IDCMP_ACTIVEWINDOW"/> message, and also
      the <link id="IDCMP_MOUSEBUTTONS"/> messages, and so on, to keep the
      gadget active until it is used (or the user selects some
      other "Cancel" gadget).</li>
  <li>No other gadgets may be in use.  This includes system gadgets,
      such as those for window sizing, dragging, etc.</li>
  <li>If the gadget is in a requester, that requester must
      be active. (Use <link id="IDCMP_REQSET"/> and <link id="IDCMP_REQCLEAR"/>).</li>
  <li>The right mouse button cannot be held down (e.g. menus)</li>
</ul>
<p><b>Note:</b> Don't try to activate a gadget which is disabled or
  not attached to a window or requester.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ActivateGadget.Result">
<short>If the conditions are met, and the gadget is in fact a string
  gadget, then this function will return True, else False.</short>
</element>

<!-- argument Visibility: default -->
<element name="ActivateGadget.Gadget">
<short>A pointer to the gadget that you want activated.</short>
</element>

<!-- argument Visibility: default -->
<element name="ActivateGadget.Window">
<short>A pointer to a window structure containing the gadget.</short>
</element>

<!-- argument Visibility: default -->
<element name="ActivateGadget.Requester">
<short>A pointer to a requester (may by nil if this isn't a requester gadget
(i.e. <link id="GTYP_REQGADGET"/> is not set)).</short>
</element>

<!-- procedure Visibility: default -->
<element name="ActivateWindow">
<short>Activate an Intuition window.</short>
<descr>
<p>
  Note that this call may have its action deferred: you cannot assume
  that when this call is made the selected window has become active.
  This action will be postponed while the user plays with gadgets and
  menus, or sizes and drags windows.  You may detect when the window
  actually has become active by the <link id="IDCMP_ACTIVEWINDOW"/> IDCMP message.</p>
<p>
  This call is intended to provide flexibility but not to confuse the
  user.  Please call this function synchronously with some action
  by the user.</p>
</descr>
<errors>
If the user has an autopointer tool (sunmouse), the call will
succeed, but the tool will deactivate the window right after
this function has activated it. It is not a good idea to try to
prevent this by waiting for <link id="IDCMP_INACTIVEWINDOW"/> and activating
the window again since that will produce an annoying flicker and
it will slow down the computer a lot.
</errors>
<seealso>
<link id="ModifyIDCMP"/>
<link id="OpenWindow"/>
<link id="CloseWindow"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ActivateWindow.Window">
<short>The window to activate</short>
</element>

<!-- procedure Visibility: default -->
<element name="AddClass">
<short>Make a public class available</short>
<descr>
  Adds a public boopsi class to the internal list of classes available
  for public consumption.
  You must call this function after you call <link id="MakeClass">MakeClass()</link>.
  Do not use this function for private classes.
</descr>
<errors>
There is no protection against creating multiple classes with
the same name yet. The operation of the system is undefined
in this case.
</errors>
<seealso>
<link id="MakeClass"/>
<link id="FreeClass"/>
<link id="RemoveClass"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="AddClass.ClassPtr">
<short>The result of <link id="MakeClass">MakeClass()</link></short>
</element>

<!-- function Visibility: default -->
<element name="AddGadget">
<short>Add a gadget to the gadget list of a window.</short>
<descr>
<p>Adds the specified gadget to the gadget list of the given window,
  linked in at the position in the list specified by the position
  argument (that is, if Position == 0, the gadget will be inserted
  at the head of the list, and if Position == 1 then the gadget will
  be inserted after the first gadget and before the second).  If the
  position you specify is greater than the number of gadgets in the
  list, your gadget will be added to the end of the list.</p>
<p>
  Calling <i>AddGadget()</i> does not cause your gadget to be redisplayed.
  The benefit of this is that you may add several gadgets without
  having the gadget list redrawn every time.</p>
<p>
  This procedure returns the position at which your gadget was added.</p>
<p>
  <b>Note:</b> A relatively safe way to add the gadget to the end of the
  list is to specify a position of -1 (i.e. Word $FFFF).  That way,
  only the 65536th (and multiples of it) will be inserted at the wrong
  position.  The return value of the procedure will tell you where it was
  actually inserted.</p>
<p>
  <b>Note:</b> The system window gadgets are initially added to the
  front of the gadget list.  The reason for this is:  If you position
  your own gadgets in some way that interferes with the graphical
  representation of the system gadgets, the system's ones will be "hit"
  first by user.  If you then start adding gadgets to the front of the
  list, you will disturb this plan, so beware.  On the other hand, if
  you don't violate the design rule of never overlapping your gadgets,
  there's no problem.</p>
<p>
  <b>Note:</b> You may not add your own gadgets to a screen.  Gadgets may
  be added to backdrop windows, however, which can be visually similar,
  but also provide an IDCMP channel for gadget input messages.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AddGList"/>
<link id="RemoveGadget"/>
<link id="RemoveGList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddGadget.Result">
<short>Returns the position of where the gadget was actually added.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGadget.Window">
<short>A pointer to the window to get your gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGadget.Gadget">
<short>A pointer to the new gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGadget.Position">
<short>Integer position in the list for the new gadget (starting
      from zero as the first position in the list)</short>
</element>

<!-- function Visibility: default -->
<element name="AddGList">
<short>Add a linked list of gadgets to a window or requester.</short>
<descr>
<p>Adds the list of gadgets to the gadget list of the given window
  or requester linked in at the position in the list specified by
  the position argument.</p>
<p>
  See <link id="AddGadget">AddGadget()</link> for more information about gadget list position,
  and more information about gadgets in general.</p>
<p>
  The requester parameter will be ignored unless the <link id="GTYP_REQGADGET"/>
  bit is set in the GadgetType field of the first gadget in the list.
  In that case, the gadget list is added to the requester gadgets.</p>
<p>
  <b>Note:</b> be sure that <link id="GTYP_REQGADGET"/> is either set or cleared consistently
  for all gadgets in the list.</p>
<p>
  <b>Note also:</b> The window parameter
  should point to the window that the requester (will) appear in.</p>
<p>
  Will add <i>Numgad</i> gadgets from gadget list linked by the field
  <link id="TGadget"/>.NextGadget, or until some <link id="TGadget"/>.NextGadget field is found to be nil.  Does
  not assume that the <i>Numgad</i>'th gadget has <link id="TGadget"/>.NextGadget equal to nil.</p>
<p>
  <b>Note well:</b> In order to link your gadget list in, the <link id="TGadget"/>.NextGadget
  field of the <i>Numgad</i>'th (or last) gadget will be modified.  Thus, if
  you are adding the first 3 gadgets from a linked list of five gadgets,
  this call will sever the connection between your third and fourth
  gadgets.</p>
<p>The gadgets will just be added. To make them visible, you must
  refresh the window or the gadgets.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AddGadget"/>
<link id="RemoveGadget"/>
<link id="RemoveGList"/>
<link id="RefreshGadgets"/>
<link id="RefreshGList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddGList.Result">
<short>Returns the position of where the first gadget in the list was actually
  added.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGList.Window">
<short>A pointer to the window to get your gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGList.Gadget">
<short>A pointer to the first gadget to be added</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGList.Position">
<short>Integer position in the list for the new gadget
      (starting from zero as the first position in the list)</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGList.NumGad">
<short>The number of gadgets from the linked list to be added
      if Numgad equals -1, the entire nil-terminated list of
      gadgets will be added.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddGList.Requester">
<short>The requester the gadgets will be added to if the
      <link id="GTYP_REQGADGET"/> GadgetType flag is set for the first gadget
      in the list</short>
</element>

<!-- function Visibility: default -->
<element name="AllocRemember">
<short>Allocate Memory with tracking to make freeing easy.</short>
<descr>
<p>This routine calls the Exec AllocMem() function for you, but also links
  the parameters of the allocation into a master list, so that
  you can simply call the Intuition routine FreeRemember() at a later
  time to deallocate all allocated memory without being required to
  remember the details of the memory you've allocated.</p>
<p>
  This routine will have two primary uses:</p>
<ul>
  <li>Let's say that you're doing a long series of allocations in a
      procedure.  If any one of the allocations fails, your program
      may need to abort the procedure.  Abandoning ship correctly
      involves freeing up what memory you've already allocated.  This
      procedure allows you to free up that memory easily, without being
      required to keep track of how many allocations you've already done,
      what the sizes of the allocations were, or where the memory was
      allocated.</li>
  <li>Also, in the more general case, you may do all of the allocations
      in your entire program using this routine.  Then, when your
      program is exiting, you can free it all up at once with a
      simple call to FreeRemember().</li>
</ul>
<p>
  You create the "anchor" for the allocation master list by creating
  a variable that's a pointer to struct Remember, and initializing
  that pointer to NULL.  This is called the RememberKey.  Whenever
  you call AllocRemember(), the routine actually does two memory
  allocations, one for the memory you want and the other for a copy
  of a Remember structure.  The Remember structure is filled in
  with data describing your memory allocation, and it's linked
  into the master list pointed to by your RememberKey.  Then, to
  free up any memory that's been allocated, all you have to do is
  call FreeRemember() with your RememberKey.</p>
<p>
  Please read the FreeRemember() function description, too.  As you will
  see, you can select either to free just the link nodes and keep all the
  allocated memory for yourself, or to free both the nodes and your memory
  buffers.</p>
<p><b>Example:</b></p>
<code>
var
  RememberKey: PRemember;
begin
  RememberKey := nil;
  buffer := AllocRemember(@RememberKey, BUFSIZE, MEMF_CHIP);
  if Assigned(buffer) then
  begin
    // Use the buffer
    //...
  end;
  FreeRemember(@RememberKey, True);
end;
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeRemember"/>
<link id="exec.ExecAllocMem">AllocMem</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AllocRemember.Result">
<short>If the memory allocation is successful, this routine returns the byte
  address of your requested memory block.  Also, the node to your block
  will be linked into the list pointed to by your <i>RememberKey</i> variable.
  If the allocation fails, this routine returns nil and the list pointed
  to by <i>RememberKey</i>, if any, will be unchanged.</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocRemember.RememberKey">
<short>Store information in this list. Must be nil for initial call.</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocRemember.Size">
<short>How many bytes to allocate</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocRemember.Flags">
<short>Attributes (see <link id="Exec.ExecAllocMem">AllocMem()</link>)
</short>
</element>

<!-- function Visibility: default -->
<element name="AllocScreenBuffer">
<short>Get a ScreenBuffer for double-buffering.</short>
<descr>
<p>Allocates a ScreenBuffer structure and usually a BitMap.  This
  structure can be used for double (or multiple) buffering in
  Intuition screens.  You may use this call to obtain a ScreenBuffer
  structure for the screen's initial BitMap, or for other BitMaps
  you intend to swap in.</p>
<p>
  <i>AllocScreenBuffer()</i> also allocates a graphics.library DBufInfo
  structure.  The ScreenBuffer structure this call returns contains
  a pointer to that <link id="AGraphics.TDBufInfo">TDBufInfo</link> structure, which is free for your use.
  See <link id="AGraphics.AllocDBufInfo">AllocDBufInfo()</link> for full details on using
  this structure to achieve notification of when it is safe to
  render into an old buffer and when it is right to switch again.
</p>
<p><b>Flags:</b></p>
<dl>
  <dt><link id="SB_SCREEN_BITMAP"/></dt><dd>to
    get a ScreenBuffer referring to the screen's actual BitMap.
    (For <link id="CUSTOMBITMAP_f">CUSTOMBITMAP</link> screens, just set the BitMap parameter
    to the BitMap you passed to <link id="OpenScreen">OpenScreen()</link>).</dd>
  <dt><link id="SB_COPY_BITMAP"/></dt><dd>If you would like the screen's BitMap
    copied into this ScreenBuffer's BitMap.  This is required
    to get any menu-bar or gadget imagery into each
    ScreenBuffer's BitMap.  If the screen has no Intuition
    rendering, you may omit this flag.  Also, when allocating
    a ScreenBuffer for the screen's initial BitMap, this flag
    should not be set.</dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeScreenBuffer"/>
<link id="ChangeScreenBuffer"/>
<link id="AGraphics.AllocDBufInfo">AllocDBufInfo</link>
<link id="AGraphics.ChangeVPBitMap">ChangeVPBitMap</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AllocScreenBuffer.Result">
<short>Pointer to a valid ScreenBuffer structure, or nil if failure.
  You may render into the resulting BitMap as appropriate.
  You may use the <link id="TScreenBuffer">TScreenBuffer.sb_DBufInfo</link> field to access graphics.library
  ViewPort-buffering features such as learning when it is safe
  to reuse the previous BitMap. If not, you risk writing into
  the on-screen BitMap, which can damage menu or gadget rendering!</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocScreenBuffer.Screen">
<short>A pointer to the screen to double-buffer</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocScreenBuffer.Bitmap">
<short>For <link id="CUSTOMBITMAP_f"/> screens, you may pre-allocate
    a BitMap matching the screen's BitMap's properties, and
    pass that in, to get a ScreenBuffer referring to that
    BitMap.  Set this parameter to nil if you'd prefer
    that Intuition allocate the alternate buffer.  This parameter
    must be nil for non-<link id="CUSTOMBITMAP_f">CUSTOMBITMAP_f</link> screens.</short>
</element>

<!-- argument Visibility: default -->
<element name="AllocScreenBuffer.Flags">
<short>Flags see list SB_*</short>
</element>

<!-- function Visibility: default -->
<element name="AutoRequest">
<short>Automatically build and get response from a requester.</short>
<descr>
<p>This procedure automatically builds a requester for you and then
  waits for a response from the user, or for the system to satisfy your
  request.  If the response is positive, this procedure returns TRUE.
  If the response is negative, this procedure returns FALSE.</p>
<p>
  An IDCMPFlag specification is created by bitwise "or'ing" your
  PosFlags, NegFlags, and the IDCMP classes IDCMP_GADGETUP and
  IDCMP_RAWKEY.  You may specify zero flags for either the PosFlags
  or NegFlags arguments.</p>
<p>
  The IntuiText arguments, and the width and height values, are
  passed directly to the BuildSysRequest() procedure along with
  your window pointer and the IDCMP flags.  Please refer to
  BuildSysRequest() for a description of the IntuiText that you are
  expected to supply when calling this routine.  It's an important
  but long-winded description that need not be duplicated here.</p>
<p>
  If the BuildSysRequest() procedure does not return a pointer
  to a window, it will return TRUE or FALSE (not valid structure
  pointers) instead, and these BOOL values will be returned to
  you immediately.</p>
<p>
  On the other hand, if a valid window pointer is returned, that
  window will have had its IDCMP ports and flags initialized according
  to your specifications.  AutoRequest() then waits for IDCMP messages
  on the UserPort, which satisfies one of four requirements:</p>
<ul>
  <li>Iither the message is of a class that matches
      one of your PosFlags arguments (if you've supplied
      any), in which case this routine returns True.</li>
  <li>or the message class matches one of your NegFlags
      arguments (if you've supplied any), in which case
      this routine returns False.</li>
  <li>or the IDCMP message is of class <link id="IDCMP_GADGETUP"/>, which means that
      one of the two gadgets, as provided with the PosText and NegText
      arguments, was selected by the user.  If the True gadget
      was selected, True is returned.  If the False gadget was
      selected, False is returned.</li>
  <li>Lastly, two <link id="IDCMP_RAWKEY"/> messages may satisfy the request: those
      for the <b>V</b> and <b>B</b> keys with the left Amiga key depressed.
      These keys, satisfy the gadgets on the left or right side of
      the requester--True or False--, respectively.</li>
</ul>
<p>
  When the dust has settled, this routine calls <link id="FreeSysRequest">FreeSysRequest()</link> if
  necessary to clean up the requester and any other allocated memory.</p>
<p>When DOS brings up <i>AutoRequests()</i> on your process (eg.
  "Please insert volume XXX in any drive", they normally come
  up on the Workbench screen.  If you set your Process <link id="amigados.TProcess">pr_WindowPtr</link>
  field to point to one of your windows, then DOS will bring its
  requesters up on the same screen as that window.  A <link id="amigados.TProcess">pr_WindowPtr</link>
  of -1 prevents requesters from coming up at all.
  (Some FileSystem requesters cannot be redirected or supressed).</p>
</descr>
<errors>
</errors>
<seealso>
<link id="EasyRequestArgs"/>
<link id="BuildSysRequest"/>
<link id="SysReqHandler"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AutoRequest.Result">
<short>The return value is either True or False.  See the text above for a
  complete description of the chain of events that might lead to either
  of these values being returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.Window">
<short>A pointer to a Window structure.  See <link id="BuildSysRequest">BuildSysRequest()</link>
      for a full discussion.</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.Body">
<short>A pointer to an TIntuiText structure</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.PosText">
<short>A pointer to an TIntuiText structure, may by nil.</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.NegText">
<short>A pointer to an TIntuiText structure, <b>must</b> be valid!</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.PFlag">
<short>Flags for the IDCMP</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.NFlag">
<short>Flags for the IDCMP</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.Width">
<short>The width to be used for the rendering of the requester</short>
</element>

<!-- argument Visibility: default -->
<element name="AutoRequest.Height">
<short>The height to be used for the rendering of the requester</short>
</element>

<!-- procedure Visibility: default -->
<element name="BeginRefresh">
<short>Sets up a window for optimized refreshing.</short>
<descr>
<p>This routine sets up your window for optimized refreshing.</p>
<p>
  Its role is to provide Intuition integrated access to the Layers
  library function <i>BeginUpdate()</i>.  Its additional contribution is
  to be sure that locking protocols for layers are followed, by
  locking both layers of a <link id="WFLG_GIMMEZEROZERO"/> window only after the
  parent Layer_Info has been locked.  Also, the <link id="WFLG_WINDOWREFRESH"/>
  flag is set in your window, for your information.</p>
<p>
  The purpose of <i>BeginUpdate()</i>, and hence <i>BeginRefresh()</i>, is to
  restrict rendering in a window (layer) to the region that needs
  refreshing after an operation such as window sizing or uncovering.
  This restriction to the "damage region" persists until you call
  <link id="EndRefresh">EndRefresh()</link>.</p>
<p>
  For instance, if you have a <link id="WFLG_SIMPLE_REFRESH"/> window which is
  partially concealed and the user brings it to the front, you can
  receive an <link id="IDCMP_REFRESHWINDOW"/> message asking you to refresh your
  display.  If you call <i>BeginRefresh()</i> before doing any of the
  rendering, then the layer that underlies your window will be arranged
  so that the only rendering that will actually take place will be that
  which goes to the newly-revealed areas.  This is very performance-
  efficient, and visually attractive.</p>
<p>
  After you have performed your refresh of the display, you should call
  <link id="EndRefresh">EndRefresh()</link> to reset the state of the layer and the window.  Then you
  may proceed with rendering to the entire window as usual.</p>
<p>
  You learn that your window needs refreshing by receiving either a
  message of class <link id="IDCMP_REFRESHWINDOW"/> through the IDCMP, or an input
  event of class <link id="inputevent.IECLASS_REFRESHWINDOW">IECLASS_REFRESHWINDOW</link> through the Console device.
  Whenever you are told that your window needs refreshing, you should
  call <i>BeginRefresh()</i> and <link id="EndRefresh">EndRefresh()</link> to clear the refresh-needed
  state, even if you don't plan on doing any rendering.  You may relieve
  yourself of even this burden by setting the <link id="WFLG_NOCAREREFRESH"/> flag
  when opening your window.
</p>
<p><b>Warning:</b></p>
<p>
  You should only perform simple graphics refreshing
  operations between <i>BeginRefresh()</i> and <link id="EndRefresh">EndRefresh()</link>.  These include
  any graphics.library drawing functions or the simple Intuition
  rendering functions (<link id="DrawImage">DrawImage()</link>,
  <link id="PrintIText">PrintIText()</link>, <link id="DrawBorder">DrawBorder()</link>, and
  so on).  In particular, do not call <link id="RefreshGadgets">RefreshGadgets()</link>, <link id="RefreshGList">RefreshGList()</link>,
  <link id="RefreshWindowFrame">RefreshWindowFrame()</link>, etc., since any of the complex Intuition
  functions run the risk of creating a deadlock.  Also avoid any
  other high-level calls in Intuition or ones that might invoke
  Intuition.  This means no calling <link id="SetPointer">SetPointer()</link>, no calling
  <link id="LockIBase">LockIBase()</link>, no dos.library functions (since an EasyRequest()
  might result), etc.  Keep it simple.</p>
<p>
  By the time the application receives its <link id="IDCMP_REFRESHWINDOW"/>
  message, Intuition has already repaired any damaged regions
  of the window border or the gadgets in the window, so attempts
  to redraw gadgets or borders are as unnecessary as they are
  dangerous.</p>
<p><b>Another Warning:</b></p>
<p>
  The concept of multiple refresh passes using
  <link id="EndRefresh">EndRefresh</link>(w, False); is not completely sound without further
  protection.  The reason is that between two sessions, more
  damage can occur to your window.  Your final <link id="EndRefresh">EndRefresh</link>(w, True);
  will dispose of all damage, including the new, and your
  initial refreshing pass will never get the chance to refresh
  the new damage.</p>
<p>
  To avoid this, you must protect your session using <link id="layers.LockLayerInfo">LockLayerInfo()</link>
  which will prevent Intuition from performing window operations
  or anything else which might cause further damage from occurring.
  Again, while holding the LayerInfo lock make no Intuition
  function calls dealing with gadgets; just render.</p>
<p>
  You can, however, call <link id="layers.InstallClipRegion">InstallClipRegion()</link> for the different
  refresh passes, if you have two clip regions.</p>
<p><b>Similar Warning:</b></p>
<p>
  Your program and Intuition "share" your window
  layer's DamageList.  <i>BeginRefresh()</i> helps arbitrate this
  sharing, but the lower-level function <link id="layers.BeginUpdate">layers.library/BeginUpdate()</link>
  does not.  It isn't really supported to use <i>BeginUpdate()</i> on
  a window's layer, but if you do <b>for whatever reason</b> it is
  critical that you first acquire the LayerInfo lock as in
  the above example: even if you only have one pass of refresh
  rendering to do.  Otherwise, the refreshing of your window's
  borders and gadgets can be incomplete, and the problem might
  occur only under certain conditions of task priority and
  system load.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="EndRefresh"/>
<link id="layers.BeginUpdate"/>
<link id="OpenWindow"/>
<link id="layers.InstallClipRegion"/>
<link id="layers.LockLayerInfo"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="BeginRefresh.Window">
<short>A pointer to the window structure which needs refreshing</short>
</element>

<!-- function Visibility: default -->
<element name="BuildEasyRequestArgs">
<short>Simple creation of system request.</short>
<descr>
<p>This function is to <link id="EasyRequestArgs">EasyRequestArgs()</link> as
  <link id="BuildSysRequest">BuildSysRequest()</link> is to
  <link id="AutoRequest">AutoRequest()</link>: it returns a pointer
  to the system requester
  window.  The input from that window can then be processed
  under application control.</p>
<p>
  It is recommended that this processing be done with
  <link id="SysReqHandler">SysReqHandler()</link>, so that future enhancement to the
  processing will be enjoyed.</p>
<p>
  After you have determined that the requester is satisfied or
  cancelled, you must free this requester using <link id="FreeSysRequest">FreeSysRequest()</link>.</p>
<p>
  Please see the autodoc for <link id="EasyRequestArgs">EasyRequestArgs()</link>.</p>
<p>
  <b>Note:</b> This function switches the processor stack to ensure
  sufficient stack space for the function to complete.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="EasyRequestArgs"/>
<link id="FreeSysRequest"/>
<link id="SysReqHandler"/>
<link id="BuildSysRequest"/>
<link id="AutoRequest"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BuildEasyRequestArgs.Result">
<short>A pointer to the system request window opened.  In the event
  of problems, you may also be returned the value '0' which
  is to be interpreted as the "False, Cancel" choice, or
  (if you have a second gadget defined) the value '1', which
  is to be taken to mean the equivalent of your corresponding
  left-most gadget.

  If there is a problem creating the window, a recoverable alert may
  be substituted for the requester, and the result, either 0 or 1,
  returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildEasyRequestArgs.Window">
<short>Reference window for requester: determines the
      requester window title and screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildEasyRequestArgs.EasyStruct">
<short>A pointer to EasyStruct structure, as described
      in the <link id="EasyRequestArgs">EasyRequestArgs()</link> .</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildEasyRequestArgs.IDCMP">
<short>(<b>not a pointer</b>) provided application specific IDCMP flags for the system requester window.</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildEasyRequestArgs.Args">
<short>see <link id="EasyRequestArgs">EasyRequestArgs()</link></short>
</element>

<!-- function Visibility: default -->
<element name="BuildSysRequest">
<short>Build and display a system requester.</short>
<descr>
<p>This procedure builds a system requester based on the supplied
  information.  If all goes well and the requester is constructed,
  this procedure returns a pointer to the window in which the requester
  appears.  That window will have its IDCMP initialized to reflect the
  flags found in the <i>IDCMPFlags</i> argument.  You may then wait on those
  ports to detect the user's response to your requester, which response
  may include either selecting one of the gadgets or causing some other
  event to be noticed by Intuition (like <link id="IDCMP_DISKINSERTED"/>, for
  instance).  After the requester is satisfied, you should call the
  <link id="FreeSysRequest">FreeSysRequest()</link> procedure to remove the requester and free up
  any allocated memory.</p>
<p>
  See the autodoc for <link id="SysReqHandler">SysReqHandler()</link> for more information on the
  how to handle the IntuiMessages this window will receive.</p>
<p>
  The requester used by this function has the <link id="NOISYREQ"/> flag bit set,
  which means that the set of <i>IDCMPFlags</i> that may be used here
  include <link id="IDCMP_RAWKEY"/>IDCMP_RAWKEY, <link id="IDCMP_MOUSEBUTTONS"/>, and others.</p>
<p>
  The function may return True (1) or False (nil) if it cannot post
  the requester.</p>
<p>
  If the window argument you supply is equal to NULL, a new window will
  be created for you in the Workbench screen. If you want the requester
  created by this routine to be bound to a particular window (i.e.,
  to appear in the same screen as the window), you should
  not supply a window argument of nil.</p>
<p>
  If you pass a nil window pointer, the system requester
  will appear on the default public screen, which is not always
  the Workbench.</p>
<p>
  The text arguments are used to construct the display.  Each is a
  pointer to an instance of the structure IntuiText.</p>
<p>
  The <i>BodyText</i> argument should be used to describe the nature of
  the requester.  As usual with IntuiText data, you may link several
  lines of text together, and the text may be placed in various
  locations in the requester.  This IntuiText pointer will be stored
  in the ReqText variable of the new requester.</p>
<p>
  The <i>PosText</i> argument describes the text that you want associated
  with the user choice of "Yes,  True,  Retry,  Good."  If the requester
  is successfully opened, this text will be rendered in a gadget in
  the lower-left of the requester, which gadget will have the
  GadgetID field set to True.  If the requester cannot be opened and
  the <link id="DisplayAlert">DisplayAlert()</link> mechanism is used, this text will be rendered in
  the lower-left corner of the alert display with additional text
  specifying that the left mouse button will select this choice.  This
  pointer can be set to nil, which specifies that there is no True
  choice that can be made.</p>
<p>
  The <i>NegText</i> argument describes the text that you want associated
  with the user choice of "No,  False,  Cancel,  Bad."  If the requester
  is successfully opened, this text will be rendered in a gadget in
  the lower-right of the requester, which gadget will have the
  GadgetID field set to FALSE.  If the requester cannot be opened and
  the <link id="DisplayAlert">DisplayAlert()</link> mechanism is used, this text will be rendered in
  the lower-right corner of the alert display with additional text
  specifying that the right mouse button will select this choice.  This
  pointer cannot be set to nil.  There must always be a way for the
  user to cancel this requester.</p>
<p>
  The Positive and Negative Gadgets created by this routine have
  the following features:</p>
<ul>
  <li><link id="GTYP_BOOLGADGET"/></li>
  <li><link id="GACT_RELVERIFY"/></li>
  <li><link id="GTYP_REQGADGET"/></li>
  <li><link id="GACT_TOGGLESELECT"/></li>
</ul>
<p>
  When defining the text for your gadgets, you may find it convenient
  to use the special constants used by Intuition for the construction
  of the gadgets.  These include defines like <link id="AUTODRAWMODE"/>, <link id="AUTOLEFTEDGE"/>,
  <link id="AUTOTOPEDGE"/> and <link id="AUTOFRONTPEN"/>.</p>
<p>
  These hard-coded constants are not very resolution or font
  sensitive.</p>
<p>
  The <i>width</i> and <i>height</i> values describe the size of the requester.  All
  of your BodyText must fit within the width and height of your
  requester.  The gadgets will be created to conform to your sizes.</p>
<p>
  <b>Very important Note:</b>  for this release of this procedure, a new window
  is opened in the same screen as the one containing your window.
  Future alternatives may be provided as a function distinct from this
  one.</p>
<p>
  <b>Note:</b> This function will pop the screen the requester and its
  window appears in to the front of all screens.
  If the user doesn't perform any other screen arrangement before
  finishing with the requester, a popped screen will be pushed
  back behind.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeSysRequest"/>
<link id="DisplayAlert"/>
<link id="ModifyIDCMP"/>
<link id="exec.Wait">Wait</link>
<link id="Request"/>
<link id="AutoRequest"/>
<link id="EasyRequestArgs"/>
<link id="BuildEasyRequestArgs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BuildSysRequest.Result">
<short>If the requester was successfully created, the value
  returned by this procedure is a pointer to the window in which the
  requester is rendered.  If the requester could not be created,
  this routine might have called <link id="DisplayAlert">DisplayAlert()</link> before returning
  (it depends on the version) and will pass back True if the user
  pressed the left mouse button and False if the user pressed the
  right mouse button.   If the version of Intuition doesn't
  call <link id="DisplayAlert">DisplayAlert()</link>, or if it does, and there's not enough
  memory for the alert, the value of False is returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.Window">
<short>A pointer to a Window structure</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.Body">
<short>A pointer to an IntuiText structure</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.PosText">
<short>A pointer to an IntuiText structure</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.NegText">
<short>A pointer to an IntuiText structure</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.Flags">
<short>The IDCMP flags you want used for the initialization
of the IDCMP of the window containing this requester</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.Width">
<short>The width required to render your requester</short>
</element>

<!-- argument Visibility: default -->
<element name="BuildSysRequest.Height">
<short>The height required to render your requester</short>
</element>

<!-- function Visibility: default -->
<element name="ChangeScreenBuffer">
<short>Swap the screen's BitMap.</short>
<descr>
<p>
  Performs double (or multiple) buffering on an Intuition screen
  in an Intuition-cooperative manner.  The BitMap associated
  with the supplied ScreenBuffer will be installed in the
  specified screen, if possible.  The previously-installed BitMap
  is available for re-use upon receiving a signal from
  graphics.library.  See the graphics.library autodocs for
  <link id="AGraphics.AllocDBufInfo">AllocDBufInfo()</link> and
  <link id="AGraphics.ChangeVPBitMap">ChangeVPBitMap()</link>
  for details.</p>
<p>It is not required to restore the original ScreenBuffer
  before closing the screen. Simply <link id="FreeScreenBuffer">FreeScreenBuffer()</link> each
  buffer (including the original and the currently-installed one)
  then close the screen.  Of course, you cannot call
  <i>ChangeScreenBuffer()</i> after freeing the currently-installed one.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AllocScreenBuffer"/>
<link id="FreeScreenBuffer"/>
<link id="agraphics.ChangeVPBitMap">ChangeVPBitMap</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ChangeScreenBuffer.Result">
<short>Returns non-zero if the operation succeeded.  Returns zero
  if the operation cannot be performed.  This function will
  fail if Intuition's state cannot permit it, for example the
  user is playing with menus or gadgets.</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeScreenBuffer.Screen">
<short>A pointer to the screen whose bitmap is to be swapped.</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeScreenBuffer.ScreenBuffer">
<short>A pointer to a ScreenBuffer structure obtained from
      <link id="AllocScreenBuffer">AllocScreenBuffer()</link>.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ChangeWindowBox">
<short>Change window position and dimensions.</short>
<descr>
<p>
  Makes simultaneous changes in window position and dimensions,
  in absolute (not relative) coordinates.</p>
<p>
  Like <link id="MoveWindow">MoveWindow()</link> and <link id="SizeWindow">SizeWindow()</link>,
  the effect of this function
  is deferred until the next input comes along.  Unlike these
  functions, <i>ChangeWindowBox()</i> specifies absolute window position
  and dimensions, not relative.  This makes for more reliable
  results considering that the action is deferred, so this
  function is typically preferable to <link id="MoveWindow">MoveWindow()</link>
  and <link id="SizeWindow">SizeWindow()</link> paired.</p>
<p>
  You can detect that this operation has completed by receiving
  the <link id="IDCMP_CHANGEWINDOW"/> IDCMP message</p>
<p>
  The dimensions are limited to legal range, but you should still
  take care to specify sensible inputs based on the window's dimension
  limits and the size of its screen.</p>
<p>
  This function limits the position and dimensions to legal
  values.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MoveWindow"/>
<link id="SizeWindow"/>
<link id="ZipWindow"/>
<link id="layers.MoveSizeLayer">MoveSizeLayer</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ChangeWindowBox.Window">
<short>The window to change position/dimension</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeWindowBox.Left">
<short>Left edge the window should move to</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeWindowBox.Top">
<short>Top edge the window should move to</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeWindowBox.Width">
<short>New Width for window</short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeWindowBox.Height">
<short>New height for window</short>
</element>

<!-- function Visibility: default -->
<element name="ClearDMRequest">
<short>Clear (detaches) the DMRequest of the window.</short>
<descr>
  Attempts to clear the DMRequest from the specified window,
  that is detaches the special requester that you attach to
  the double-click of the menu button which the user can then
  bring up on demand.  This routine <b>will not</b> clear the DMRequest
  if it's active (in use by the user). The IDCMP message class
  <link id="IDCMP_REQCLEAR"/> can be used to detect that the requester is not in use,
  but that message is sent only when the last of perhaps several
  requesters in use in a window is terminated.
</descr>
<errors>
</errors>
<seealso>
<link id="SetDMRequest"/>
<link id="Request"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ClearDMRequest.Result">
<short>If the DMRequest was not currently in use, detaches the DMRequest
  from the window and returns True.
  If the DMRequest was currently in use, doesn't change anything
  and returns False.</short>
</element>

<!-- argument Visibility: default -->
<element name="ClearDMRequest.Window">
<short>A pointer to the window from which the DMRequest is to be cleared.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ClearMenuStrip">
<short>Clear (detach) the menu strip from the window.</short>
<descr>
<p>
  Detaches the current menu strip from the window; menu strips
  are attached to windows using the
  <link id="SetMenuStrip">SetMenuStrip()</link> function.</p>
<p>
  If the menu is in use (for that matter if any menu is in use)
  this function will block (<link id="exec.Wait">Wait()</link>)
  until the user has finished.</p>
<p>
  Call this function before you make any changes to the data
  in a <link id="TMenu"/> or <link id="TMenuItem"/> structure#
  which is part of a menu strip linked into a window.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetMenuStrip"/>
<link id="ResetMenuStrip"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ClearMenuStrip.Window">
<short>A pointer to a window structure</short>
</element>

<!-- procedure Visibility: default -->
<element name="ClearPointer">
<short>Clear the mouse pointer definition from a window.</short>
<descr>
<p>
  Clears the window of its own definition of the Intuition mouse pointer.
  After calling <i>ClearPointer()</i>, every time this window is the active
  one the default Intuition pointer will be the pointer displayed
  to the user.  If your window is the active one when this routine
  is called, the change will take place immediately.</p>
<p>
  Custom definitions of the mouse pointer which this function clears
  are installed by a call to <link id="SetPointer">SetPointer()</link>.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetWindowPointerA"/>
<link id="SetPointer"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ClearPointer.Window">
<short>A pointer to the window to be cleared of its pointer definition</short>
</element>

<!-- function Visibility: default -->
<element name="CloseScreen">
<short>Close an Intuition screen.</short>
<descr>
<p>
  Unlinks the screen, unlinks the viewport, deallocates everything that
  Intuition allocated when the screen was opened (using <link id="OpenScreen">OpenScreen()</link>).
  Doesn't care whether or not there are still any windows attached to the
  screen.  Doesn't try to close any attached windows; in fact, ignores
  them altogether.</p>
<p>
  If this is the last screen to go, attempts to reopen Workbench.</p>
<p>
  This function will refuse to close the screen
  if there are windows open on the screen or if there are any
  outstanding screen locks (see <link id="LockPubScreen">LockPubScreen()</link>) when
  <i>CloseScreen()</i> is called.  This avoids the almost certain crash
  when a screen is closed out from under a window.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CloseScreen.Result">
<short>Returns <link id="AmigaDos.DOSTrue">DOSTrue</link> (1) if screen is closed,
  returns <link id="AmigaDos.DOSFalse">DOSFalse</link> (0) if screen had open windows when
  called.</short>
</element>

<!-- argument Visibility: default -->
<element name="CloseScreen.Screen">
<short>A pointer to the screen to be closed.</short>
</element>

<!-- procedure Visibility: default -->
<element name="CloseWindow">
<short>Close an Intuition window.</short>
<descr>
<p>
  Closes an Intuition window.  Unlinks it from the system, deallocates
  its memory, and makes it disappear.</p>
<p>
  When this function is called, all IDCMP messages which have been sent
  to your window are deallocated.  If the window had shared a message
  Port with other windows, you must be sure that there are no unreplied
  messages for this window in the message queue.  Otherwise, your program
  will try to make use of a linked list (the queue) which contains free
  memory (the old messages).  This will give you big problems.
  See the code fragment CloseWindowSafely(), below.</p>
<p>
  <b>Note:</b>  If you have added a Menu strip to this Window (via
  a call to <link id="SetMenuStrip">SetMenuStrip()</link>) you must be sure to remove that Menu strip
  (via a call to <link id="ClearMenuStrip">ClearMenuStrip()</link>) before closing your Window.</p>
<p>
  <b>Note:</b> This function may block until it is safe to de-link and free
  your window.  Your program may thus be suspended while the user
  plays with gadgets, menus, or window sizes and position.</p>
<p>
  If your window is a "Visitor Window" (see <link id="OpenWindow">OpenWindow()</link>)
  <i>CloseWindow()</i> will decrement the "visitor count" in the public screen
  on which the window was open.  When the last visitor window is
  closed, a signal will be sent to the public screen task, if this
  was pre-arranged (see <link id="OpenWindow">OpenWindow()</link>).</p>
<code>
{ these functions close an Intuition window
  that shares a port with other Intuition
  windows or IPC customers.

  We are careful to set the UserPort to
  nil before closing, and to free
  any messages that it might have been
  sent.}
procedure CloseWindowSafely(Win: PWindow);
begin
  // we forbid here to keep out of race conditions with Intuition
  Forbid();
  // send back any messages for this window that have not yet been processed
  StripIntuiMessages(Win^.UserPort, Win);
  // clear UserPort so Intuition will not free it
  Win^.UserPort := nil;
  // tell Intuition to stop sending more messages
  ModifyIDCMP(Win, 0);
  // turn multitasking back on
  Permit();
  // and really close the window
  CloseWindow(Win);
end;

{ Remove and reply all IntuiMessages on a port that
  have been sent to a particular window
  (note that we don't rely on the ln_Succ pointer
  of a message after we have replied it)}
procedure StripIntuiMessages(var Mp: PMsgPort; var Win: PWindow);
var
  msg: PIntuiMessage;
  Succ: PNode;
begin
  Msg := PIntuiMessage(Mp^.mp_MsgList.lh_Head);
  Succ := Msg^.ExecMessage.mn_Node.ln_Succ;
  while Assigned(succ) do
  begin
    if Msg^.IDCMPWindow = Win then
    begin
      // Intuition is about to free this message. Make sure that we have politely sent it back.
      Remove(Msg);
      ReplyMsg(Msg);
    end;
    Msg := PIntuiMessage(Succ);
    Succ := Msg^.ExecMessage.mn_Node.ln_Succ;
  end;
end;
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
<link id="OpenScreen"/>
<link id="CloseScreen"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="CloseWindow.Window">
<short>A pointer to a Window structure</short>
</element>

<!-- function Visibility: default -->
<element name="CloseWorkBench">
<short>Closes the Workbench screen.</short>
<descr>
<p>
  This routine attempts to close the Workbench screen:</p>
<ul>
  <li>Test whether or not any applications have opened windows on the
      Workbench, and return False if so.  Otherwise ...</li>
  <li>Clean up all special buffers</li>
  <li>Close the Workbench screen</li>
  <li>Make the Workbench program mostly inactive (it will still monitor disk activity)</li>
  <li>Return <link id="AmigaDos.DOSTrue">DOSTrue</link></li>
</ul>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWorkBench"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CloseWorkBench.Result">
<short><link id="AmigaDos.DOSTrue">DOSTrue</link> if the Workbench screen closed successfully
  <link id="AmigaDos.DOSFalse">DOSFalse</link> if the Workbench was not open, or if it has windows
      open which are not Workbench drawers.</short>
</element>

<!-- procedure Visibility: default -->
<element name="CurrentTime">
<short>Get the current time values.</short>
<descr>
<p>
  Puts copies of the current time into the supplied argument pointers.</p>
<p>
  This time value is not extremely accurate, nor is it of a very fine
  resolution.  This time will be updated no more than sixty times a
  a second, and will typically be updated far fewer times a second.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="CurrentTime.Seconds">
<short>A pointer to a LongInt variable to receive the current seconds value</short>
</element>

<!-- argument Visibility: default -->
<element name="CurrentTime.Micros">
<short>A pointer to a LongInt variable for the current microseconds value</short>
</element>

<!-- function Visibility: default -->
<element name="DisplayAlert">
<short>Create the display of an alert message.</short>
<descr>
<p>
  Creates an alert display with the specified message.</p>
<p>
  If the system can recover from this alert, it's a <link id="RECOVERY_ALERT"/> and
  this routine waits until the user presses one of the mouse buttons,
  after which the display is restored to its original state and a
  LongBool value is returned by this routine to specify whether or not
  the user pressed the Left mouse button.</p>
<p>
  If the system cannot recover from this alert, it's a <link id="DEADEND_ALERT"/>
  and this routine returns immediately upon creating the alert display.
  The return value is False.</p>
<p>
  <b>NOTE:</b> If Intuition can't get enough
  memory for a <link id="RECOVERY_ALERT"/>, the value False will be returned.</p>
<p>
  <i>AlertNumber</i> is a LongInt value, historically related to the value
  sent to the <link id="Exec.Alert">Alert()</link> routine.  But the only bits that are pertinent to
  this routine are the <link id="ALERT_TYPE"/> bit(s).  These bits must be set to
  either <link id="RECOVERY_ALERT"/> for alerts from which the system may safely
  recover, or <link id="DEADEND_ALERT"/> for those fatal alerts.  These states are
  described in the paragraph above.   There is a third type of
  alert, the DAISY_ALERT, which is used only by the Exec.</p>
<p>
  The <i>String_</i> argument points to an AlertMessage string.  The AlertMessage
  string is comprised of one or more substrings, each of which is
  composed of the following components:</p>
<ul>
  <li>first, a 16-bit x-coordinate and an 8-bit y-coordinate,
      describing where on the alert display you want this string
      to appear.  The y-coordinate describes the offset to the
      baseline of the text.</li>
  <li>then, the bytes of the string itself, which must be
      null-terminated (end with a byte of zero)</li>
  <li>lastly, the continuation byte, which specifies whether or
      not there's another substring following this one.  If the
      continuation byte is non-zero, there <b>is</b> another substring
      to be processed in this alert message.  If the continuation
      byte is zero, this is the last substring in the message.</li>
</ul>
<p>
  The last argument, <i>Height</i>, describes how many video lines tall you
  want the alert display to be.</p>
<p>
  Alerts are always rendered in Topaz 8 (80 column font),
  regardless of the system default font.  Also, <link id="RECOVERY_ALERT"/>s are
  displayed in amber, while <link id="DEADEND_ALERT"/>s are still red.  Alerts
  no longer push down the application screens to be displayed.  Rather,
  they appear alone in a black display.</p>
<p>
  Alerts block each other out, and input
  during an alert is deprived of the rest of the system.  Internal
  input buffers still cause alert clicks to be processed by
  applications sometimes.</p>
</descr>
<errors>
This function is obsolete and exists only for backwards compatibility with
AmigaOS(tm). On various modern systems this function has different effects.
On classic Amiga(tm) this function may not work with RTG displays, so it
is generally <b>deprecated</b>. Please don't use it in a new software! Use legitimate
intuition requesters if you want to present some message to the user.
</errors>
<seealso>
<link id="TimedDisplayAlert"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DisplayAlert.Result">
<short>A LongBool value of True or False.  If this is a <link id="DEADEND_ALERT"/>, False
  is always the return value.  If this is a <link id="RECOVERY_ALERT"/>. The return
  value will be True if the user presses the left mouse button in
  response to your message, and False if the user presses the right hand
  button is response to your text, or if the alert could not
  be posted.
</short>
</element>

<!-- argument Visibility: default -->
<element name="DisplayAlert.AlertNumber">
<short>The number of this alert message.  The only pertinent
bits of this number are the <link id="ALERT_TYPE"/> bit(s).  The rest of the
number is ignored by this routine.</short>
</element>

<!-- argument Visibility: default -->
<element name="DisplayAlert.String_">
<short>A pointer to the alert message string, as described above</short>
</element>

<!-- argument Visibility: default -->
<element name="DisplayAlert.Height">
<short>Minimum display lines required for your message</short>
</element>

<!-- procedure Visibility: default -->
<element name="DisplayBeep">
<short>Flash the video display.</short>
<descr>
<p>
  "Beeps" the video display by flashing the background color of the
  specified screen.  If the screen argument is nil, every screen
  in the display will be beeped.  Flashing everyone's screen is not
  a polite thing to do, so this should be reserved for dire
  circumstances.</p>
<p>
  The reason such a routine is supported is because the Amiga has
  no internal bell or speaker.  When the user needs to know of
  an event that is not serious enough to require the use of a requester,
  the <i>DisplayBeep()</i> function may be called.</p>
<p>
  Intuition calls <i>DisplayBeep()</i> through the
  external library vector.  This means that if you call <link id="Exec.SetFunction">SetFunction()</link>
  to replace <i>DisplayBeep()</i> with an audible beep, for example, then
  your change will affect even Intuition's calls to <i>DisplayBeep()</i>.</p>
<p>Since this function changes color zero of the affected screen(s),
  surprising results could occur if the screen's owner reading
  colors or perhaps cycling them.
</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DisplayBeep.Screen">
<short>A pointer to a screen.  If nil, every screen in the display will be flashed</short>
</element>

<!-- procedure Visibility: default -->
<element name="DisposeObject">
<short>Deletes a 'boopsi' object.</short>
<descr>
<p>
  Deletes a boopsi object and all of it auxiliary data.
  These objects are all created by <link id="NewObject">NewObject()</link>.  Objects
  of certain classes "own" other objects, which will also
  be deleted when the object is passed to <link id="DisposeObject">DisposeObject()</link>.
  Read the per-class documentation carefully to be aware
  of these instances.</p>
<p>
  This function invokes the <link id="OM_DISPOSE"/> method.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NewObject"/>
<link id="SetAttrs"/>
<link id="GetAttr"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DisposeObject.Object_">
<short>An abstract pointer to a boopsi object returned by <link id="NewObject">NewObject()</link>.
    The pointer may be nil, in which case this function has
    no effect.</short>
</element>

<!-- function Visibility: default -->
<element name="DoGadgetMethodA">
<short>Invoke method on a boopsi gadget.</short>
<descr>
<p>
  Same as the <link id="DoMethodA">DoMethodA()</link> function, but provides context
  information and arbitration for classes which implement custom
  Intuition gadgets.</p>
<p>
  You should use this function for boopsi gadget objects,
  or for "models" which propagate information to gadgets.</p>
<p>
  Unlike <link id="DoMethodA">DoMethodA()</link>, this function provides a <link id="TGadgetInfo"/> pointer
  (if possible) when invoking the method.  Some classes may
  require or benefit from this.</p>
<p>
  <b>Note:</b> This function invokes the specified method with a <link id="TGadgetInfo"/>
  derived from the <i>Window</i> and <i>Requester</i> pointers.  The <link id="TGadgetInfo"/>
  is passed as the second parameter of the message, except for
  <link id="OM_NEW"/>, <link id="OM_SET"/>, <link id="OM_NOTIFY"/>,
  and <link id="OM_UPDATE"/>, where the <link id="TGadgetInfo"/>
  is passed as the third parameter.</p>
<p>
  Implementers of new gadget methods should ensure that the
  <link id="TGadgetInfo"/> is the second long-word of their message!</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NewObject"/>
<link id="DisposeObject"/>
<link id="GetAttr"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoGadgetMethodA.Result">
<short>The object does whatever it wants with the message you sent,
  which might include updating its gadget visuals.

  The return value is defined per-method.</short>
</element>

<!-- argument Visibility: default -->
<element name="DoGadgetMethodA.Gad">
<short>An abstract pointer to a boopsi gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="DoGadgetMethodA.Win">
<short>window gadget has been added to using <link id="AddGList">AddGList()</link>
or <link id="AddGadget">AddGadget()</link></short>
</element>

<!-- argument Visibility: default -->
<element name="DoGadgetMethodA.Req">
<short>For REQGADGETs, requester containing the gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="DoGadgetMethodA.Msg">
<short>The boopsi message to send</short>
</element>

<!-- function Visibility: default -->
<element name="DoubleClick">
<short>Test two time values for double-click timing.</short>
<descr>
<p>
  Compares the difference in the time values with the double-click
  timeout range that the user has set (using the "Preferences" tool) or
  some other program has configured into the system.  If the
  difference between the specified time values is within the current
  double-click time range, this function returns True, else it
  returns False.</p>
<p>
  These time values can be found in input events and IDCMP messages.
  The time values are not perfect; however, they are precise enough for
  nearly all applications.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CurrentTime"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoubleClick.Result">
<short>If the difference between the supplied timestamp values is within the
  double-click time range in the current set of Preferences, this
  function returns True, else it returns False
</short>
</element>

<!-- argument Visibility: default -->
<element name="DoubleClick.SSeconds">
<short>The timestamp value describing the start of
          the double-click time period you are considering</short>
</element>

<!-- argument Visibility: default -->
<element name="DoubleClick.SMicros">
<short>Microseconds of start</short>
</element>

<!-- argument Visibility: default -->
<element name="DoubleClick.CSeconds">
<short>The timestamp value describing
          the end of the double-click time period you are considering</short>
</element>

<!-- argument Visibility: default -->
<element name="DoubleClick.CMicros">
<short>Microsecond of end</short>
</element>

<!-- procedure Visibility: default -->
<element name="DrawBorder">
<short>Draw the specified Border structure into a RastPort.</short>
<descr>
<p>
  First, sets up the draw mode and pens in the RastPort according to the
  arguments of the Border structure.  Then, draws the vectors of
  the border argument into the RastPort, offset by the left and top
  offsets.</p>
<p>
  As with all graphics rendering routines, the border will be clipped to
  to the boundaries of the RastPort's layer, if it exists.  This is
  the case with window RastPorts.</p>
<p>
  This routine will draw all borders in the null-terminated list linked
  by the NextBorder field of the border argument.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DrawBorder.Rp">
<short>A pointer to the RastPort to receive the border rendering</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawBorder.Border">
<short>A pointer to a Border structure</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawBorder.LeftOffset">
<short>The offset to be added to each vector's x coordinate</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawBorder.TopOffset">
<short>The offset to be added to each vector's y coordinate</short>
</element>

<!-- procedure Visibility: default -->
<element name="DrawImage">
<short>Draw the specified Image structure into a RastPort.</short>
<descr>
<p>First, sets up the draw mode and pens in the RastPort according to the
  arguments of the Image structure.  Then, moves the image data of
  the image argument into the RastPort, offset by the left and top
  offsets.</p>
<p>
  This routine does window layer clipping if you pass your window's
  (layered) RastPort -- if you draw an image outside of your window,
  your imagery will be clipped at the window's edge.  If you pass
  a (non-layered) screen RastPort, you <b>must</b> be sure your image is
  wholly contained within the rastport bounds.</p>
<p>
  If the <i>NextImage</i> field of the image argument is non-nil,
  the next image is rendered as well, and so on until some
  NextImage field is found to be nil.</p>
<p><b>Note:</b></p>
<p>Intuition always has and will continue to assume there are
  at least as many planes of data pointed to by ImageData as there
  are '1' bits in the PlanePick field.  Please ensure that
  this is so.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DrawImageState"/>
<link id="EraseImage"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DrawImage.Rp">
<short>A pointer to the RastPort to receive image rendering</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImage.Image">
<short>A pointer to an image structure</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImage.LeftOffset">
<short>The offset which will be added to the image's x coordinate</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImage.TopOffset">
<short>The offset which will be added to the image's y coordinate
</short>
</element>

<!-- procedure Visibility: default -->
<element name="DrawImageState">
<short>Draw an (extended) Intuition Image with special visual state.</short>
<descr>
<p>This function draws an Intuition Image structure in a variety of
  "visual states", these include:</p>
<dl>
  <dt><link id="IDS_NORMAL"/></dt><dd>like <link id="DrawImage">DrawImage()</link></dd>
  <dt><link id="IDS_SELECTED"/></dt><dd>represents the "selected state" of a Gadget</dd>
  <dt><link id="IDS_DISABLED"/></dt><dd>the "ghosted state" of a gadget</dd>
  <dt><link id="IDS_BUSY"/></dt><dd>for future functionality</dd>
  <dt><link id="IDS_INDETERMINATE"/></dt><dd>for future functionality</dd>
  <dt><link id="IDS_INACTIVENORMAL"/></dt><dd>for gadgets in window border</dd>
  <dt><link id="IDS_INACTIVESELECTED"/></dt><dd>for gadgets in window border</dd>
  <dt><link id="IDS_INACTIVEDISABLED"/></dt><dd>for gadgets in window border</dd>
</dl>
<p>
  Only <link id="IDS_NORMAL"/> will make sense for traditional Image structures,
  this function is more useful when applied to new custom images
  or "object-oriented image classes."</p>
<p>
  Each class of custom images is responsible for documenting which
  visual states it supports, and you typically want to use images
  which support the appropriate states with your custom gadgets.</p>
<p>
  The DrawInfo parameter provides information invaluable to
  "rendered" images, such as pen color and resolution.  Each
  image class must document whether this parameter is required.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DrawImage"/>
<link id="GetScreenDrawInfo"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DrawImageState.Rp">
<short>RastPort for rendering</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImageState.Image">
<short>A pointer to a (preferably custom) image</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImageState.LeftOffset">
<short>Left positional offsets in pixels</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImageState.TopOffset">
<short>Top positional offsets in pixels</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImageState.state">
<short>Visual state selected from above</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawImageState.DrawInfo">
<short>A pointer to packed of pen selections and resolution.</short>
</element>

<!-- function Visibility: default -->
<element name="EasyRequest">
<short>VarArgs Version of <link id="EasyRequestArgs">EasyRequestArgs()</link> </short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="EasyRequestArgs">
<short>Easy alternative to <link id="AutoRequest">AutoRequest()</link></short>
<descr>
<p>This function provides a simpler method of using a 'System
  Requester' than provided by <link id="AutoRequest">AutoRequest()</link>.
  It performs layout
  and size calculations sensitive to the current font and screen
  resolution.</p>
<p>
  It provides for the descriptive <i>body</i> text and the gadget
  text to be constructed from <i>printf</i> style format strings.</p>
<p>
  It also provides a general way for the requester to be
  sensitive to particular IDCMP messages.</p>
<p>
  The first function listed is the actual Intuition library
  function.  It is passed the arguments for the formatting
  operations as a pointer to the first argument.</p>
<p>
  <b>Note:</b> The formatting is done by <link id="Exec.RawDoFmt">RawDoFmt()</link>, so
  be aware that to display a 32-bit integer argument, for
  example, you must say "%ld", not "%d", since <link id="Exec.RawDoFmt">RawDoFmt()</link> is
  "word-oriented."</p>
<p>
  <b>Note:</b> This function switches the processor stack to ensure
  sufficient stack space for the function to complete.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="EasyRequest"/>
<link id="exec.RawDoFmt">RawDoFmt</link>
<link id="BuildEasyRequestArgs"/>
<link id="SysReqHandler"/>
<link id="AutoRequest"/>
<link id="BuildSysRequest"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="EasyRequestArgs.Result">
<short>
<p>0, 1, ..., N = Successive GadgetID values, for the gadgets
      you specify for the requester.  <b>Note:</b> The numbering
      from left to right is actually: 1, 2, ..., N, 0.
      This is for compatibility with <link id="AutoRequest">AutoRequest()</link>, which has
      False for the rightmost gadget.</p>
<p>
  -1 = Means that one of the caller-supplied IDCMPFlags occurred.
      The IDCMPFlag value is in the LongWord pointed to by IDCMP_ptr.</p>
</short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequestArgs.Window">
<short>Reference window pointer, determines the screen and
      title of the requester window.  This can be nil, which
      means the requester is to appear on the Workbench screen,
      or default public screen, if defined.</short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequestArgs.EasyStruct">
<short>A Pointer to EasyStruct structure</short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequestArgs.IDCMP_Ptr">
<short>A pointer to IDCMP flags that you want to terminate
    the requester.  This pointer may be nil.</short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequestArgs.Args">
<short>Arguments for format commands. Arguments for
GadFmt follow arguments for TextFmt.</short>
</element>

<!-- procedure Visibility: default -->
<element name="EndRefresh">
<short>End the optimized refresh state of the window.</short>
<descr>
<p>This function gets you out of the special refresh state of your
  window.  It is called following a call to <link id="BeginRefresh">BeginRefresh()</link>, which
  routine puts you into the special refresh state.  While your window
  is in the refresh state, the only rendering that will be wrought in
  your window will be to those areas which were recently revealed and
  need to be refreshed.</p>
<p>
  After you've done all the refreshing you want to do for this window,
  you should call this routine to restore the window to its
  non-refreshing state.  Then all rendering will go to the entire
  window, as usual.</p>
<p>
  The <i>Complete</i> argument is a boolean True or False value used to
  describe whether or not the refreshing you've done was all the
  refreshing that needs to be done at this time.  Most often, this
  argument will be True.  But if, for instance, you have multiple
  tasks or multiple procedure calls which must run to completely
  refresh the window, then each can call its own
  <link id="BeginRefresh">BeginRefresh()</link>/<i>EndRefresh()</i>
  pair with a Complete argument of False, and only the last calls
  with a Complete argument of True.</p>
<p>
  <b>Warning:</b>  Passing this function the value of False has its
  pitfalls.  Please see <link id="BeginRefresh">BeginRefresh()</link>.</p>
<p>
  For your information, this routine calls the Layers library function
  <link id="layers.EndUpdate">EndUpdate()</link>, unlocks your layers
  (calls <link id="AGraphics.UnlockLayerRom">UnlockLayerRom()</link>), clears
  the <link id="Layers.LAYERREFRESH">LAYERREFRESH</link> bit in your Layer Flags, and clears the
  <link id="WFLG_WINDOWREFRESH"/> bit in your window Flags.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="BeginRefresh"/>
<link id="layers.EndUpdate">EndUpdate</link>
<link id="AGraphics.UnlockLayerRom">UnlockLayerRom</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="EndRefresh.Window">
<short>A pointer to the window currently in optimized-refresh mode</short>
</element>

<!-- argument Visibility: default -->
<element name="EndRefresh.Complete">
<short>Boolean True or False describing whether or not this window is completely refreshed</short>
</element>

<!-- procedure Visibility: default -->
<element name="EndRequest">
<short>Remove a currently active requester.</short>
<descr>
<p>Ends the request by erasing the requester and decoupling it from
  the window.</p>
<p>
  Note that this doesn't necessarily clear all requesters from the window,
  only the specified one.  If the window labors under other requesters,
  they will remain in the window.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="InitRequester"/>
<link id="Request"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="EndRequest.Requester">
<short>A pointer to the requester to be removed</short>
</element>

<!-- argument Visibility: default -->
<element name="EndRequest.Window">
<short>A pointer to the Window structure with which this requester is associated</short>
</element>

<!-- procedure Visibility: default -->
<element name="EraseImage">
<short>Erases an Image.</short>
<descr>
<p>Erases an Image.  For a normal Image structure, this will
  call the graphics function <link id="AGraphics.EraseRect">EraseRect()</link> (clear using layer
  backfill, if any) for the Image box (LeftEdge/TopEdge/Width/Height).</p>
<p>
  For custom image, the exact behavior is determined by the custom image class.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AGraphics.EraseRect">EraseRect()</link>
<link id="DrawImage"/>
<link id="DrawImageState"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="EraseImage.Rp">
<short>RastPort to erase a part of</short>
</element>

<!-- argument Visibility: default -->
<element name="EraseImage.Image">
<short>Custom or standard image</short>
</element>

<!-- argument Visibility: default -->
<element name="EraseImage.LeftOffset">
<short>Left pixel offsets of Image position</short>
</element>

<!-- argument Visibility: default -->
<element name="EraseImage.TopOffset">
<short>Top pixel offsets of Image position</short>
</element>

<!-- function Visibility: default -->
<element name="FreeClass">
<short>Frees a boopsi class created by <link id="MakeClass">MakeClass()</link>.</short>
<descr>
<p>For class implementors only.</p>
<p>
  Tries to free a boopsi class created by <link id="MakeClass">MakeClass()</link>.  This
  won't always succeed: classes with outstanding objects or
  with subclasses cannot be freed.  You cannot allow the code
  which implements the class to be unloaded in this case.</p>
<p>
  For public classes, this function will <b>always</b> remove
  the class (see <link id="RemoveClass">RemoveClass()</link> )
  making it unavailable, whether it succeeds or not.</p>
<p>
  If you have a dynamically allocated data for your class (hanging
  off of <link id="TIClass">cl_UserData</link>), try to free the class before you free the
  user data, so you don't get stuck with a half-freed class.</p>
<p><b>Example:</b></p>
<code>
// Free a public class with dynamic memory in cl_UserData
function freeMyClass(cl: PClass): Boolean;
var
  mpcd: PMyPerClassData;
begin
  Result := False;
  mpcd = PMyPerClassData(cl^.cl_UserData);
  if FreeClass(cl) then
  begin
    FreeMem(mpcd, SizeOf(TMyPerClassData));
    Result := True;
  end;
end;
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FreeClass.Result">
<short>Returns False if the class could not be freed.  Reasons include,
  but will not be limited to, having non-zero <link id="TIClass">cl_ObjectCount</link> or
  <link id="TIClass">cl_SubclassCount</link>. Returns True if the class could be freed.
  Calls <link id="RemoveClass">RemoveClass()</link> for the class in either case.</short>
</element>

<!-- argument Visibility: default -->
<element name="FreeClass.ClassID">
<short>pointer to a class created by <link id="MakeClass">MakeClass()</link>.
</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeRemember">
<short>Free memory allocated by calls to <link id="AllocRemember">AllocRemember()</link>.</short>
<descr>
<p>This function frees up memory allocated by the <link id="AllocRemember">AllocRemember()</link> function.
  It will either free up just the Remember structures, which supply the
  link nodes that tie your allocations together, or it will deallocate
  both the link nodes AND your memory buffers too.</p>
<p>
  If you want to deallocate just the Remember structure link nodes,
  you should set the <i>ReallyForget</i> argument to False. However, if you
  want <i>FreeRemember()</i> to really deallocate all the memory, including
  both the Remember structure link nodes and the buffers you requested
  via earlier calls to <link id="AllocRemember">AllocRemember()</link>, then you should set the
  ReallyForget argument to True.</p>
<p>
  <b>Note well:</b> Once you call this function passing it False, the
  linkages between all the memory chunks are lost, and you
  cannot subsequently use <i>FreeRemember()</i> to free them.</p>
<p><b>Example:</b></p>
<code>
var
  RememberKey: PRemember;
begin
  RememberKey := nil;
  AllocRemember(@RememberKey, BUFSIZE, MEMF_CHIP);
  // ...
  FreeRemember(@RememberKey, TRUE);
end;
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="AllocRemember"/>
<link id="Exec.ExecFreeMem">ExecFreeMem</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeRemember.RememberKey">
<short>The address of a pointer to struct Remember.  This
pointer should either be nil or set to some value (possibly
nil) by a call to <link id="AllocRemember">AllocRemember()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="FreeRemember.ReallyForget">
<short>A LongBool False or True describing, respectively,
whether you want to free up only the Remember nodes or
if you want this procedure to really forget about all of
the memory, including both the nodes and the memory buffers
referenced by the nodes.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeScreenBuffer">
<short>Free a ScreenBuffer structure.</short>
<descr>
<p>Frees a ScreenBuffer structure you got from <link id="AllocScreenBuffer">AllocScreenBuffer()</link>,
  and releases associated resources.  You must call <i>FreeScreenBuffer()</i>
  before you close your screen.</p>
<p><b>Notes:</b></p>
<p>Originally, <i>FreeScreenBuffer()</i> did not <link id="AGraphics.WaitBlit">WaitBlit()</link> before freeing
  a BitMap.  The intent was that the application should do this.
  Application writers should ensure that freeing
  the buffer is safe by calling <link id="AGraphics.WaitBlit">WaitBlit()</link> themselves.</p>
<p>
  The <link id="SB_SCREEN_BITMAP"/> flag instructs <link id="AllocScreenBuffer">AllocScreenBuffer()</link> to provide
  a ScreenBuffer referring to the screen's actual bitmap.  When
  you are done changing screen buffers, you must <i>FreeScreenBuffer()</i>
  the currently-installed ScreenBuffer before you close the screen.
  Intuition will recognize when <i>FreeScreenBuffer()</i> is called for
  the currently-installed ScreenBuffer, and will know to free the
  supporting structures but not the BitMap.  <link id="CloseScreen">CloseScreen()</link> will
  take care of that.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AllocScreenBuffer"/>
<link id="ChangeScreenBuffer"/>
<link id="agraphics.ChangeVPBitMap">ChangeVPBitMap</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeScreenBuffer.Screen">
<short>A pointer to the screen this ScreenBuffer is associated with.</short>
</element>

<!-- argument Visibility: default -->
<element name="FreeScreenBuffer.ScreenBuffer">
<short>A pointer to a ScreenBuffer structure obtained from
<link id="AllocScreenBuffer">AllocScreenBuffer()</link>.
It is safe to call this function with
a nil argument.  It will have no effect.
</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeScreenDrawInfo">
<short>Finish using a DrawInfo structure.</short>
<descr>
<p>Declares that you are finished with the DrawInfo structure
  returned by <link id="GetScreenDrawInfo">GetScreenDrawInfo()</link>.</p>
<p>This function, and <link id="GetScreenDrawInfo">GetScreenDrawInfo()</link>,
  don't really do much, but
  they provide an upward compatibility path.  That means that
  if you misuse them today, they probably won't cause a problem,
  although they may someday later.  So, please be very careful
  only to use the DrawInfo structure between calls to
  <link id="GetScreenDrawInfo">GetScreenDrawInfo()</link> and
  <i>FreeScreenDrawInfo()</i>, and be sure
  that you don't forget <i>FreeScreenDrawInfo()</i>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetScreenDrawInfo"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeScreenDrawInfo.Screen">
<short>A pointer to screen passed to <link id="GetScreenDrawInfo">GetScreenDrawInfo()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="FreeScreenDrawInfo.DrawInfo">
<short>A pointer to DrawInfo returned by <link id="GetScreenDrawInfo">GetScreenDrawInfo()</link>.
 A nil DrawInfo pointer is a valid parameter, signifying "do nothing".</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeSysRequest">
<short>Free resources gotten by a call to <link id="BuildSysRequest">BuildSysRequest()</link>.</short>
<descr>
<p>This routine frees up all memory allocated by a successful call to
  the <link id="BuildSysRequest">BuildSysRequest()</link> procedure.
  If <link id="BuildSysRequest">BuildSysRequest()</link> returned a
  pointer to a window, then you are able to wait on the message port
  of that window to detect an event which satisfies the requester.
  When you want to remove the requester, you call this procedure.  It
  ends the requester and deallocates any memory used in the creation
  of the requester.  It also closes the special window that was opened
  for your system requester.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="BuildSysRequest"/>
<link id="AutoRequest"/>
<link id="CloseWindow"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeSysRequest.Window">
<short>Value of the window pointer returned by a successful call to
the <link id="BuildSysRequest">BuildSysRequest()</link> procedure</short>
</element>

<!-- procedure Visibility: default -->
<element name="GadgetMouse">
<short>Calculate gadget-relative mouse position.</short>
<descr>
<p>Determines the current location of the mouse pointer relative
  to the upper-left corner of a custom gadget.  Typically used
  only in the <link id="GM_HANDLEINPUT"/> and <link id="GM_GOACTIVE"/> custom gadget hook
  routines.</p>
<p>
  <b>News flash!!:</b> These two hook routines are now passed the mouse
  coordinates, so this function has no known usefulness.</p>
<p>
  We recommend that you don't call it.</p>
<p>
  Note that this function calculates the mouse position taking
  "gadget relativity" (<link id="GFLG_RELRIGHT"/>, <link id="GFLG_RELBOTTOM"/>) into
  consideration.  If your custom gadget intends to ignore these
  properties, then you should either enjoin or inhibit your users
  from setting those bits, since Intuition won't ask if you respect
  them.</p>
</descr>
<errors>
This function is useless, because programs which need this information
can get it in a cleaner way.
It is recommended not to call this function!
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="GadgetMouse.Gadget">
<short>A pointer to the Gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="GadgetMouse.GInfo">
<short>A pointer to a GadgetInfo structure as passed to the custom gadget hook routine.</short>
</element>

<!-- argument Visibility: default -->
<element name="GadgetMouse.MousePoint">
<short>Address of two Words, or a pointer to a structure of
    type Point.</short>
</element>

<!-- function Visibility: default -->
<element name="GetAttr">
<short>Inquire the value of some attribute of an object.</short>
<descr>
<p>Inquires from the specified object the value of the specified attribute.</p>
<p>
  You always pass the address of a long variable, which will
  receive the same value that would be passed to <link id="SetAttrs">SetAttrs()</link> in
  the <link id="utility.TTagItem">ti_Data</link> portion of a
  <link id="utility.TTagItem">TagItem</link> element.</p>
<p>
  Not all attributes will respond to this function.  Those that
  will are documented on a class-by-class basis.</p>
<p>This function sends <link id="OM_GET"/> to the object.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NewObject"/>
<link id="DisposeObject"/>
<link id="SetAttrs"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetAttr.Result">
<short>Mostly True if the method is supported for the specified attribute
and False if it isn't or the attribute can't be read at this time.
See the classes documentation for details.
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetAttr.AttrID">
<short>The attribute tag ID understood by the object's class</short>
</element>

<!-- argument Visibility: default -->
<element name="GetAttr.Object_">
<short>Abstract pointer to the boopsi object you are interested in</short>
</element>

<!-- argument Visibility: default -->
<element name="GetAttr.StoragePtr">
<short>A pointer to appropriate storage for the answer</short>
</element>

<!-- function Visibility: default -->
<element name="GetDefaultPubScreen">
<short>Get name of default public screen.</short>
<descr>
<p>Provides the name of the current default public screen.
  Only anticipated use is for Public Screen Manager utilities,
  since it is easy to open a visitor window on the default
  public screen without specifying the name.</p>
<p><b>Note:</b></p>
<p>Only Public Screen Manager utilities want to use this function
since it is easy to open a window on the default public screen
without specifying a name.</p>
<p>
  Also note that if there no default public screen has been set,
  the return value of this function will be zero, and not a pointer
  to the Workbench screen.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetDefaultPubScreen"/>
<link id="OpenWindow"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetDefaultPubScreen.Result">
<short>None.  Will provide the string "Workbench" in Namebuff if there
  is no current default public screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefaultPubScreen.NameBuffer">
<short>A buffer of <link id="MAXPUBSCREENNAME"/>.  This can be nil.</short>
</element>

<!-- function Visibility: default -->
<element name="GetDefPrefs">
<short>Get a copy of the the Intuition default Preferences.
</short>
<descr>
<p>Gets a copy of the Intuition default preferences data.  Writes the
  data into the buffer you specify.  The number of bytes you want
  copied is specified by the size argument.</p>
<p>
  The default preferences are those that Intuition uses when it
  is first opened.  If no preferences file is found, these are
  the preferences that are used.  These would also be the startup
  preferences in an AmigaDOS-less environment.</p>
<p>
  It is legal to take a partial copy of the Preferences structure.
  The more pertinent preferences variables have been grouped near
  the top of the structure to facilitate the memory conservation
  that can be had by taking a copy of only some of the Preferences
  structure.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetPrefs"/>
<link id="SetPrefs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetDefPrefs.Result">
<short>Returns your parameter <i>Preferences</i>.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefPrefs.Preferences">
<short>A pointer to the memory buffer to receive your copy of the
Intuition Preferences structure</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefPrefs.Size">
<short>The number of bytes in your PrefBuffer, the number of bytes
you want copied from the system's internal Preference settings</short>
</element>

<!-- function Visibility: default -->
<element name="GetPrefs">
<short>Get the current Intuition Preferences structure.</short>
<descr>
<p>Gets a copy of the current Intuition Preferences structure.
  Writes the data into the buffer you specify.  The number of bytes you
  want copied is specified by the size argument.</p>
<p>
  It is legal to take a partial copy of the Preferences structure.
  The more pertinent preferences variables have been grouped near
  the top of the structure to facilitate the memory conservation
  that can be had by taking a copy of only some of the Preferences
  structure.</p>
<p>
  A new and more extensible method for supplying
  Preferences has been introduced in V36, and relies on file
  system notification.  The Intuition preferences items rely
  also on the IPrefs program.  Certain elements of the
  Preferences structure have been superseded by this new method.
  As much as possible, the Preferences structure returned by
  <i>GetPrefs()</i> reflect the current state of Preferences.  However,
  it is impossible to represent some of the V36-style preferences
  items using the existing Preferences structure.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetDefPrefs"/>
<link id="SetPrefs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetPrefs.Result">
<short>Returns your parameter <i>Preferences</i>.
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPrefs.Preferences">
<short>A pointer to the memory buffer to receive your copy of the Intuition Preferences</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPrefs.Size">
<short>The number of bytes in your PrefBuffer, the number of bytes you want copied from the system's internal Preference settings
</short>
</element>

<!-- function Visibility: default -->
<element name="GetScreenData">
<short>Get copy of a screen data structure.</short>
<descr>
<p>This function copies into the caller's buffer data from a Screen
  structure.  Typically, this call will be used to find the size, title
  bar height, and other values for a standard screen, such as the
  Workbench screen.</p>
<p>
  To get the data for the Workbench screen, one would call:</p>
<code>
  GetScreenData(buff, SizeOf(TScreen), WBENCHSCREEN_f, nil);
</code>
<p>
  <b>Note:</b> If the requested standard screen is not open, this function
  will have the effect of opening it.</p>
<p>
  This function has been useful for two basic types of things:</p>
<ol>
  <li>Determining information about the Workbench screen, in
     preparation for opening a window on it.</li>
  <li>Attempts at discerning the user's preferences in a working
     screen, for "cloning" the Workbench modes and dimensions
     when opening a similar custom screen.</li>
</ol>
<p>
  The function <link id="LockPubScreen">LockPubScreen()</link> is an improvement
  over this function, in that it doesn't copy the screen data
  but returns a pointer and a guarantee that the screen will not
  be closed.</p>
<p>
  If the global public screen <link id="SHANGHAI"/> mode is in effect (see
  <link id="SetPubScreenModes">SetPubScreenModes()</link>), this function will actually report on
  the default public screen, where "Workbench" windows will
  actually open.</p>
<p>
  This function does some "compatibility tricks"
  when you inquire about the <link id="WBENCHSCREEN_f"/>.  To keep programs from
  "stumbling" into modes they don't understand, and because an NTSC
  machine may be running a PAL Workbench or PRODUCTIVITY, for example,
  the following "false" information is returned.</p>
<p>
  The <link id="TScreen">Screen</link>.<link id="AGraphics.TViewPort">ViewPort.Modes</link> field will either be HIRES or HIRES+LACE
  (with the SPRITES flag also set, as usual).  HIRES+LACE is
  used if the display mode selected for the Workbench screen
  is an interlaced screen of any type.</p>
<p>
  The dimensions returned will be the <b>smaller</b> of the <link id="OSCAN_TEXT"/>
  dimensions for the returned mode, and the actual dimensions
  of the Workbench screen.</p>
<p>
  <b>Exception:</b> For specific compatibility considerations, if the
  Workbench is in one of the A2024 modes, the mode returned
  in Screen.ViewPort.Modes will be HIRES+LACE (with perhaps
  some "special" bits also set for future improvement), but
  with dimensions equal to the actual A2024-mode Workbench screen.
  This will favor programs which open windows on the A2024
  Workbench, but will cause some problems for programs which
  try to "clone" the Workbench screen using this function.</p>
<p>
  If you want the real information about the modern Workbench
  screen, call <link id="LockPubScreen"/>('Workbench') and acquire its
  display mode ID by inquiring of the actual ViewPort (using
  <link id="agraphics.GetVPModeID">GetVPModeID()</link>).</p>
<p>
  You may then use the information you get to clone as many of
  the properties of the Workbench screen that you wish.</p>
<p>
  In the long run, it's probably better to provide your user
  with a screen mode selection option, and skip all this.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
<link id="LockPubScreen"/>
<link id="AGraphics.GetVPModeID">GetVPModeID</link>
<link id="SetPubScreenModes"/>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetScreenData.Result">
<short>True if successful.
  False if standard screen of Type 'type' could not be opened.
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetScreenData.Buffer">
<short>A pointer to a buffer into which data can be copied</short>
</element>

<!-- argument Visibility: default -->
<element name="GetScreenData.Size">
<short>The size of the buffer provided, in bytes</short>
</element>

<!-- argument Visibility: default -->
<element name="GetScreenData.Type_">
<short>The screen type, as specified in <link id="OpenWindow">OpenWindow()</link> (<link id="WBENCHSCREEN_f"/>,
      <link id="CUSTOMSCREEN_f"/>, ...)</short>
</element>

<!-- argument Visibility: default -->
<element name="GetScreenData.Screen">
<short>Ignored, unless type is <link id="CUSTOMSCREEN_f"/>, which results only in
      copying 'size' bytes from 'screen' to 'buffer'</short>
</element>

<!-- function Visibility: default -->
<element name="GetScreenDrawInfo">
<short>Get pointer to rendering information.</short>
<descr>
<p>Returns a pointer to a <link id="TDrawInfo"/> structure derived from the
  screen passed.  This data structure is <b>Read Only</b>.  The field
  <link id="TDrawInfo">dri_Version</link> identifies which version of <link id="TDrawInfo"/> you
  are given a pointer to.</p>
<p><b>Note:</b></p>
<p>Some information in the <link id="TDrawInfo"/> structure may in the future
  be calculated the first time this function is called for a
  particular screen.</p>
<p>
  You must call <link id="FreeScreenDrawInfo">FreeScreenDrawInfo()</link> when you are done using the
  returned pointer.</p>
<p>
  This function does not prevent a screen from closing.  Apply it
  only to the screens you opened yourself, or apply a protocol
  such as <link id="LockPubScreen">LockPubScreen()</link>.</p>
<p>
  <b>WARNING:</b> Until further notice, the pointer returned does not
  remain valid after the screen is closed.</p>
<p>
  This function and <link id="FreeScreenDrawInfo">FreeScreenDrawInfo()</link> don't really do much now,
  but they provide an upward compatibility path.  That means that
  if you misuse them today, they probably won't cause a problem,
  although they may someday later.  So, please be very careful
  only to use the <link id="TDrawInfo"/> structure between calls to
  <i>GetScreenDrawInfo()</i> and <link id="FreeScreenDrawInfo">FreeScreenDrawInfo()</link>, and be sure
  that you don't forget <link id="FreeScreenDrawInfo">FreeScreenDrawInfo()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="LockPubScreen"/>
<link id="FreeScreenDrawInfo"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetScreenDrawInfo.Result">
<short>A pointer to a system-allocated DrawInfo structure.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetScreenDrawInfo.Screen">
<short>A pointer to a valid, open screen.</short>
</element>

<!-- procedure Visibility: default -->
<element name="HelpControl">
<short>Enable/disable Gadget-Help feature.</short>
<descr>
<p>This function can be used to turn Gadget-Help on or off for
  your window.  Gadget-Help will also be enabled/disabled
  accordingly for all other windows which share the same
  help-group.  This allows Gadget-Help to be well-behaved
  for multiple-window applications.</p>
<p>You must use <link id="utility.GetUniqueID">GetUniqueID()</link> to get a help-group
  identifier. Never ever supply your own!</p>
</descr>
<errors>
</errors>
<seealso>
<link id="WA_HelpGroup"/>
<link id="OpenWindowTagList"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="HelpControl.Window">
<short>A pointer to the window you wish to affect.  (Other windows
      will also be affected, as explained above.</short>
</element>

<!-- argument Visibility: default -->
<element name="HelpControl.Flags">
<short>Currently, <link id="HC_GADGETHELP"/> or zero are the allowed values.
</short>
</element>

<!-- procedure Visibility: default -->
<element name="InitRequester">
<short>Initialize a Requester structure.</short>
<descr>
<p>Initializes a requester for general use.  After calling <i>InitRequester</i>,
  you need fill in only those Requester values that fit your needs.
  The other values are set to nil--or zero--states.</p>
<p>
  Note that the example in the early versions of the Intuition
  Reference Manual is flawed because the Requester structure is
  initialized <b>before</b> InitRequester is called.  Be sure to
  perform your initialization <b>after</b> calling <i>InitRequester</i>.
</p>
</descr>
<errors>
This function is <b>obsolete</b>.
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="InitRequester.Requester">
<short>A pointer to a Requester structure</short>
</element>

<!-- function Visibility: default -->
<element name="IntuiTextLength">
<short>Return the length (pixel-width) of an IntuiText.</short>
<descr>
<p>This routine accepts a pointer to an instance of an IntuiText structure,
  and returns the length (the pixel-width) of the string which that
  instance of the structure represents.</p>
<p>
  <b>Note:</b> if the Font pointer of your IntuiText structure is set to nil,
  you'll get the pixel-width of your text in terms of the current system
  default font.  You may wish to be sure that the field <link id="TIntuiText">IText</link>^.ITextFont
  for 'default font' text is equal to the Font field of the screen it is
  being measured for.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IntuiTextLength.Result">
<short>The width of the text in pixels.</short>
</element>

<!-- argument Visibility: default -->
<element name="IntuiTextLength.iText">
<short>A pointer to an instance of an IntuiText structure</short>
</element>

<!-- function Visibility: default -->
<element name="ItemAddress">
<short>Returns the address of the specified MenuItem.</short>
<descr>
<p>This routine feels through the specified menu strip and returns the
  address of the item specified by the menu number.  Typically,
  you will use this routine to get the address of a menu item from
  a menu number sent to you by Intuition after user has chosen from
  a window's menus.</p>
<p>
  This routine requires that the arguments are well-defined.
  MenuNumber may be equal to <link id="MENUNULL"/>, in which case this routine returns
  nil.  If MenuNumber doesn't equal <link id="MENUNULL"/>, it's presumed to be a
  valid item number selector for your menu strip, which includes:</p>
<ul>
  <li>a valid menu number</li>
  <li>a valid item number</li>
  <li>if the item specified by the above two components has a
      sub-item, the menu number may have a sub-item component, too.</li>
</ul>
<p>
  Note that there must be <b>both</b> a menu number and an item number.
  Because a sub-item specifier is optional, the address returned by
  this routine may point to either an item or a sub-item.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ItemAddress.Result">
<short>If MenuNumber = <link id="MENUNULL"/>, this routine returns nil,
  else this routine returns the address of the menu item specified
  by <i>MenuNumber</i>.</short>
</element>

<!-- argument Visibility: default -->
<element name="ItemAddress.MenuStrip">
<short>A pointer to the first menu in your menu strip</short>
</element>

<!-- argument Visibility: default -->
<element name="ItemAddress.MenuNumber">
<short>The value which contains the packed data that selects
the menu and item (and sub-item).  See the Intuition Reference
Manual for information on menu numbers.</short>
</element>

<!-- procedure Visibility: default -->
<element name="LendMenus">
<short>Lend window's menu action to another window.</short>
<descr>
<p>This function is used to "lend" the menus of one window to
  another.  This means that menu events (for example, the user
  presses the mouse menu button) will take place in another
  window's menu (using that other window's menu strip and screen).</p>
<p>
  The sole intended use of this function is to unify two
  windows on different screens that are attached.  (See
  <link id="SA_Parent"/>, <link id="SA_FrontChild"/>, <link id="SA_BackChild"/>).  An example would
  be a program with a full-sized parent screen which has a
  short control panel screen attached in the front.  Pressing the
  menu button even when the control panel window of the canvas
  screen is active can now cause the menus of the parent screen
  to appear.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetMenuStrip"/>
<link id="ClearMenuStrip"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="LendMenus.FromWindow">
<short>A pointer to the Window structure whose menu actions
      are to go to another window.</short>
</element>

<!-- argument Visibility: default -->
<element name="LendMenus.ToWindow">
<short>A pointer to the Window structure whose menus are to
      be displayed in place of the fromWindow's.  If nil, turns
      off menu-lending from the fromWindow.</short>
</element>

<!-- function Visibility: default -->
<element name="LockIBase">
<short>Invoke semaphore arbitration of <link id="TIntuitionBase"/>.</short>
<descr>
<p>Grabs Intuition internal semaphore so that caller may examine
  <link id="TIntuitionBase"/> safely.  This function is not a magic "fix all my
  race conditions" panacea.</p>
<p>
  The idea here is that you can get the locks Intuition needs before
  such IntuitionBase fields as <link id="TIntuitionBase">ActiveWindow</link> and <link id="TIntuitionBase">FirstScreen</link> are
  changed, or linked lists of windows and screens are changed.</p>
<p>
  Do Not Get Tricky with this entry point, and do not hold these locks
  for long, as all Intuition input processing will wait for you to
  surrender the lock by a call to <link id="UnlockIBase">UnlockIBase()</link>.</p>
<p>
  <b>Note Well:</b> A call to this function <b>must</b> be paired with a subsequent
  call to <link id="UnlockIBase">UnlockIBase()</link>, and soon, please.</p>
<p>
  <b>Note Well:</b> Do not call any Intuition functions (nor any graphics,
  layers, dos, or other high-level system function) while
  holding this lock.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="UnlockIBase"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockIBase.Result">
<short>The result of this function must be passed to <link id="UnlockIBase">UnlockIBase()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="LockIBase.LockNumber">
<short>Which fields of Intuition should be locked. The only allowed
    value for this is currently 0 which means to lock everything.</short>
</element>

<!-- function Visibility: default -->
<element name="LockPubScreen">
<short>Prevent a public screen from closing.</short>
<descr>
<p>
Prevents a public screen (or the Workbench) from closing
while you examine it in preparation of opening a visitor window.</p>
<p>
  The sequence you use to open a visitor window that needs to
  examine fields in the screen it is about to open on is:</p>
<code>
  LockPubScreen();
  // ... examine fields ...
  OpenWindow(); //on public screen
  UnlockPubScreen();
  // ... use your window ...
  // CloseWindow();
</code>
<p>You needn't hold the "pubscreen lock" for the duration that
  your window is opened. <i>LockPubScreen()</i> basically has the
  same effect as an open visitor window: it prevents the
  screen from being closed.</p>
<p>
  If you pass the string 'Workbench' or you pass nil and there
  is no default public screen, the Workbench screen will
  be automatically opened if it is not already present.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
<link id="UnlockPubScreen"/>
<link id="GetScreenData"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockPubScreen.Result">
<short>Returns pointer to a screen, if successful, else nil.
  The call can fail for reasons including that the named
  public screen doesn't exist or is in private state.</short>
</element>

<!-- argument Visibility: default -->
<element name="LockPubScreen.Name">
<short>Name string for public screen or NULL for default public screen.  The string 'Workbench' indicates the Workbench
  screen.</short>
</element>

<!-- function Visibility: default -->
<element name="LockPubScreenList">
<short>Prevent changes to the system list.</short>
<descr>
<p>Arbitrates access to public screen list  while you quickly
  make a copy of it for display to the user.</p>
<p>
  Note that this is intended only for the Public Screen Manager
  program.</p>
<p><b>Note:</b></p>
<p>
  The nodes on the list are PubScreenNode structures.
  Act quickly while holding this lock.  The restrictions
  on <link id="LockIBase">LockIBase()</link> apply here as well.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="UnlockPubScreenList"/>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LockPubScreenList.Result">
<short>A pointer to the public screen list.</short>
</element>

<!-- function Visibility: default -->
<element name="MakeClass">
<short>Create and initialize a boopsi class.</short>
<descr>
<p>For class implementors only.</p>
<p>
  This function creates a new public or private boopsi class.
  The superclass should be defined to be another boopsi class:
  all classes are descendants of the class "rootclass".</p>
<p>
  Superclasses can be public or private.  You provide a name/ID
  for your class if it is to be a public class (but you must
  have registered your class name and your attribute ID's with
  Commodore before you do this!).  For a public class, you would
  also call <link id="AddClass">AddClass()</link> to make it available after you have
  finished your initialization.</p>
<p>
  Returns pointer to an <link id="TIClass"/> data structure for your
  class.  You then initialize the Hook cl_Dispatcher for
  your class methods code.  You can also set up special data
  shared by all objects in your class, and point <link id="TIClass">cl_UserData</link> at it.
  The last step for public classes is to call <link id="AddClass">AddClass()</link>.</p>
<p>
  You dispose of a class created by this function by calling
  <link id="FreeClass">FreeClass()</link>.
</p>
<p>No copy is made of <i>classID</i>. So make sure the lifetime of the contents
of <i>classID</i> is at least the same as the lifetime of the class itself.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeClass"/>
<link id="AddClass"/>
<link id="RemoveClass"/>
<link id="NewObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MakeClass.Result">
<short>A pointer to the resulting class, or nil if not possible:
no memory for class data structure, public superclass not found, public class of same name/ID as this one already exists
</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeClass.ClassID">
<short>Nil for private classes, the name/ID string for public
    classes</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeClass.SuperClassID">
<short>Name/ID of your new class's superclass.  Nil if
    superclass is a private class</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeClass.SuperClassPtr">
<short>A pointer to private superclass.  Only used if
    <i>SuperClassID</i> is nil.  You are required never to provide
    a nil superclass.</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeClass.InstanceSize">
<short>The size of the instance data that your class's
    objects will require, beyond that data defined for
    your superclass's objects.</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeClass.Flags">
<short>For future enhancement, including possible additional
    parameters.  Provide zero for now.
</short>
</element>

<!-- function Visibility: default -->
<element name="MakeScreen">
<short>Do an Intuition-integrated <link id="AGraphics.MakeVPort">MakeVPort()</link> of a screen.</short>
<descr>
<p>This procedure allows you to do a <link id="AGraphics.MakeVPort">MakeVPort()</link> for the viewport of your
  custom screen in an Intuition-integrated way.  This way you can
  do your own screen manipulations without worrying about interference
  with Intuition's usage of the same viewport.</p>
<p>
  The operation of this function is as follows:</p>
<ul>
  <li>Block until the Intuition View structure is not in being changed.</li>
  <li>Set the view modes correctly to reflect if there is a (visible) interlaced screen.</li>
  <li>call <link id="AGraphics.MakeVPort">MakeVPort()</link>, passing the Intuition View and your screen's ViewPort.</li>
  <li>Unlocks the Intuition View.</li>
</ul>
<p>
  After calling this routine, you should call <link id="RethinkDisplay">RethinkDisplay()</link> to
  incorporate the new viewport of your custom screen into the
  Intuition display.</p>
<p>
  <b>Note:</b> Intuition may determine that because of a change in global
  interlace needs that all viewports need to be remade, so
  it may effectively call <link id="RemakeDisplay">RemakeDisplay()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="RemakeDisplay"/>
<link id="RethinkDisplay"/>
<link id="AGraphics.MakeVPort">MakeVPort</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MakeScreen.Result">
<short>Returns zero for success, non-zero for failure.
  Probable cause of failure is failure of <link id="AGraphics.MakeVPort">MakeVPort()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="MakeScreen.Screen">
<short>Address of the custom screen structure</short>
</element>

<!-- function Visibility: default -->
<element name="ModifyIDCMP">
<short>Modify the state of a window's IDCMPFlags.</short>
<descr>
<p>
  This routine modifies the state of your window's IDCMP (Intuition
  Direct Communication Message Port).  The state is modified to reflect
  your desires as described by the flag bits in the value <i>IDCMPFlags</i>.</p>
<p>
  The four actions that might be taken are:</p>
<ul>
  <li>if there is currently no IDCMP in the given window, and <i>IDCMPFlags</i>
      is zero, nothing happens</li>
  <li>if there is currently no IDCMP in the given window, and any of the
      <i>IDCMPFlags</i> is selected (set), then the IDCMP of the window is
      created, including allocating and initializing the message ports
      and allocating a signal bit for your port.</li>
  <li>if the IDCMP for the given window exists, and the
      <i>IDCMPFlags</i> argument is zero, this says that you want
      Intuition to close the ports, free the buffers and free
      your signal bit.  You MUST be the same task that was active
      when this signal bit was allocated (either by <i>ModifyIDCMP()</i>
      or <link id="OpenWindow">OpenWindow()</link>).</li>
  <li>if the IDCMP for the given window is opened, and the <i>IDCMPFlags</i>
      argument is not zero, this means that you want to change the
      state of which events will be broadcast to you through the IDCMP</li>
</ul>
<p>
  <b>Note:</b> You can set up the <link id="TWindow">Window^.UserPort</link> to any port of your own
  before you call <i>ModifyIDCMP()</i>.  If <i>IDCMPFlags</i> is non-null but
  your UserPort is already initialized, Intuition will assume that
  it's a valid port with task and signal data preset and Intuition
  won't disturb your set-up at all, Intuition will just allocate
  the Intuition message port half of it.  The converse is true
  as well:  if UserPort is nil when you call here with
  IDCMPFlags = 0, Intuition will deallocate only the Intuition
  side of the port.</p>
<p>
  This allows you to use a port that you already have allocated:</p>
<ul>
  <li><link id="OpenWindow">OpenWindow()</link> with <i>IDCMPFlags</i> equal to 0 (open no ports)</li>
  <li>set the <link id="TWindow">UserPort</link> variable of your window to any valid port of your
      own choosing</li>
  <li>call <i>ModifyIDCMP()</i> with IDCMPFlags set to what you want</li>
  <li>then, to clean up later, set <link id="TWindow">UserPort</link> equal to nil before calling
      <link id="CloseWindow">CloseWindow()</link> (leave <i>IDCMPFlags</i> alone)
      <b>But first:</b> you must make
      sure that no messages sent your window are queued at the port,
      since they will be returned to the memory free pool.</li>
</ul>
<p>
  For an example of how to close a window with a shared IDCMP,
  see the description for <link id="CloseWindow">CloseWindow()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
<link id="CloseWindow"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ModifyIDCMP.Result">
<short>This function returns False if it was unable
  to create the necessary message ports.</short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyIDCMP.Window">
<short>A pointer to the Window structure containing the IDCMP ports</short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyIDCMP.Flags">
<short>The flag bits describing the new desired state of
    the IDCMP. (IDCMP_*)</short>
</element>

<!-- procedure Visibility: default -->
<element name="ModifyProp">
<short>Modify the current parameters of a proportional gadget.</short>
<descr>
<p>
  Modifies the parameters of the specified proportional gadget.  The
  gadget's internal state is then recalculated and the imagery
  is redisplayed in the window or requester that contains the gadget.</p>
<p>
  The <i>requester</i> variable can point to a requester structure.  If the
  gadget has the <link id="GTYP_REQGADGET"/> flag set, the gadget is in a requester
  and the window pointer must point to the window of the requester.
  If this is not the gadget of a requester, the requester argument may
  be nil.</p>
<p>
  <b>Note:</b> this function causes all gadgets from the proportional
  gadget to the end of the gadget list to be refreshed, for
  reasons of compatibility.
  For more refined display updating, use <link id="NewModifyProp">NewModifyProp()</link>.</p>
<p>
  <i>ModifyProp()</i> refreshing consists of redrawing gadgets
  completely.  <link id="NewModifyProp">NewModifyProp()</link> has changed this behavior.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NewModifyProp"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.Gadget">
<short>A pointer to a proportional gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.Window">
<short>A pointer to the window containing the gadget or the window
      containing the requester containing the gadget.</short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.Requester">
<short>A pointer to a requester (may be nil if this isn't
      a requester gadget)</short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.Flags">
<short>Value to be stored in the Flags field of the <link id="TPropInfo"/></short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.HorizPot">
<short>Value to be stored in the HorizPot field of the <link id="TPropInfo"/></short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.VertPot">
<short>Value to be stored in the VertPot field of the <link id="TPropInfo"/></short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.HorizBody">
<short>Value to be stored in the HorizBody field of the <link id="TPropInfo"/></short>
</element>

<!-- argument Visibility: default -->
<element name="ModifyProp.VertBody">
<short>Value to be stored in the VertBody field of the <link id="TPropInfo"/></short>
</element>

<!-- procedure Visibility: default -->
<element name="MoveScreen">
<short>Attempt to move the screen by the increments provided.</short>
<descr>
<p>Moves the screen the specified increment, specified in screen
  pixel resolution coordinates.</p>
<p>
  Screen movement limits have been greatly relaxed,
  to support screen scrolling.  In particular, negative values
  for screen LeftEdge and TopEdge may now be valid.</p>
<p>
  If the <i>dX</i> and <i>dY</i> variables you specify would move the screen
  in a way that violates any restrictions, the screen will be moved
  as far as possible.  You may examine the <i>LeftEdge</i> and <i>TopEdge</i> fields
  of the Screen structure after this function returns to see where
  the screen really ended up.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ScreenPosition"/>
<link id="RethinkDisplay"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="MoveScreen.Screen">
<short>A pointer to a Screen structure</short>
</element>

<!-- argument Visibility: default -->
<element name="MoveScreen.Dx">
<short>Amount to move the screen on the x-axis</short>
</element>

<!-- argument Visibility: default -->
<element name="MoveScreen.Dy">
<short>Amount to move the screen on the y-axis</short>
</element>

<!-- procedure Visibility: default -->
<element name="MoveWindow">
<short>Ask Intuition to move a window.</short>
<descr>
<p>This routine sends a request to Intuition asking to move the window
  the specified distance.  The delta (dX, dY) arguments describe how far to
  move the window along the respective axes.</p>
<p>
  Note that the window will not be moved immediately, but rather
  will be moved the next time Intuition receives an input event,
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.</p>
<p>
  Interactions with other arbitration of Intuition data structures
  may defer this operation longer. You can use the
  IDCMP class <link id="IDCMP_CHANGEWINDOW"/> to detect when this operation has
  completed.</p>
<p>
  Intuition now will do validity checking on the final
  position.  To send absolute movements, or to move and size a
  window in one step, use <link id="ChangeWindowBox">ChangeWindowBox()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ChangeWindowBox"/>
<link id="SizeWindow"/>
<link id="WindowToFront"/>
<link id="WindowToBack"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="MoveWindow.Window">
<short>A pointer to the structure of the Window to be moved</short>
</element>

<!-- argument Visibility: default -->
<element name="MoveWindow.Dx">
<short>How far to move the Window on the x-axis</short>
</element>

<!-- argument Visibility: default -->
<element name="MoveWindow.Dy">
<short>How far to move the Window on the y-axis</short>
</element>

<!-- procedure Visibility: default -->
<element name="MoveWindowInFrontOf">
<short>Arrange the relative depth of a window.</short>
<descr>
Depth-arranges a window in front of an another window.
Brings out the <link id="layers.MoveLayerInFrontOf">MoveLayerInFrontOf()</link> to the
Intuition user.
</descr>
<errors>
</errors>
<seealso>
<link id="WindowToFront"/>
<link id="WindowToBack"/>
<link id="layers.MoveLayerInFrontOf">MoveLayerInFrontOf</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="MoveWindowInFrontOf.Window">
<short>Window to re-position in front of another window</short>
</element>

<!-- argument Visibility: default -->
<element name="MoveWindowInFrontOf.BehindWindow">
<short>Window to re-position in front of</short>
</element>

<!-- procedure Visibility: default -->
<element name="NewModifyProp">
<short><link id="ModifyProp">ModifyProp()</link>, but with selective refresh.</short>
<descr>
<p>Performs the function of <i>ModifyProp()</i>, but refreshes
  gadgets in the list as specified by the NumGad parameter.
  With <i>NumGad</i> = -1, this function is identical to <i>ModifyProp()</i>.</p>
<p>
  When <i>NumGad</i> = 1, this function will now perform
  an incremental update of the proportional gadget knob image,
  rather than refreshing the entire gadget.  This means much
  less flashing when programmatically scrolling a proportional
  gadget.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ModifyProp"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.Gadget">
<short>A pointer to a proportional gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.Window">
<short>A pointer to the window containing the gadget or the window
      containing the requester containing the gadget.</short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.Requester">
<short>A pointer to a requester (may be nil if this isn't
      a requester gadget)</short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.Flags">
<short>Value to be stored in the Flags field of the <link id="TPropInfo"/></short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.HorizPot">
<short>Value to be stored in the HorizPot field of the </short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.VertPot">
<short>Value to be stored in the VertPot field of the </short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.HorizBody">
<short>Value to be stored in the HorizBody field of the </short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.VertBody">
<short>Value to be stored in the VertBody field of the </short>
</element>

<!-- argument Visibility: default -->
<element name="NewModifyProp.NumGad">
<short>Number of gadgets to be refreshed after propgadget internals
      have been adjusted.  -1 means "to end of list."</short>
</element>

<!-- function Visibility: default -->
<element name="NewObjectA">
<short>Create an object from a class.</short>
<descr>
<p>This is the general method of creating objects from 'boopsi' classes.
  ('Boopsi' stands for "basic object-oriented programming system for
  Intuition".)</p>
<p>
  You specify a class either as a pointer (for a private class) or
  by its ID string (for public classes).  If the class pointer
  is nil, then the classID is used.</p>
<p>
  You further specify initial "create-time" attributes for the
  object via a TagItem list, and they are applied to the resulting
  generic data object that is returned.  The attributes, their meanings,
  attributes applied only at create-time, and required attributes
  are all defined and documented on a class-by-class basis.</p>
<p>This functions send <link id="OM_NEW"/> to the dispatcher of the class.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="NewObject"/>
<link id="DisposeObject"/>
<link id="SetAttrs"/>
<link id="GetAttr"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NewObjectA.Result">
<short>A boopsi object, which may be used in different contexts such
  as a gadget or image, and may be manipulated by generic functions.
  You eventually free the object using <link id="DisposeObject">DisposeObject()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="NewObjectA.ClassPtr">
<short>An abstract pointer to a boopsi class gotten via <link id="MakeClass">MakeClass()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="NewObjectA.ClassID">
<short>The name/ID string of a public class.  This parameter is only used if <i>class</i> is nil.</short>
</element>

<!-- argument Visibility: default -->
<element name="NewObjectA.TagList">
<short>A pointer to array of <link id="utility.TTagItem">TTagItems</link> containing attribute/value
    pairs to be applied to the object being created</short>
</element>

<!-- function Visibility: default -->
<element name="NextObject">
<short>Iterate through the object on an Exec list.</short>
<descr>
<p>Use this function to iterate through a list of BOOPSI objects.
You may do whatever you want with the object returned, even
remove it from the list or dispose it, and then continue to
iterate through the list.</p>
<p>When you collect a set of boopsi objects on an Exec List
  structure by invoking their <link id="OM_ADDMEMBER"/> method, you
  can (only) retrieve them by iterations of this function.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DisposeObject"/>
<link id="SetAttrs"/>
<link id="GetAttr"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NextObject.Result">
<short>Returns pointers to each object in the list in turn, and nil
  when there are no more.</short>
</element>

<!-- argument Visibility: default -->
<element name="NextObject.ObjectPtrPtr">
<short>The pointer to a variable. This must be the same
    variable, as long as you iterate though the same list. This
    variable must initially be filled with the <link id="Exec.TList">lh_Head</link> of a list.</short>
</element>

<!-- function Visibility: default -->
<element name="NextPubScreen">
<short>Identify next public screen in the cycle.</short>
<descr>
<p>Returns name of next public screen in system rotation, to
  allow visitor windows to provide function to "jump" among
  public-screens in a cycle.</p>
<p><b>Notes:</b></p>
<p>
  There is no guarantee that the public screen whose name
  was returned by this function will exist or be in "public" state
  by the time you call <link id="LockPubScreen">LockPubScreen()</link>, etc.  You must handle
  cases where <link id="LockPubScreen">LockPubScreen()</link>, etc. will fail.</p>
<p>
  Note that this function may return the name of a public screen
  which is open but in "private mode" (see <link id="PubScreenStatus">PubScreenStatus()</link> and
  <link id="PSNF_PRIVATE"/>).</p>
<p>The cycle order is undefined, so draw no conclusions based on it!</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
<link id="PubScreenStatus"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NextPubScreen.Result">
<short>Returns <i>namebuff</i> or nil if there are no public screens.</short>
</element>

<!-- argument Visibility: default -->
<element name="NextPubScreen.Screen">
<short>A pointer to the public screen your window is open in or
       nil if you don't have a pointer to a public screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="NextPubScreen.Namebuf">
<short>A pointer to a buffer with (at least) <link id="MAXPUBSCREENNAME"/> + 1
       characters to put the name of the next public screen in.</short>
</element>

<!-- function Visibility: default -->
<element name="ObtainGIRPort">
<short>Set up a RastPort for a custom gadget.</short>
<descr>
<p>Sets up a RastPort for use (only) by custom gadget hook routines.
  This function must be called <b>each</b> time a hook routine needing
  to perform gadget rendering is called, and must be accompanied
  by a corresponding call to <link id="ReleaseGIRPort">ReleaseGIRPort()</link>.</p>
<p>
  Note that if a hook function passes you a RastPort pointer,
  e.g., <link id="GM_RENDER"/>, you needn't call <i>ObtainGIRPort()</i> in that case.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ReleaseGIRPort"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ObtainGIRPort.Result">
<short>A pointer to a RastPort that may be used for gadget rendering.
  This pointer may be nil, in which case you should do no rendering.
  You may (optionally) pass a nil return value to Rele<link id="ReleaseGIRPort">ReleaseGIRPort()</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="ObtainGIRPort.GInfo">
<short>A pointer to a GadgetInfo structure, as passed to each custom
  gadget hook function.</short>
</element>

<!-- procedure Visibility: default -->
<element name="OffGadget">
<short>Disable the specified gadget.</short>
<descr>
<p>This command disables the specified gadget.  When a gadget is
  disabled, these things happen:</p>
  <ul>
    <li>its imagery is displayed ghosted</li>
    <li>the GFLG_DISABLED flag is set</li>
    <li>the gadget cannot be selected by User</li>
  </ul>
<p>
  The window parameter must point to the window which contains the
  gadget, or which contains the requester that contains the gadget.
  The requester parameter must only be valid if the gadget has the
  <link id="GTYP_REQGADGET"/> flag set, a requirement for all requester gadgets.</p>
<p>
  <b>Note:</b>it's never safe to tinker with the gadget list yourself.  Don't
  supply some gadget that Intuition hasn't already processed in
  the usual way.</p>
<p>
  <b>Note:</b> This function will update the gadget (unlike the original function
  which would update all gadgets in the window).</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OnGadget"/>
<link id="AddGadget"/>
<link id="RefreshGadgets"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="OffGadget.Gadget">
<short>A pointer to the gadget that you want disabled</short>
</element>

<!-- argument Visibility: default -->
<element name="OffGadget.Window">
<short>A pointer to a window structure containing the gadget or
      containing the requester which contains the gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="OffGadget.Requester">
<short>A pointer to a requester (may by nil if this isn't a requester gadget (i.e. <link id="GTYP_REQGADGET"/> is not set)).</short>
</element>

<!-- procedure Visibility: default -->
<element name="OffMenu">
<short>Disable the given menu or menu item.</short>
<descr>
<p>This command disables a sub-item, an item, or a whole menu.
  This depends on the contents of the data packed into <i>MenuNumber</i>,
  which is described in the Intuition Reference Manual.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OnMenu"/>
<link id="ResetMenuStrip"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="OffMenu.Window">
<short>A pointer to the window</short>
</element>

<!-- argument Visibility: default -->
<element name="OffMenu.MenuNumber">
<short>The menu piece to be disabled</short>
</element>

<!-- procedure Visibility: default -->
<element name="OnGadget">
<short>Enable the specified gadget.</short>
<descr>
<p>This command enables the specified gadget.  When a gadget is
  enabled, these things happen:</p>
  <ul>
    <li>its imagery is displayed normally (not ghosted)</li>
    <li>the <link id="GFLG_DISABLED"/> flag is cleared</li>
    <li>the gadget can thereafter be selected by the user</li>
  </ul>
<p>
  The window parameter must point to the window which contains the
  gadget, or which contains the requester that contains the gadget
  The requester parameter must only be valid if the gadget has the
  <link id="GTYP_REQGADGET"/> flag set, a requirement for all requester gadgets.</p>
<p>
  <b>Note:</b> it's never safe to tinker with the gadget list yourself.  Don't
  supply some gadget that Intuition hasn't already processed in
  the usual way.</p>
<p>
  <b>Note:</b> This function will update the gadget (unlike the original function
  which would update all gadgets in the window).</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OffGadget"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="OnGadget.Gadget">
<short>A pointer to the gadget that you want disabled</short>
</element>

<!-- argument Visibility: default -->
<element name="OnGadget.Window">
<short>A pointer to a window structure containing the gadget or
      containing the requester which contains the gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="OnGadget.Requester">
<short>A pointer to a requester (may by nil if this isn't a requester gadget (i.e. <link id="GTYP_REQGADGET"/> is not set)).
</short>
</element>

<!-- procedure Visibility: default -->
<element name="OnMenu">
<short>Enable the given menu or menu item.</short>
<descr>
<p>This command enables a sub-item, an item, or a whole menu.
  This depends on the contents of the data packed into MenuNumber,
  which is described in the Intuition Reference Manual.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OffMenu"/>
<link id="ResetMenuStrip"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="OnMenu.Window">
<short>A pointer to the window</short>
</element>

<!-- argument Visibility: default -->
<element name="OnMenu.MenuNumber">
<short>The menu piece to be enables</short>
</element>

<!-- function Visibility: default -->
<element name="OpenScreen">
<short>Open an Intuition screen</short>
<descr>
<p>Opens an Intuition screen according to the specified parameters
  found in the <link id="TNewScreen"/> structure.</p>
<p>
  Does all the allocations, sets up the screen structure and all
  substructures completely, and links this screen's viewport into
  Intuition's View structure.</p>
<p>
  Before you call <i>OpenScreen()</i>, you must initialize an instance of
  a NewScreen structure.  <link id="TNewScreen"/> is a structure that contains
  all of the arguments needed to open a screen.  The <link id="TNewScreen"/>
  structure may be discarded immediately after <i>OpenScreen()</i> returns.</p>
<p>
  The <link id="SHOWTITLE"/> flag is set to True by default when a screen is opened.
  To change this, you must call the routine <link id="ShowTitle">ShowTitle()</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreenTagList"/>
<link id="OpenWindow"/>
<link id="PrintIText"/>
<link id="CloseScreen"/>
<link id="QueryOverscan"/>
<link id="PubScreenStatus"/>
<link id="AGraphics.ModeNotAvailable">ModeNotAvailable</link>
<link id="Diskfont.OpenDiskFont">OpenDiskFont</link>
<link id="AGraphics.GetColorMap">GetColorMap</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OpenScreen.Result">
<short>If all is well, returns the pointer to your new screen
  If anything goes wrong, returns nil, with further error
  specification in the variable pointed to by the <link id="SA_ErrorCode"/>
  data field.</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenScreen.NewScreen">
<short>A pointer to an instance of a NewScreen structure.</short>
</element>

<!-- function Visibility: default -->
<element name="OpenScreenTags">
<short>Varargs Version of <link id="OpenScreenTagList">OpenScreenTagList()</link></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="OpenScreenTagList">
<short><link id="OpenScreen">OpenScreen()</link> with TagItem extension array.</short>
<descr>
<p>Provides an extension to the parameters passed to <link id="OpenScreen">OpenScreen()</link>.
  This extensions is in the form of (a pointer to) an array of
  TagItem structures, which have to fields: <link id="utility.TTagItem">ti_Tag</link>, an ID identifying
  the meaning of the other field, <link id="utility.TTagItem">ti_Data</link>.</p>
<p>
  The tag items can supplement or override the values in NewScreen.
  In fact, you can pass a nil value of the <link id="TNewScreen"/> pointer.
  For that matter, if you pass nil in both arguments, you'll get
  a screen with defaults in all fields, including display mode,
  depth, colors, dimension, title, and so on.  We ask that
  you at least supply a title when you open a screen.</p>
<p>
  If you need a pointer to the screen's bitmap use Screen^.RastPort.BitMap
  instead of @(Screen^.BitMap).</p>
<p>
  If you want DOS requester to appear on your screen you have to do:
</p>
<code>
process := PProcess(FindTask(nil));
process^.pr_WindowPtr := APTR(window);
</code>
<p>
  The old value of <link id="amigados.TProcess">pr_WindowPtr</link> must be reset before you quit your
  program.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OpenScreenTagList.Result">
<short>An open Intuition screen.  Check ErrorCode when Screen is returned nil.</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenScreenTagList.NewScreen">
<short>An optional pointer to a NewScreen structure.</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenScreenTagList.TagList">
<short>An optional pointer to (an array of) TagItem
      structures, terminated by the value <link id="TAG_END"/>.</short>
</element>

<!-- function Visibility: default -->
<element name="OpenWindow">
<short>Open an Intuition window.</short>
<descr>
<p>
  Opens an Intuition window of the given dimensions and position,
  with the properties specified in the NewWindow structure.
  Allocates everything you need to get going.</p>
<p>
  You can provide extensions to the NewWindow parameters using
  and array of TagItem structures.</p>
<p>
  Before you call <i>OpenWindow()</i>, you must initialize an instance of
  a NewWindow structure.  NewWindow is a structure that contains
  all of the arguments needed to open a window.  The NewWindow
  structure may be discarded immediately after it is used to open
  the window.</p>
<p>
  If <link id="TNewWindow">Type</link> = <link id="CUSTOMSCREEN_f"/>, you must have opened your own screen
  already via a call to OpenScreen().  Then Intuition uses your screen
  argument for the pertinent information needed to get your window
  going.  On the other hand, if <link id="TNewWindow">Type</link> = one of the Intuition's standard
  screens, your screen argument is ignored.  Instead,
  Intuition will check to see whether or not that screen
  already exists:  if it doesn't, it will be opened first before
  Intuition opens your window in the standard screen.</p>
<p>
  If you specify <link id="TNewWindow">Type</link> = <link id="WBENCHSCREEN_f"/>, then your
  window will appear on the Workbench screen, unless the global
  public screen mode <link id="SHANGHAI"/> is set, in which case your window
  will be "hijacked" to the default public screen.  See also
  <link id="SetPubScreenModes">SetPubScreenModes()</link>.</p>
<p>
  If the <link id="WFLG_NW_EXTENDED"/> flag is set, it means that the
  field <link id="TExtNewWindow"/>.Extension points to an array of TagItems.
  This provides an extensible means
  of providing extra parameters to <i>OpenWindow()</i>.  For compatibility
  reasons, we could not add the <i>Extension</i> field to the <link id="TNewWindow"/>
  structure, so we have define a new structure <link id="TExtNewWindow"/>, which
  is identical to <link id="TNewWindow"/> with the addition of the <i>Extension</i> field.</p>
<p>
  We recommend that rather than using <link id="TExtNewWindow"/>.Extension, you
  use the new Intuition function <link id="OpenWindowTagList">OpenWindowTagList()</link> and its
  varargs equivalent <link id="OpenWindowTags">OpenWindowTags()</link>.  We document the window
  attribute tag ID's (<link id="utility.TTagItem">ti_Tag </link> values) here, rather than in
  <link id="OpenWindowTagList">OpenWindowTagList()</link>, so that you can find all the parameters
  for a new window defined in one place.</p>
<p>
  If the <link id="WFLG_SUPER_BITMAP"/> flag is set, the bitmap variable must point
  to your own bitmap.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CloseWindow"/>
<link id="ModifyIDCMP"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OpenWindow.Result">
<short>A pointer to the new window or nil if it couldn't be
opened. Reasons for this might be lack of memory or illegal
attributes.</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenWindow.NewWindow">
<short>A pointer to an instance of a NewWindow structure.</short>
</element>


<!-- function Visibility: default -->
<element name="OpenWindowTags">
<short>Varargs Version of <link id="OpenWindowTagList">OpenWindowTagList()</link> </short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="OpenWindowTagList">
<short><link id="OpenWindow">OpenWindow()</link> with TagItem extension.</short>
<descr>
<p>A variation of <link id="OpenWindow">OpenWindow()</link> that allow direct specification of
  a TagItem array of extension data.  Recommended over using the
  <link id="TExtNewWindow">TExtNewWindow</link>.Extension field.</p>
<p>
  If you omit the <i>NewWindow</i> (pass nil), a set of defaults
  are used, and overridden by the tag items.  Even without
  any tag items at all, a reasonable window opens on the Workbench
  or default public screen.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OpenWindowTagList.Result">
<short>A newly created window, per your specifications.</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenWindowTagList.NewWindow">
<short>A optional pointer to a NewWindow structure.</short>
</element>

<!-- argument Visibility: default -->
<element name="OpenWindowTagList.TagList">
<short>A optional pointer to TagItem array, with tag
    values as described under the description for
    <link id="OpenWindow">OpenWindow()</link>.</short>
</element>

<!-- function Visibility: default -->
<element name="OpenWorkBench">
<short>Open the Workbench screen.</short>
<descr>
<p>
Tries to (re)open WorkBench screen. If successful return value
is a pointer to the screen structure, which shouldn't be used,
because other programs may close the WorkBench and make the
pointer invalid.</p>
<p>
If this function fails the return value is 0.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="CloseWorkBench"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OpenWorkBench.Result">
<short>Non-zero if Workbench screen opened successfully, or was already
    opened. Zero if anything went wrong and the Workbench screen isn't out there.
</short>
</element>

<!-- function Visibility: default -->
<element name="PointInImage">
<short>Tests whether an image "contains" a point.</short>
<descr>
<p>Tests whether a point is properly contained in an image.
  The intention of this is to provide custom gadgets a means
  to delegate "image mask" processing to the Image, where
  it belongs (superseding things like BOOLMASK).  After all,
  a rounded rect image with a drop shadow knows more about
  what points are inside it than anybody else should.</p>
<p>
  For traditional Intuition Images, this routine checks if
  the point is in the <link id="TImage">Image</link> box (LeftEdge/RightEdge/Width/Height).
</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PointInImage.Result">
<short>Boolean result of the test. True is the point is inside the image, False otherwise.

</short>
</element>

<!-- argument Visibility: default -->
<element name="PointInImage.Point">
<short>Two words, X/Y packed into a LongInt, with high word
    containing <i>X</i>.  This is what you get if you pass
    a <link id="AGraphics.TPoint">Point</link> structure (not a pointer!).</short>
</element>

<!-- argument Visibility: default -->
<element name="PointInImage.Image">
<short>A pointer to a standard or custom Image data object.
      <b>Note:</b> If <i>Image</i> is nil, this function returns True.</short>
</element>

<!-- procedure Visibility: default -->
<element name="PrintIText">
<short>Print text described by the IntuiText argument.</short>
<descr>
<p>Prints the IntuiText into the specified RastPort.  Sets up the RastPort
  as specified by the IntuiText values, then prints the text into the
  RastPort at the IntuiText x/y coordinates offset by the left/top
  arguments.  Note, though, that the IntuiText structure itself
  may contain further text position coordinates: those coordinates
  and the <i>Left/TopOffsets</i> are added to obtain the true position of
  the text to be rendered.</p>
<p>
  This routine does window layer clipping as appropriate -- if you
  print text outside of your window, your characters will be
  clipped at the window's edge, providing you pass your window's
  (layered) RastPort.</p>
<p>
  If the <link id="TIntuiText">NextText</link> field of the IntuiText argument is non-nil,
  the next IntuiText is rendered as well, and so on until some
  <link id="TIntuiText">NextText</link> field is nil.</p>
<p>
  IntuiText with the ITextFont field nil are displayed in the
  font of the RastPort.  If the RastPort font is also nil, the
  system default font, as set via the Preferences tool, will be used.
</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="PrintIText.Rp">
<short>The RastPort destination of the text</short>
</element>

<!-- argument Visibility: default -->
<element name="PrintIText.IText">
<short>A pointer to an instance of the structure IntuiText</short>
</element>

<!-- argument Visibility: default -->
<element name="PrintIText.Left">
<short>Left offset of the IntuiText into the RastPort</short>
</element>

<!-- argument Visibility: default -->
<element name="PrintIText.Top">
<short>Top offset of the IntuiText into the RastPort</short>
</element>

<!-- function Visibility: default -->
<element name="PubScreenStatus">
<short>Change status flags for a public screen.</short>
<descr>
<p>Changes status flags for a given public screen.  The only
  flag bit currently defined is <link id="PSNF_PRIVATE"/>.  Thus,
  <i>PubScreenStatus</i>(Screen, <link id="PSNF_PRIVATE"/>); makes a screen
  private, while <i>PubScreenStatus</i>(Screen, 0); makes it public.</p>
<p>
  Do not apply this function to a screen if your program
  isn't the screen's "owner", in particular, don't call
  this function for the Workbench screen.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PubScreenStatus.Result">
<short>Returns 0 in the lowest order bit of the return value
  if the screen wasn't public, or because it can not be taken
  private because visitors are open in it.
  All other bits in the return code are reserved for future
  enhancement.</short>
</element>

<!-- argument Visibility: default -->
<element name="PubScreenStatus.Screen">
<short>A pointer to public screen</short>
</element>

<!-- argument Visibility: default -->
<element name="PubScreenStatus.StatusFlags">
<short>Any of the PSNF_ flags (only <link id="PSNF_PRIVATE"/> is currently defined).</short>
</element>

<!-- function Visibility: default -->
<element name="QueryOverscan">
<short>Inquire about a standard overscan region.</short>
<descr>
<p>This function fills in a rectangle with one of the system
  overscan dimensions, scaled appropriately for the mode of
  the DisplayID it is passed.</p>
<p>
  System overscan values for <i>OScanType</i>:</p>
<dl>
  <dt><link id="OSCAN_TEXT"/>:</dt><dd> completely visible, by user preference.  Used
    for Workbench screen and screen dimensions <link id="STDSCREENWIDTH"/>
    and <link id="STDSCREENHEIGHT"/>.  Left/Top is always 0,0.</dd>
  <dt><link id="OSCAN_STANDARD"/>:</dt><dd> just beyond visible bounds of monitor, by
    user preference.  Left/Top may be negative.</dd>
  <dt><link id="OSCAN_MAX"/>:</dt><dd> The largest region we can display, <b>and</b> display
    any smaller region.</dd>
  <dt><link id="OSCAN_VIDEO"/>:</dt><dd> The absolute largest region that the graphics.library
    can display.  This region must be used as-is.</dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="QueryOverscan.Result">
<short>0 (False) if the MonitorSpec your NewScreen requests
  does not exist.  Non-zero (True) if it does.</short>
</element>

<!-- argument Visibility: default -->
<element name="QueryOverscan.DisplayID">
<short>ID to be queried</short>
</element>

<!-- argument Visibility: default -->
<element name="QueryOverscan.Rect">
<short>Pointer to struct Rectangle to store result</short>
</element>

<!-- argument Visibility: default -->
<element name="QueryOverscan.OScanType">
<short>Overscan type OSCAN_*</short>
</element>

<!-- procedure Visibility: default -->
<element name="RefreshGadgets">
<short>Refresh (redraw) the gadget display.</short>
<descr>
<p>Refreshes (redraws) all of the gadgets in the gadget list starting
  from the specified gadget.</p>
<p>
  The window parameter must point to the window which contains the
  gadget, or which contains the requester that contains the gadget
  The requester parameter must only be valid if the gadget has the
  <link id="GTYP_REQGADGET"/> flag set, a requirement for all requester gadgets.</p>
<p>
  The two main reasons why you might want to use this routine are:
  first, that you've modified the imagery of the gadgets in your
  display and you want the new imagery to be displayed; secondly,
  if you think that some graphic operation you just performed
  trashed the gadgetry of your display, this routine will refresh
  the imagery for you.</p>
<p>
  Note that to modify the imagery of a gadget, you must first remove
  that gadget from the window's gadget list, using <link id="RemoveGadget">RemoveGadget()</link> (or
  <link id="RemoveGList">RemoveGList()</link>).  After changing the image, border, text (including
  text for a string gadget), the gadget is replaced in the gadget list
  (using <link id="AddGadget">AddGadget()</link> or <link id="AddGList">AddGList()</link>).
  Adding gadgets does not cause
  them to be displayed (refreshed), so this function, or <i>RefreshGList()</i>
  is typically called.</p>
<p>
  A common technique is to set or reset the <link id="GFLG_SELECTED"/> flag of a
  Boolean gadget and then call <i>RefreshGadgets()</i> to see it displayed
  highlighted if and only if <link id="GFLG_SELECTED"/> is set.  If you wish to do
  this and be completely proper, you must <link id="RemoveGadget">RemoveGadget()</link>, change the
  <link id="GFLG_SELECTED"/> flag, <link id="AddGadget">AddGadget()</link>, and <i>RefreshGadgets()</i>,
  or the equivalent.</p>
<p>
  The gadgets argument can be a copy of the FirstGadget variable in
  the Window structure that you want refreshed:
  the effect of this will be that all gadgets will be redrawn.
  However, you can selectively refresh just some of the gadgets
  by starting the refresh part-way into the list:  for instance,
  redrawing your window non-<link id="GTYP_GZZGADGET"/> gadgets only, which you've
  conveniently grouped at the end of your gadget list.</p>
<p>
  Even more control is available using the <link id="RefreshGList">RefreshGList()</link> routine which
  enables you to refresh a single gadget, or number of your choice.</p>
<p>
  <b>Note:</b> It's never safe to tinker with the gadget list yourself.  Don't
  supply some gadget list that Intuition hasn't already processed in
  the usual way.</p>
<p><b>Example:</b></p>
<code>
//Refresh all gadgets of a window
RefreshGadgets(Win^.FirstGadget, Win, nil);
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="RefreshGList"/>
<link id="RemoveGadget"/>
<link id="RemoveGList"/>
<link id="AddGadget"/>
<link id="AddGList"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGadgets.Gadgets">
<short>A pointer to the first in the list of gadgets wanting refreshment</short>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGadgets.Window">
<short>A pointer to the window containing the gadget or its requester</short>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGadgets.Requester">
<short>A pointer to a requester (ignored if gadget is not attached to a requester).</short>
</element>

<!-- procedure Visibility: default -->
<element name="RefreshGList">
<short>Refresh (redraw) a chosen number of gadgets.</short>
<descr>
<p>Refreshes (redraws) gadgets in the gadget list starting
  from the specified gadget.  At most <i>NumGad</i> gadgets are redrawn.
  If <i>NumGad</i> is -1, all gadgets until a terminating nil value
  in the NextGadget field is found will be refreshed, making this
  routine a superset of RefreshGadgets().</p>
<p>
  The Requester parameter can point to a Requester structure.  If
  the first gadget in the list has the <link id="GTYP_REQGADGET"/> flag set, the
  gadget list refers to gadgets in a requester and the pointer
  must necessarily point to a window.  If these are not the gadgets
  of a requester, the requester argument may be nil.</p>
<p>
  Be sure to see the <link id="RefreshGadgets">RefreshGadgets()</link> function description, as this
  function is simply an extension of that.</p>
<p><b>Example:</b></p>
<code>
// Refresh one gadget
RefreshGList(@Gadget, Win, nil, 1);

// Refresh all gadgets in the window
RefreshGList(Win^.FirstGadget, Win, nil, -1);
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="RefreshGadgets"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGList.Gadgets">
<short>A pointer to the first in the list of gadgets wanting refreshment</short>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGList.Window">
<short>A pointer to the window containing the gadget or its requester</short>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGList.Requester">
<short>A pointer to a requester (ignored if Gadget is not attached to a Requester).</short>
</element>

<!-- argument Visibility: default -->
<element name="RefreshGList.NumGad">
<short>Maximum number of gadgets to be refreshed.  A value of -1
    will cause all gadgets to be refreshed from gadget to the
    end of the list.  A value of -2 will also do this, but if <i>Gadgets</i>
    points to a Requester Gadget (<link id="GTYP_REQGADGET"/>) ALL gadgets in the
    requester will be refreshed.)
</short>
</element>

<!-- procedure Visibility: default -->
<element name="RefreshWindowFrame">
<short>Ask Intuition to redraw your window border.</short>
<descr>
<p>
  Refreshes the border of a window, including title region and all
  of the window's gadgets.</p>
<p>
  You may use this call if you wish to update the display of your borders.
  The expected use of this is to correct unavoidable corruption.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="RefreshWindowFrame.Window">
<short>A pointer to a Window structure</short>
</element>

<!-- procedure Visibility: default -->
<element name="ReleaseGIRPort">
<short>Release a custom gadget RastPort.</short>
<descr>
The corresponding function to <link id="ObtainGIRPort">ObtainGIRPort()</link>, it releases
  arbitration used by Intuition for gadget RastPorts.
</descr>
<errors>
</errors>
<seealso>
<link id="ObtainGIRPort"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ReleaseGIRPort.Rp">
<short>A pointer to the RastPort returned by <link id="ObtainGIRPort">ObtainGIRPort()</link>.
  This pointer can be nil, in which case nothing happens.</short>
</element>

<!-- function Visibility: default -->
<element name="RemakeDisplay">
<short></short>
<descr>
<p>
  This is the big one.</p>
<p>
  This procedure remakes the entire View structure for the
  Intuition display.  It does the equivalent of <link id="MakeScreen">MakeScreen()</link> for
  every screen in the system, and then it calls the internal
  equivalent of <link id="RethinkDisplay">RethinkDisplay()</link>.</p>
<p>
  <b>Warning:</b>  This routine can take many milliseconds to run, so
  do not use it lightly.</p>
<p>
  Calling <link id="MakeScreen">MakeScreen()</link> followed by <link id="RethinkDisplay">RethinkDisplay()</link> is typically
  a more efficient method for affecting changes to a single
  screen's ViewPort.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="RethinkDisplay"/>
<link id="MakeScreen"/>
<link id="AGraphics.MakeVPort">MakeVPort</link>
<link id="AGraphics.MrgCop">MrgCop</link>
<link id="AGraphics.LoadView">LoadView</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RemakeDisplay.Result">
<short>Returns zero for success, non-zero for failure.
Probable cause of failure is failure of <link id="AGraphics.MakeVPort">MakeVPort()</link>
or of <link id="AGraphics.MrgCop">MrgCop()</link>.</short>
</element>

<!-- procedure Visibility: default -->
<element name="RemoveClass">
<short>Make a public boopsi class unavailable.</short>
<descr>
<p>Makes a public class unavailable for public consumption.
  It's OK to call this function for a class which is not
  yet in the internal public class list, or has been
  already removed.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MakeClass"/>
<link id="FreeClass"/>
<link id="AddClass"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="RemoveClass.ClassPtr">
<short>A pointer to <b>public</b> class created by <link id="MakeClass">MakeClass()</link>,
    may be nil.</short>
</element>

<!-- function Visibility: default -->
<element name="RemoveGadget">
<short>Remove a gadget from a window.
</short>
<descr>
<p>Removes the given gadget from the gadget list of the specified
  window.  Returns the ordinal position of the removed gadget.</p>
<p>
  If the gadget is in a requester attached the the window, this
  routine will look for it and remove it if it is found.</p>
<p>
  If the gadget pointer points to a gadget that isn't in the
  appropriate list, $FFFF is returned.  If there aren't any gadgets in the
  list, $FFFF is returned.  If you remove the 65535th gadget from the list
  $FFFF is returned.</p>
<p>
  <b>Note:</b>
  If one of the gadgets you wish to remove
  is the active gadget, this routine will wait for the user
  to release the mouse button before deactivating and removing
  the gadget.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AddGadget"/>
<link id="AddGList"/>
<link id="RemoveGList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RemoveGadget.Result">
<short>Returns the ordinal position of the removed gadget.  If the gadget
  wasn't found in the appropriate list, or if there are no gadgets in
  the list, returns $FFFF.</short>
</element>

<!-- argument Visibility: default -->
<element name="RemoveGadget.Window">
<short>A pointer to the window containing the gadget or the requester
      containing the gadget to be removed.</short>
</element>

<!-- argument Visibility: default -->
<element name="RemoveGadget.Gadget">
<short>A pointer to the gadget to be removed.  The gadget itself
      describes whether this is a gadget that should be removed from the
      window or some requester.</short>
</element>

<!-- function Visibility: default -->
<element name="RemoveGList">
<short>Remove a sublist of gadgets from a window.</short>
<descr>
<p>Removes <i>Numgad</i> gadgets from the gadget list of the specified
  window.  Will remove gadgets from a requester if the first
  gadget's GadgetType flag <link id="GTYP_REQGADGET"/> is set.</p>
<p>
  Otherwise identical to <link id="RemoveGadget">RemoveGadget()</link>.</p>
<p>
  <b>Note:</b>
  Last gadget's NextGadget field is set to nil.</p>
<p>
  If one of the gadgets you wish to remove
  is the active gadget, this routine will wait for the user
  to release the mouse button before deactivating and removing
  the gadget.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="RemoveGadget"/>
<link id="AddGadget"/>
<link id="AddGList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RemoveGList.Result">
<short>Returns the ordinal position of the removed gadget.  If the gadget
  wasn't found in the appropriate list, or if there are no gadgets in
  the list, returns $FFFF.</short>
</element>

<!-- argument Visibility: default -->
<element name="RemoveGList.RemPtr">
<short>A pointer to the window containing the gadget or the requester
      containing the gadget to be removed.</short>
</element>

<!-- argument Visibility: default -->
<element name="RemoveGList.Gadget">
<short>A pointer to the gadget to be removed.  The gadget itself
describes whether this is a gadget that should be removed
from the window or some requester.</short>
</element>

<!-- argument Visibility: default -->
<element name="RemoveGList.NumGad">
<short>Number of gadgets to be removed.  If $FFFF, remove all gadgets
      to end of window gadget list</short>
</element>

<!-- procedure Visibility: default -->
<element name="ReportMouse">
<short>Tell Intuition whether to report mouse movement.
</short>
<descr>
<p>
  Tells Intuition whether or not to broadcast mouse-movement events to
  your window when it's the active one.  The Boolean value specifies
  whether to start or stop broadcasting position information of
  mouse-movement.  If the window is the active one, mouse-movement reports
  start coming immediately afterwards.  This same routine will change
  the current state of the <link id="GACT_FOLLOWMOUSE"/> function of a
  currently-selected gadget too.</p>
<p>
  Note that calling <i>ReportMouse()</i> when a gadget is selected will only
  temporarily change whether or not mouse movements are reported while
  that gadget remains selected; the next time the gadget is selected, its
  <link id="GACT_FOLLOWMOUSE"/> flag is examined anew.</p>
<p>
  The <i>ReportMouse()</i> function is first performed when <link id="OpenWindow">OpenWindow()</link>
  is first called; if the flag <link id="WFLG_REPORTMOUSE"/> is included among
  the options, then all mouse-movement events are reported
  to the opening task and will continue to be reported
  until <i>ReportMouse()</i> is called with a Boolean value of FALSE.
  If <link id="WFLG_REPORTMOUSE"/> is not set, then no mouse-movement reports will
  be broadcast until <i>ReportMouse()</i> is called with a Boolean of True.</p>
<p>
  Note that the <link id="WFLG_REPORTMOUSE"/> flag, as managed by this routine,
  determines <b>if</b> mouse messages are to be broadcast.  Determining <b>how</b>
  they are to be broadcast is determined by the <link id="IDCMP_MOUSEMOVE"/>
  IDCMPFlag.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ReportMouse.Flag">
<short>True (-1) or False (0) value specifying whether to turn this function on or off</short>
</element>

<!-- argument Visibility: default -->
<element name="ReportMouse.Window">
<short>A pointer to a Window structure associated with this request</short>
</element>

<!-- function Visibility: default -->
<element name="Request">
<short>Activate a requester.</short>
<descr>
Links in and displays a requester into the specified window.
This routine ignores the window's <link id="IDCMP_REQVERIFY"/> flag.
</descr>
<errors>
</errors>
<seealso>
<link id="EndRequest"/>
 <link id="InitRequester"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="Request.Result">
<short>If the requester is successfully opened, True is returned.  Otherwise,
  if the requester could not be opened, False is returned.
</short>
</element>

<!-- argument Visibility: default -->
<element name="Request.Requester">
<short>A pointer to the requester to be displayed.</short>
</element>

<!-- argument Visibility: default -->
<element name="Request.Window">
<short>A pointer to the window into which this requester goes.</short>
</element>

<!-- function Visibility: default -->
<element name="ResetMenuStrip">
<short>Re-attach a menu strip to a window.</short>
<descr>
<p>
  This function is simply a "fast" version of <link id="SetMenuStrip">SetMenuStrip()</link> that
  doesn't perform the precalculations of menu page sizes that
  <link id="SetMenuStrip">SetMenuStrip()</link> does.</p>
<p>
  You may call this function <b>only if</b> the menu strip and all items
  and sub-items have not changed since the menu strip was passed to
  <link id="SetMenuStrip">SetMenuStrip()</link>, with the following exceptions:</p>
<ul>
  <li>You may change the <link id="CHECKED"/> flag to turn a checkmark on or off.</li>
  <li>You may change the <link id="ITEMENABLED"/> flag to enable/disable some
    MenuItem or Menu structures.</li>
</ul>
<p>
  In all other ways, this function performs like SetMenuStrip().</p>
<p>
  The new sequence of events you can use is:</p>
<ul>
  <li><link id="OpenWindow">OpenWindow()</link></li>
  <li><p><link id="SetMenuStrip">SetMenuStrip()</link></p>
  <p>zero or more iterations of:</p>
  <ul>
    <li><link id="ClearMenuStrip">ClearMenuStrip()</link> </li>
    <li>change <link id="CHECKED"/> or <link id="ITEMENABLED"/> flags</li>
    <li><link id="ResetMenuStrip">ResetMenuStrip()</link></li>
  </ul>
  </li>
  <li><link id="ClearMenuStrip">ClearMenuStrip()</link> </li>
  <li><link id="CloseWindow">CloseWindow()</link> </li>
 </ul>
</descr>
<errors>
</errors>
<seealso>
<link id="SetMenuStrip"/>
<link id="ClearMenuStrip"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ResetMenuStrip.Result">
<short>True always.</short>
</element>

<!-- argument Visibility: default -->
<element name="ResetMenuStrip.Window">
<short>A pointer to a Window structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ResetMenuStrip.Menu">
<short>A pointer to the first menu in the menu strip</short>
</element>

<!-- function Visibility: default -->
<element name="RethinkDisplay">
<short>Grand manipulation of the entire Intuition display.</short>
<descr>
<p>
  This function performs the Intuition global display reconstruction.
  This includes rethinking about all of the  ViewPorts and their
  relationship to one another and reconstructing the entire display
  based on the results of this rethinking.</p>
<p>
  Specifically, and omitting many internal details, the operation
  consists of this:</p>
<ul>
  <li>Determine which ViewPorts are invisible and set their <link id="AGraphics.VP_HIDE">VP_HIDE</link>
      ViewPort Mode flag. <link id="AGraphics.VP_HIDE">VP_HIDE</link> flags are also set for screens that
      may not be simultaneously displayed with the frontmost.</li>
  <li>
      If a change to a viewport height, or changing interlace or
      monitor scan rates require, <link id="AGraphics.MakeVPort">MakeVPort()</link> is called for specific
      screen viewports.  After this phase, the intermediate Copper lists
      for each screen's viewport are correctly set up.</li>
  <li>
      <link id="AGraphics.MrgCop">MrgCop()</link> and <link id="AGraphics.LoadView">LoadView()</link>
      are then called to get these Copper lists
      in action, thus establishing the new state of the Intuition
      display.</li>
</ul>
<p>
  You may perform a <link id="MakeScreen">MakeScreen()</link> on your Custom Screen before calling
  this routine.  The results will be incorporated in the new display, but
  changing the interlace ViewPort mode for one screens must be reflected
  in the Intuition View, which is left to Intuition.</p>
<p>
  <b>Warning:</b>  This routine can take several milliseconds to run, so
  do not use it lightly.</p>
<p>
  This routine is substantially changed to support
  new screen modes.  In particular, if screen rearrangement has
  caused a change in interlace mode or scan rate, this routine
  will remake the copper lists for each screen's viewport.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="RemakeDisplay"/>
<link id="AGraphics.MakeVPort">MakeVPort</link>
<link id="AGraphics.MrgCop">MrgCop</link>
<link id="AGraphics.LoadView">LoadView</link>
<link id="MakeScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RethinkDisplay.Result">
<short>Returns zero for success, non-zero for failure.
  Probable cause of failure is failure of <link id="AGraphics.MakeVPort">MakeVPort()</link>
  or of <link id="AGraphics.MrgCop">MrgCop()</link>.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ScreenDepth">
<short>Depth arrange a screen with extra control.</short>
<descr>
<p>Brings the specified screen to the front or back, based on
  the supplied flags.  Also allows control of screen
  depth-arranging within screen families.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ScreenToFront"/>
<link id="ScreenToBack"/>
<link id="SA_Parent"/>
<link id="SA_FrontChild"/>
<link id="SA_BackChild"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ScreenDepth.Screen">
<short>A pointer to the screen to move</short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenDepth.Flags">
<short>One of <link id="SDEPTH_TOFRONT"/> or <link id="SDEPTH_TOBACK"/> (bringing the
      screen to front or back respectively).</short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenDepth.Reserved">
<short>Must be nil for now.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ScreenPosition">
<short>Move screens with greater control.</short>
<descr>
<p>Moves the screen to the specified position or by the specified
  increment, in screen pixel resolution coordinates.</p>
<p>
  If the <i>x1</i> and <i>y1</i> variables you specify would move the screen in
  a way that violates any restrictions, the screen will be moved
  as far as possible.  You may examine the <link id="TScreen">LeftEdge</link> and <link id="TScreen">TopEdge</link>
  fields of the Screen structure after this function returns to
  see where the screen really ended up.</p>
<p>
  <b>Note</b> that negative values for screen <link id="TScreen">LeftEdge</link> and <link id="TScreen">TopEdge</link> are
  valid for screens bigger than their display clip.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MoveScreen"/>
<link id="RethinkDisplay"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ScreenPosition.Screen">
<short>A pointer to a Screen structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenPosition.Flags">
<short>Set to one of <link id="SPOS_RELATIVE"/>, <link id="SPOS_ABSOLUTE"/>, or
    <link id="SPOS_MAKEVISIBLE"/>.   You may additionally set <link id="SPOS_FORCEDRAG"/>
    if you need.  Use <link id="SPOS_RELATIVE"/> (zero) for normal use
    (move screen a relative amount expressed by <i>x1,y1</i>).  Set
    the <link id="SPOS_ABSOLUTE"/> flag if you wish <i>x1</i> and <i>y1</i> to be absolute
    coordinates to move the screen to.  Set <link id="SPOS_MAKEVISIBLE"/> to
    position an oversized scrolling screen so that the rectangle
    described by <i>(x1,y1)-(x2,y2)</i> is on the visible part of
    the display. (A word-processor may wish to support
    autoscrolling as the user types.  In that case, it could
    call <link id="ScreenPosition">ScreenPosition()</link> with the <link id="SPOS_MAKEVISIBLE"/> flag and
    a rectangle that encompasses the cursor with some space
    around it.

    In addition to any one of the above choices, you can
    additionally set <link id="SPOS_FORCEDRAG"/> if you wish to reposition
    a screen that was opened with the [<link id="SA_Draggable"/>, False]
    attribute.</short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenPosition.X1">
<short>Absolute position or change in position you wish to apply
    to the screen, when using <link id="SPOS_ABSOLUTE"/> or <link id="SPOS_RELATIVE"/>.
    </short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenPosition.Y1">
<short>When using <link id="SPOS_MAKEVISIBLE"/>, these variables describe
    the upper-left corner of the rectangle you would like to
    ensure is on the visible part of a scrolling screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenPosition.X2">
<short>Ignored when using <link id="SPOS_ABSOLUTE"/> or <link id="SPOS_RELATIVE"/>.
    When using <link id="SPOS_MAKEVISIBLE"/>, these variables describe
    the lower-right corner of the rectangle you would like to
    ensure is on the visible part of a scrolling screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="ScreenPosition.Y2">
<short>Note that these coordinates are in the same resolution
    as the screen.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ScreenToBack">
<short>Send the specified screen to the back of the display.</short>
<descr>
<p>
Move a screen behind all other screens. If the screen is in a
group, the screen will be moved behind all other screens in the
group only. If the screen is the parent of a group, the whole
group will be moved in the back.</p>
<p>You will see the screen move behind all other screens. If some
screen before this screen occupies the whole display, then it
will disappear completely. If all other screens occupy only part
of the display, the screen will appear behind the screens.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ScreenToFront"/>
<link id="ScreenDepth"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ScreenToBack.Screen">
<short>A pointer to a Screen structure</short>
</element>

<!-- procedure Visibility: default -->
<element name="ScreenToFront">
<short>Make the specified screen the frontmost.</short>
<descr>
<p>Move a screen in front of all other screens. If the screen is in a
group, the screen will be moved in front of all other screens in the
group only. If the screen is the parent of a group, the whole
group will be moved in the front.</p>
<p>You will see the screen move in front of all other screens.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ScreenToBack"/>
<link id="ScreenDepth"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ScreenToFront.Screen">
<short>A pointer to a Screen structure</short>
</element>

<!-- procedure Visibility: default -->
<element name="ScrollWindowRaster">
<short>Scrolls the content of the rectangle</short>
<descr>
<p>Calls <link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link>, which moves
   the bits in the raster by <i>(dx,dy)</i> towards (0,0)
   The space vacated is filled by calling <link id="AGraphics.EraseRect">EraseRect()</link>.</p>
<p>
   <b>Note:</b> that vacated space is <b>not</b> considered damage!
   The scroll operation is limited to the rectangle defined
   by <i>(xmin,ymin)-(xmax,ymax)</i>. Bits outside will not be
   affected. If <i>(xmax,ymax)</i> is outside the rastport then use
   the lower right corner of the rastport.</p>
<p>
   If a window is partly obscured, then it is possible for
   <i>ScrollWindowRaster()</i> to scroll some of the obscured
   area into view.  If the window is simple-refresh, then
   the formerly obscured area is damage, and the application
   needs to repair it.  If Intuition detects damage as a result
   of <i>ScrollWindowRaster()</i>, it will send an <link id="IDCMP_REFRESHWINDOW"/>
   event to the application's window.  This handling of damage
   is the principal reason <i>ScrollWindowRaster()</i> is preferred
   to <link id="AGraphics.ScrollRaster">ScrollRaster()</link> and
   <link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link>.
</p>
<p><b>Note:</b>
  This call uses <link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link>,
  which calls <link id="AGraphics.EraseRect">EraseRect()</link>
  when clearing the newly exposed area. This allows use of
  a custom layer backfill hook.</p>
<p>
  <b>Important:</b>  boopsi gadgets should use <link id="AGraphics.ScrollRaster">ScrollRaster()</link> or
  <link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link> directly!  Never call <i>ScrollWindowRaster()</i>
  from inside a boopsi gadget's method handler.  Note that
  Intuition will detect and handle damage caused by such use
  of <link id="AGraphics.ScrollRaster">ScrollRaster()</link> or
  <link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link>, for gadgets with
  the <link id="GMORE_SCROLLRASTER"/> property.</p>
<p>
  <b>VERY IMPORTANT</b>:  if you have any gadgets in your simple-refresh
  window with the <link id="GMORE_SCROLLRASTER"/> property, you must use
  <i>ScrollWindowRaster()</i> instead of <link id="AGraphics.ScrollRaster">ScrollRaster()</link> or
  <link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link>.
  Handling of gadget scroll damage is incompatible with continued
  use of these graphics functions in an Intuition window.
  NB:  If you're using a gadget class whose source code you do
  not control, that class might be using <link id="GMORE_SCROLLRASTER"/> or
  might start to in a future version.  For that reason, you
  should use <i>ScrollWindowRaster()</i> if you are using any such gadgets.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AGraphics.ScrollRaster">ScrollRaster()</link>
<link id="AGraphics.ScrollRasterBF">ScrollRasterBF()</link>
<link id="AGraphics.EraseRect">EraseRect()</link>
<link id="WA_BackFill"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.Win">
<short>A pointer to a Window structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.Dx">
<short>May be postive, zero, or negative</short>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.Dy">
<short>May be postive, zero, or negative</short>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.XMin">
<short>Left of bounding rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.YMin">
<short>Upper of bounding rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.XMax">
<short>Right of bounding rectangle</short>
</element>

<!-- argument Visibility: default -->
<element name="ScrollWindowRaster.YMax">
<short>Lower of bounding rectangle</short>
</element>

<!-- function Visibility: default -->
<element name="SetAttrsA">
<short>Specify attribute values for an object.</short>
<descr>
<p>Specifies a set of attribute/value pairs with meaning as
  defined by a 'boopsi' object's class.</p>
<p>
  This function does not provide enough context information or
  arbitration for boopsi gadgets which are attached to windows
  or requesters.  For those objects, use <link id="SetGadgetAttrsA">SetGadgetAttrsA()</link>.
</p>
<p><b>Note:</b>
  This function invokes the <link id="OM_SET"/> method with a nil GadgetInfo
  parameter. </p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetAttrs"/>
<link id="NewObject"/>
<link id="DisposeObject"/>
<link id="GetAttr"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetAttrsA.Result">
<short>The object does whatever it wants with the attributes you provide.
  The return value tends to be non-zero if the changes would require
  refreshing gadget imagery, if the object is a gadget.
</short>
</element>

<!-- argument Visibility: default -->
<element name="SetAttrsA.Object_">
<short>An abstract pointer to a boopsi object.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetAttrsA.TagList">
<short>Array of TagItem structures with attribute/value pairs.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SetDefaultPubScreen">
<short>Choose a new default public screen.</short>
<descr>
<p>Establishes a new default public screen for visitor windows.</p>
<p>
  This screen is used by windows asking for a named public screen
  that doesn't exist and the faqllback option is selected, and for
  windows asking for the default public screen directly.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="SetDefaultPubScreen.Name">
<short>name of chosen public screen to be the new default.
  A value of nil means that the Workbench screen is to
  be the default public screen.</short>
</element>

<!-- function Visibility: default -->
<element name="SetDMRequest">
<short>Set the DMRequest of a window.</short>
<descr>
<p>
A DMRequest is a requester that appears if the user double-clicks
with the menu button.
The new DMRequest will only be set if the old DMRequest is not in use.
The official way to change the DMRequest is to call <link id="ClearDMRequest">ClearDMRequest()</link>
until it returns True and then call <link id="SetDMRequest">SetDMRequest()</link>.</p>
<p><b>Note:</b> If the DMRequest has the <link id="POINTREL"/> flag set, the DMR will show up
as close to the pointer as possible. The RelLeft/Top fields are
used to fine-tune the positioning.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ClearDMRequest"/>
<link id="Request"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetDMRequest.Result">
<short>True if old DMRequest was not in use and therefore changed to
the new one, or False if the old DMRequest was in use and could
not be set to the new one.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetDMRequest.Window">
<short>The window from which the DMRequest is to be set</short>
</element>

<!-- argument Visibility: default -->
<element name="SetDMRequest.Requester">
<short>A pointer to the requester
</short>
</element>

<!-- function Visibility: default -->
<element name="SetEditHook">
<short>Set global processing for string gadgets.</short>
<descr>
<p>Sets new global editing hook for string gadgets.</p>
<p>
  <b>Warning:</b> The use and integration of this function has not
  been explored, and thus should be considered a risky function.
  Do <b>not</b> use this in a commercial product until further notice.</p>
<p>
  There are a few key differences between a global edit hook and the
  more famililar per-gadget StringExtend->EditHook field.  In the
  case of the latter, the hook's creator supplies a WorkBuffer.
  Intuition's idea of the result of a keystroke is stored in
  the SGWork structure (which references the WorkBuffer).  The
  state of the gadget before Intuition's hook acted is available in
  the <link id="TStringInfo"/>.Buffer, .BufferPos, and .NumChars fields.</p>
<p>
  In the case of a global editing hook, your hook <b>becomes</b>
  Intuition's hook, which affects all gadgets, most of which
  do not have a WorkBuffer.  This means that if you invoke
  Intuition's original hook (which you got as the result of this
  function), there isn't any easy way for you to "undo" that after
  the fact.  This means that if Intuition's behavior for certain
  keystrokes is incompatible with your hook's objectives, then
  you must avoid calling Intuition's hook for those keys.  One
  approach is to run through your hook's code first, acting on
  those keys you wish to recognize.  Then, call Intuition's
  hook for those keys you do not recognize, or for those keys
  whose default actions you wish to add to.</p>
<p>
  Do not forget to set <link id="SGA_REDISPLAY"/> when needed,
  and please be sure to give the <link id="TSGWork"/>^.EditOp field a value
  which is as meaningful as possible.</p>
<p>
  Currently, only <link id="SGH_KEY"/> messages are sent to the global edit
  hook, though custom edit hooks do receive <link id="SGH_CLICK"/> messages
  in addition.</p>
<p>
  Finally, there is currently no arbitration between a global
  edit hook and a custom edit hook as to ownership of keystrokes.
  It would be fair to expect that a custom edit hook would be
  written to match the current Intuition edit hook.  If your
  global edit hook acts on (say) up and down arrow keystrokes,
  an undesirable result may occur if some string gadget's custom
  hook also acts on these keystrokes.  There is currently
  no easy way to resolve this issue.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetEditHook.Result">
<short>Returns previous global edit hook structure.  You may need this
  hook if you wish to invoke the previous edit hook's behavior
  in addition to your own.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetEditHook.Hook">
<short>A pointer to a struct Hook which determines a function
    in your code to be called every time the user types a key.
    This is done before control is passed to the gadget custom
    editing hook, so affects <b>all</b> string gadgets.</short>
</element>


<!-- function Visibility: default -->
<element name="SetGadgetAttrs">
<short>Varargs Version of <link id="SetGadgetAttrsA">SetGadgetAttrsA()</link> </short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetGadgetAttrsA">
<short>Specify attribute values for a boopsi gadget.</short>
<descr>
<p>Same as <link id="SetAttrsA">SetAttrsA()</link>, but provides context information and
  arbitration for classes which implement custom Intuition gadgets.</p>
<p>
  You should use this function for boopsi gadget objects which have
  already been added to a requester or a window, or for "models" which
  propagate information to gadget already added.</p>
<p>
  Typically, the gadgets will refresh their visuals to reflect
  changes to visible attributes, such as the value of a slider,
  the text in a string-type gadget, the selected state of a button.</p>
<p>
  You can use this as a replacement for <link id="SetAttrsA">SetAttrsA()</link>, too, if you
  specify nil for the <i>Window</i> and <i>Requester</i> parameters.</p>
<p><b>Notes:</b></p>
<p>
  This function invokes the <link id="OM_SET"/> method with a GadgetInfo
  derived from the <i>Window</i> and <i>Requester</i> pointers.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetGadgetAttrs"/>
<link id="NewObject"/>
<link id="DisposeObject"/>
<link id="GetAttr"/>
<link id="MakeClass"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetGadgetAttrsA.Result">
<short>The object does whatever it wants with the attributes you provide,
  which might include updating its gadget visuals.
  The return value tends to be non-zero if the changes would require
  refreshing gadget imagery, if the object is a gadget.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrsA.Gadget">
<short>An abstract pointer to a boopsi gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrsA.Window">
<short>A window gadget has been added to using <link id="AddGList">AddGList()</link> or <link id="AddGadget">AddGadget()</link></short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrsA.Requester">
<short>For <link id="GTYP_REQGADGET"/>s, requester containing the gadget</short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrsA.TagList">
<short>An array of TagItem structures with attribute/value pairs.
</short>
</element>

<!-- function Visibility: default -->
<element name="SetMenuStrip">
<short>Attach a menu strip to a window.
</short>
<descr>
<p>
  Attaches the menu strip to the window.  After calling this routine,
  if the user presses the menu button, this specified menu strip
  will be displayed and accessible by the user.</p>
<p>
  Menus with zero menu items are not allowed.</p>
<p>
  <b>Note:</b> You should always design your menu strip changes to be a
  two-way operation, where for every menu strip you add to your
  window you should always plan to clear that strip sometime.  Even
  in the simplest case, where you will have just one menu strip for
  the lifetime of your window, you should always clear the menu strip
  before closing the window.  If you already have a menu strip attached
  to this window, the correct procedure for changing to a new menu
  strip involves calling <link id="ClearMenuStrip">ClearMenuStrip()</link> to clear the old first.</p>
<p>
  The sequence of events should be:</p>
  <ul>
    <li><link id="OpenWindow">OpenWindow()</link> </li>
    <li><p>zero or more iterations of:</p>
      <ul>
        <li><link id="SetMenuStrip">SetMenuStrip()</link> </li>
        <li><link id="ClearMenuStrip">ClearMenuStrip()</link></li>
      </ul></li>
    <li><link id="CloseWindow">CloseWindow()</link> </li>
  </ul>
</descr>
<errors>
</errors>
<seealso>
<link id="ResetMenuStrip"/>
<link id="ClearMenuStrip"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetMenuStrip.Result">
<short>True if all menus have at least one menuitem.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetMenuStrip.Window">
<short>The window to add the MenuStrip to</short>
</element>

<!-- argument Visibility: default -->
<element name="SetMenuStrip.Menu">
<short>The menu to be added to the window above.</short>
</element>

<!-- function Visibility: default -->
<element name="SetMouseQueue">
<short>Change limit on pending mouse messages.</short>
<descr>
Change the number of mouse messages for your window to be allowed
to be outstanding.
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetMouseQueue.Result">
<short>-1 if <i>Window</i> is not known
  Otherwise the previous value of the queue limit.
  The corresponding function for changing the repeat key
  queue limit is not yet implemented.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetMouseQueue.Window">
<short>Your window</short>
</element>

<!-- argument Visibility: default -->
<element name="SetMouseQueue.QueueLength">
<short>The new value of outstanding mouse movement messages
    you wish to allow.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SetPointer">
<short>Specify a pointer sprite image for a window.</short>
<descr>
<p> Sets up the window with the sprite definition for the pointer.
  Then, whenever the window is the active one, the pointer
  image will change to the window's version.  If the window is
  the active one when this routine is called, the change takes
  place immediately.</p>
<p>
  The <i>XOffset</i> and <i>YOffset</i> parameters are used to offset the
  upper-left corner of the hardware sprite image from what Intuition
  regards as the current position of the pointer.  Another way of
  describing it is as the offset from the "hot spot" of the pointer
  to the top-left corner of the sprite.  For instance, if you specify
  offsets of zero, zero, then the top-left corner of your sprite
  image will be placed at the mouse position.  On the other hand,
  if you specify an <i>XOffset</i> of -7 (remember, sprites are 16 pixels
  wide) then your sprite will be centered over the mouse position.
  If you specify an XOffset of -15, the right-edge of the sprite
  will be over the mouse position.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SetWindowPointerA"/>
<link id="ClearPointer"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="SetPointer.Window">
<short>A pointer to the window to receive this pointer definition</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPointer.Pointer_">
<short>A pointer to the data definition of a sprite</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPointer.Height">
<short>The height of the pointer</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPointer.Width">
<short>The width of the sprite (must be less than or equal to sixteen)</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPointer.XOffset">
<short>The offset for your sprite from the mouse position</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPointer.YOffset">
<short>The offset for your sprite from the mouse position
</short>
</element>

<!-- function Visibility: default -->
<element name="SetPrefs">
<short>Set Intuition preferences data.
</short>
<descr>
<p>Sets new preferences values.  Copies the first <i>Size</i> bytes
  from your preferences buffer to the system preferences table,
  and puts them into effect.</p>
<p>
  The <i>Inform</i> parameter, if True, indicates that an <link id="IDCMP_NEWPREFS"/>
  message is to be sent to all windows that have the <link id="IDCMP_NEWPREFS"/>
  <link id="TWindow">IDCMPFlags</link> set.</p>
<p>
  It is legal to set a partial copy of the Preferences structure.
  The most frequently changed values are grouped at the beginning
  of the Preferences structure.</p>
<p>
  <b>Note:</b>  A new and more extensible method for supplying
  Preferences has been introduced, and relies on file
  system notification.  The Intuition preferences items rely
  also on the IPrefs program.  Certain elements of the
  Preferences structure have been superseded by this new method.
  (Elements are generally superseded as new hardware or software
  features demand more information than fits in struct Preferences.
  Parts of struct Preferences must be ignored so that applications
  calling <link id="GetPrefs">GetPrefs()</link>, modifying some other part of struct Preferences,
  then calling <i>SetPrefs()</i>, don't end up truncating the extended
  data).</p>
<p>
  Pointer Preferences:  Only the pointer from the initial
  <i>SetPrefs()</i> (i.e. devs:system-configuration) is heeded.</p>
<p>
  Palette Preferences:  Color changes submitted
  through <i>SetPrefs()</i> are ignored after the first time IPrefs sends
  Intuition new style palette preferences.</p>
<p>
  FontHeight and LaceWB:  These are only respected from
  devs:system-configuration.</p>
<p>
  View centering and size:  Changes to ViewX/YOffset and
  Row/ColumnSizeChange only apply to the default monitor
  (NTSC or PAL), and not to other monitors such as Productivity.</p>
<p>
  Other fields may be superseded in the future.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetDefPrefs"/>
<link id="GetPrefs"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetPrefs.Result">
<short>Returns your parameter buffer.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPrefs.PrefBuffer">
<short>The buffer which contains your settings for the
    preferences.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPrefs.Size">
<short>The number of bytes of the buffer you want to be copied.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPrefs.Inform">
<short>If True, all windows with <link id="IDCMP_NEWPREFS"/> <link id="TWindow">IDCMPFlags</link> set
    get an <link id="IDCMP_NEWPREFS"/> message.</short>
</element>

<!-- function Visibility: default -->
<element name="SetPubScreenModes">
<short>Establish global public screen behavior.</short>
<descr>
<p>
Sets GLOBAL Intuition public screen modes.
Values for flag bits are:</p>
<dl>
  <dt><link id="SHANGHAI"/>:</dt><dd> workbench windows are to be opened on the
    default public screen</dd>
  <dt><link id="POPPUBSCREEN"/>:</dt><dd> when a visitor window is opened, the public
    screen it opens on is to be brought to the front.</dd>
</dl>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetPubScreenModes.Result">
<short>Previous global mode settings</short>
</element>

<!-- argument Visibility: default -->
<element name="SetPubScreenModes.Modes">
<short>new global modes flags.
    </short>
</element>

<!-- procedure Visibility: default -->
<element name="SetWindowPointer">
<short>Varargs Version of <link id="SetWindowPointerA">SetWindowPointerA()</link> </short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetWindowPointerA">
<short>Select a pointer for your window.</short>
<descr>
<p>
  Allows you to set the pointer image associated with the
  specified window.  Whenever the window is the active one,
  the pointer image will change to the window's version.
  If the window is the active one when this routine is
  called, the change takes place immediately.</p>
<p>Tags:</p>
<p>The same three tags are also accepted by <link id="OpenWindowTagList">OpenWindowTagList()</link>,
  which allows you to establish the initial pointer at the
  time you open your window.</p>
<dl>
  <dt><link id="WA_Pointer"/> (APTR)</dt><dd>The pointer you wish to associate with
      your window.  If nil, you are requesting the Preferences
      default pointer.  Custom pointers should be allocated
      by performing a <link id="NewObject">NewObject()</link> on "pointerclass".  Defaults to nil.</dd>
  <dt><link id="WA_BusyPointer"/> (LongBool)</dt><dd>Set to True to request the Preferences
      busy-pointer.  If False, your pointer will be as requested
      by WA_Pointer.  Defaults to False.</dd>
  <dt><link id="WA_PointerDelay"/> (LongBool)</dt><dd>Set to True to defer changing your
      pointer for a brief instant.  This is typically used
      along with setting the busy pointer, especially when
      the application knows it may be busy for a very short
      while.  If the application clears the pointer or sets
      another pointer before the delay expires, the pending
      pointer change is cancelled.  This reduces short
      flashes of the busy pointer.</dd>
</dl>
<p><b>Example</b></p>
<p>
  This example sets the standard busy pointer with pointer-delay,
  does a bit of work, then clears the pointer:</p>
<code>
  // Put up the busy pointer, with pointer-delay
SetWindowPointer(Win,
   [WA_BusyPointer, True,
    WA_PointerDelay, True,
    TAG_DONE]);
// Do busy stuff here
  // No tags means "clear the pointer"
SetWindowPointer(Win, [TAG_DONE]);
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="SetWindowPointer"/>
<link id="SetPointer"/>
<link id="ClearPointer"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowPointerA.Win">
<short>A pointer to the window to receive this pointer definition</short>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowPointerA.Taglist">
<short>A pointer to a taglist describing your pointer</short>
</element>

<!-- procedure Visibility: default -->
<element name="SetWindowTitles">
<short>Set the window's titles for both window and screen.
</short>
<descr>
<p>Allows you to set the text which appears in the Window and/or Screen
  title bars.</p>
<p>
  The window title appears at all times along the window title bar.
  The window's screen title appears at the screen title bar whenever
  this window is the active one.</p>
<p>
  When this routine is called, your window title will be changed
  immediately.  If your window is the active one when this routine is
  called, the screen title will be changed immediately.</p>
<p>
  You can specify a value of -1 (i.e. PByte($FF)) for either of
  the title pointers.  This designates that you want Intuition to leave
  the current setting of that particular title alone, and modify
  only the other one.  Of course, you could set both to -1.</p>
<p>
  Furthermore, you can set a value of nil for either of the
  title pointers.  Doing so specifies that you want no title to
  appear (the title bar will be blank).</p>
<p>
  Both of the titles are rendered in the default font of the window's
  screen, as set using <link id="OpenScreen">OpenScreen()</link>.</p>
<p>
  In setting the window's title, Intuition may do some other rendering
  in the top border of your window.  If your own rendering sometimes
  appears in your window border areas, you may want to restore the entire
  window border frame.  The function <i>SetWindowTitles()</i> does not do this
  in the newer versions.  The function <link id="RefreshWindowFrame">RefreshWindowFrame()</link> is provided
  to do this kind of thing for you.</p>
<p><b>Note:</b>You should be careful with specifying a screen title because that
may irritate the user.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="OpenWindow"/>
<link id="RefreshWindowFrame"/>
<link id="OpenScreen"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowTitles.Window">
<short>A pointer to your window structure</short>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowTitles.WindowTitle">
<short>A pointer to a null-terminated text string, or set to
either the value of -1 (negative one) or 0 (zero). If you specify a string,
    this string is <b>not</b> copied.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowTitles.ScreenTitle">
<short>A pointer to a null-terminated text string, or set to
either the value of -1 (negative one) or 0 (zero). If you specify
    a title for the screen, this title will be shown when the
    window becomes active. If you specify a string, this string
    is <b>not</b> copied.</short>
</element>

<!-- procedure Visibility: default -->
<element name="ShowTitle">
<short>Set the screen title bar display mode.</short>
<descr>
<p>This routine sets the <link id="SHOWTITLE">SHOWTITLE</link> flag of the specified screen, and
  then coordinates the redisplay of the screen and its windows.</p>
<p>
  The screen title bar can appear either in front of or behind
  <link id="WFLG_BACKDROP"/> windows.  This is contrasted with the fact that
  non-<link id="WFLG_BACKDROP"/> windows always appear in front of the screen title
  bar.  You specify whether you want the screen title bar to be in front
  of or behind the screen's <link id="WFLG_BACKDROP"/> windows by calling this
  routine.</p>
<p>
  The <i>ShowIt</i> argument should be set to either True or False.  If True,
  the screen's title bar will be shown in front of <link id="WFLG_BACKDROP"/> windows.</p>
<p>
   If False, the title bar will be rendered behind all windows.</p>
<p>
  When a screen is first opened, the default setting of the <link id="SHOWTITLE">SHOWTITLE</link>
  flag is True.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ShowTitle.Screen">
<short>A pointer to a Screen structure</short>
</element>

<!-- argument Visibility: default -->
<element name="ShowTitle.ShowIt">
<short>A Boolean: True or False describing whether to show or hide the screen title bar</short>
</element>

<!-- procedure Visibility: default -->
<element name="SizeWindow">
<short>Ask Intuition to size a window.</short>
<descr>
<p>This routine sends a request to Intuition asking to size the window
  the specified amounts.  The delta arguments describe how much to
  size the window along the respective axes.</p>
<p>
  Note that the window will not be sized immediately, but rather
  will be sized the next time Intuition receives an input event,
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.  You can discover when
  you window has finally been sized by setting the <link id="IDCMP_NEWSIZE"/> flag
  of the IDCMP of your window.</p>
<p>
  Intuition now will do validity checking on the final
  dimensions.  To change to new absolute dimensions, or to move and
  size a window in one step, use <link id="ChangeWindowBox">ChangeWindowBox()</link>.</p>
<p>
  However, limit checking against window MinWidth, MinHeight,
  MaxWidth, and MaxHeight was not done prior to V36, and
  these fields are still ignored (as documented) if you have
  no sizing gadget (<link id="WFLG_SIZEGADGET"/> is not set).  The <b>are</b>
  respected if <link id="WFLG_SIZEGADGET"/> is set.</p>
<p>
  You can determine when the change in size has
  taken effect by receiving the <link id="IDCMP_CHANGEWINDOW"/> IDCMP message.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="ChangeWindowBox"/>
<link id="MoveWindow"/>
<link id="WindowToFront"/>
<link id="WindowToBack"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="SizeWindow.Window">
<short>A pointer to the structure of the window to be sized</short>
</element>

<!-- argument Visibility: default -->
<element name="SizeWindow.Dx">
<short>A signed value describing how much to size the window
   on the x-axis</short>
</element>

<!-- argument Visibility: default -->
<element name="SizeWindow.Dy">
<short>A signed value describing how much to size the window
   on the y-axis</short>
</element>

<!-- function Visibility: default -->
<element name="SysReqHandler">
<short>Handle system requester input.</short>
<descr>
<p>Handles input for a window returned by either <link id="BuildSysRequest">BuildSysRequest()</link>.
  These functions with <link id="SysReqHandler">SysReqHandler()</link>
  you can perform an "asynchronous" <link id="EasyRequest">EasyRequest()</link> or <link id="AutoRequest">AutoRequest()</link>.
  That is to say, you can perform other processing while you
  wait for the requester to be satisfied.</p>
<p>
  Each time this function is called, it will process all
  IDCMPMessages that the window has received.  If the parameter
  <i>WaitInput</i> is non-zero, <i>SysReqHandler()</i> will wait for input
  (by calling <link id="Exec.WaitPort">WaitPort()</link>) if there are no IDCMP messages.</p>
<p>
  <i>SysReqHandler()</i> returns the same values as <link id="EasyRequest">EasyRequest()</link>: A gadget
  ID greater than equal to 0, and  -1 if one of the other IDCMP
  events were received.</p>
<p>
  An additional value of -2 is returned if the input processed
  does not satisfy the requester.  In this case, you might
  perform some processing and call <i>SysReqHandler()</i> again.</p>
<p>
  <b>Note:</b> this function does <b>not</b> terminate the system request.
  Not only must you call <link id="FreeSysRequest">FreeSysRequest()</link> to eliminate the request,
  but you may also continue processing after an event which would
  normally terminate a normal call to <link id="EasyRequest">EasyRequest()</link>.
</p>
<p><b>Example</b></p>
<p>
  Implementation of EasyRequest input loop:</p>
<code>
Window := BuildEasyRequest(...);
while SysReqHandler(Window, IDCMP_Ptr, True) = -2 do
begin
 // loop
end;
FreeSysRequest(Window);
</code>
</descr>
<errors>
Gadget placing is still untidy.
Does not support  <link id="BuildSysRequest">BuildSysRequest()</link> requesters, yet.
</errors>
<seealso>
<link id="Exec.WaitPort">WaitPort</link>
<link id="BuildSysRequest"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SysReqHandler.Result">
<short>
<p> 0, 1, ..., N = Successive GadgetID values, for the gadgets
      you specify for the requester.  NOTE: The numbering
      from left to right is actually: 1, 2, ..., N, 0.
      This is for compatibility with AutoRequests which has
      FALSE for the rightmost gadget.</p>
<p>
  -1 = Means that one of the caller-supplied IDCMPFlags occurred.
      The IDCMPFlag value is in the longword pointed to by <i>IDCMPFlagsPtr</i>.</p>
<p>
  -2 = input processed did not satisfy the requester. One example
      is a keystroke that does not satisfy the requester.  Another
      example is if there is no input pending and you specified
      False for <i>WaitInput</i>.</p>
</short>
</element>

<!-- argument Visibility: default -->
<element name="SysReqHandler.Window">
<short>Window pointer returned from <link id="BuildSysRequest">BuildSysRequest()</link>.
    Those functions can also return
    values 0 or 1, and these values may also be
    passed to <link id="SysReqHandler">SysReqHandler()</link>, which will immediately
    return the same value.</short>
</element>

<!-- argument Visibility: default -->
<element name="SysReqHandler.IDCMPFlagsPtr">
<short>If you passed application specific IDCMP
    flags to <link id="BuildSysRequest">BuildSysRequest()</link>,
    <i>SysReqHandler()</i> will return -1 if that IDCMP message
    is received.  If <i>IDCMPFlagsPtr</i> is non-null, it
    points to a LongWord where the IDCMP class received
    will be copied for your examination.

    This pointer can be nil if you have provided no
    application specific IDCMP flags or if you do
    not need to know which application specific IDCMP
    event occurred.

    If you provide more than on flag in the flags variable
    this pointer points to, you will have to refresh
    the variable whenever -1 is returned, since the
    variable will have been changed to show just the
    single IDCMP Class bit that caused the return.</short>
</element>

<!-- argument Visibility: default -->
<element name="SysReqHandler.WaitInput">
<short>Specifies that you want <i>SysReqHandler()</i> to
          to wait for IDCMP input if there is none pending.</short>
</element>

<!-- function Visibility: default -->
<element name="TimedDisplayAlert">
<short>Display an alert with automatic time-out.</short>
<descr>
<p>This function is equivalent to <link id="DisplayAlert">DisplayAlert()</link>, except that if
  the user fails to respond in a given time, the alert comes
  down automatically.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DisplayAlert"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TimedDisplayAlert.Result">
<short>A LongBool value of True or False.  If this is a <link id="DEADEND_ALERT"/>, False
  is always the return value.  If this is a <link id="RECOVERY_ALERT"/>. The return
  value will be True if the user presses the left mouse button in
  response to your message, and False if the user presses the right hand
  button is response to your text, or if the alert could not
  be posted.  If the alert times out, the return value will be False.</short>
</element>

<!-- argument Visibility: default -->
<element name="TimedDisplayAlert.AlertNumber">
<short>The number of this alert message.  The only pertinent
      bits of this number are the <link id="ALERT_TYPE"/> bit(s).  The rest of the
      number is ignored by this routine.</short>
</element>

<!-- argument Visibility: default -->
<element name="TimedDisplayAlert.String_">
<short>A pointer to the alert message string, as described above</short>
</element>

<!-- argument Visibility: default -->
<element name="TimedDisplayAlert.Height">
<short>Minimum display lines required for your message</short>
</element>

<!-- argument Visibility: default -->
<element name="TimedDisplayAlert.Time">
<short>Length of time the alert should wait for the user to
      respond.  This time is the number of video frames the
      alert should remain up for.</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnlockIBase">
<short>Release a an Intuition lock gotten by <link id="LockIBase">LockIBase()</link>.</short>
<descr>
Calling this function when you do not own the specified lock will
  immediately crash the system.
</descr>
<errors>
</errors>
<seealso>
<link id="LockIBase"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnlockIBase.LockNumber">
<short>The value returned by <link id="LockIBase">LockIBase()</link> should be passed to this function,
  to specify which internal lock is to be freed.</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnlockPubScreen">
<short>Release lock on a public screen.</short>
<descr>
<p>Releases lock gotten by <link id="LockPubScreen">LockPubScreen()</link>.
  It is best to identify the locked public screen by
  the pointer returned from <link id="LockPubScreen">LockPubScreen()</link>.  To do this,
  supply a nil <i>Name</i> pointer and the screen pointer.</p>
<p>
  In rare circumstances where it would be more convenient to pass
  a non-nil pointer to the public screen name string, the
  <i>Screen</i> parameter is ignored.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="LockPubScreen"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnlockPubScreen.Name">
<short>A pointer to name of public screen.  If Name is nil,
      then argument <i>Screen</i> is used as a direct pointer to
      a public screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnlockPubScreen.Screen">
<short>A pointer to a public screen.  Used only if Name
      is nil.  This pointer <b>must</b> have been returned
      by <link id="LockPubScreen">LockPubScreen()</link>.
      It is safe to call <i>UnlockPubScreen()</i> with nil Name
      and Screen (the function will have no effect).</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnlockPubScreenList">
<short>Release public screen list semaphore.</short>
<descr>
Releases lock gotten by <link id="LockPubScreenList">LockPubScreenList()</link>.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ViewAddress">
<short>Return the address of the Intuition View structure.</short>
<descr>
  Returns the address of the Intuition View structure.  If you
  want to use any of the graphics, text, or animation primitives
  in your window and that primitive requires a pointer to a view,
  this routine will return the address of the view for you.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ViewAddress.Result">
<short>Returns the address of the Intuition View structure
</short>
</element>

<!-- function Visibility: default -->
<element name="ViewPortAddress">
<short>Return the address of a window's viewport.
</short>
<descr>
<p>Returns the address of the viewport associated with the specified
  window.  The viewport is actually the viewport of the screen within
  which the window is displayed.  If you want to use any of the graphics,
  text, or animation primitives in your window and that primitive
  requires a pointer to a viewport, you can use this call.</p>
<p>
  This pointer is only valid as long as your window's screen remains
  open, which is ensured by keeping your window open.
</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ViewPortAddress.Result">
<short>Returns the address of the Intuition ViewPort structure for
  your window's screen.
</short>
</element>

<!-- argument Visibility: default -->
<element name="ViewPortAddress.Window">
<short>A pointer to the window for which you want the viewport address</short>
</element>

<!-- function Visibility: default -->
<element name="WBenchToBack">
<short>Send the Workbench screen in back of all screens.</short>
<descr>
Causes the Workbench screen, if it's currently opened, to go behind
  all other screens.  This does not 'move' the screen up or down,
  instead only affects the depth-arrangement of the screens.
</descr>
<errors>
</errors>
<seealso>
<link id="ScreenToBack"/>
<link id="ScreenToFront"/>
<link id="WBenchToFront"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WBenchToBack.Result">
<short>If the Workbench screen was opened, this function returns True,
  otherwise it returns False.</short>
</element>

<!-- function Visibility: default -->
<element name="WBenchToFront">
<short>Bring the Workbench screen in front of all screens.
</short>
<descr>
  Causes the Workbench Screen, if it's currently opened, to come to
  the foreground.  This does not 'move' the screen up or down, instead
  only affects the depth-arrangement of the screen.
</descr>
<errors>
</errors>
<seealso>
<link id="ScreenToBack"/>
<link id="ScreenToFront"/>
<link id="WBenchToBack"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WBenchToFront.Result">
<short>If the Workbench screen was opened, this function returns True,
  otherwise it returns False.</short>
</element>

<!-- function Visibility: default -->
<element name="WindowLimits">
<short>Set the minimum and maximum limits of a window.</short>
<descr>
<p>Sets the minimum and maximum limits of the window's size.  Until this
  routine is called, the window's size limits are equal to the initial
  values established in the OpenWindow() function.</p>
<p>
  After a call to this routine, the Window will be able to be sized
  to any dimensions within the specified limits.</p>
<p>
  If you don't want to change any one of the dimensions, set the limit
  argument for that dimension to zero.  If any of the limit arguments
  is equal to zero, that argument is ignored and the initial setting
  of that parameter remains undisturbed.</p>
<p>
  If any of the arguments is out of range (minimums greater than the
  current size, maximums less than the current size), that limit
  will be ignored, though the others will still take effect if they
  are in range.  If any are out of range, the return value from this
  procedure will be False.  If all arguments are valid, the return
  value will be True.</p>
<p>
  If you want your window to be able to become "as large as possible"
  you may put -1 (i.e. not 0) in either or both Max arguments.  But
  please note: screen sizes may vary for several reasons, and you
  must be able to handle any possible size of window you might end
  up with if you use this method.  Note that you can use the function
  <link id="LockPubScreen">LockPubScreen()</link> to find out how big the screen your window will
  appear in is.  You may also refer to the WScreen field in your
  window structure, providing that your window remains open,
  which will ensure that the screen remains open, and thus the
  pointer remains valid.</p>
<p>
  If the user is currently sizing this window, the new limits will
  not take effect until after the sizing is completed.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="LockPubScreen"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="WindowLimits.Result">
<short>Returns True if everything was in order.  If any of the parameters was
  out of range (minimums greater than current size, maximums less than
  current size), False is returned and the errant limit request is
  not fulfilled (though the valid ones will be).</short>
</element>

<!-- argument Visibility: default -->
<element name="WindowLimits.Window">
<short>A pointer to a Window structure</short>
</element>

<!-- argument Visibility: default -->
<element name="WindowLimits.WidthMin">
<short>The new limits for the size
            of this window.  If any of these is set to zero, it will
            be ignored and that setting will be unchanged.</short>
</element>

<!-- argument Visibility: default -->
<element name="WindowLimits.HeightMin">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="WindowLimits.WidthMax">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="WindowLimits.HeightMax">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="WindowToBack">
<short>Ask Intuition to send a window behind others.</short>
<descr>
<p>This routine sends a request to Intuition asking to send the window
  in back of all other windows in the screen.</p>
<p>
  Note that the window will not be depth-arranged immediately, but rather
  will be arranged the next time Intuition receives an input event,
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.</p>
<p>
  Remember that <link id="WFLG_BACKDROP"/> windows cannot be depth-arranged.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MoveWindow"/>
<link id="SizeWindow"/>
<link id="WindowToFront"/>
<link id="MoveWindowInFrontOf"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="WindowToBack.Window">
<short>A pointer to the structure of the window to be sent to the back</short>
</element>

<!-- procedure Visibility: default -->
<element name="WindowToFront">
<short>Ask Intuition to bring a window to the front.
</short>
<descr>
<p>This routine sends a request to Intuition asking to bring the window
  in front of all other windows in the screen.</p>
<p>
  Note that the window will not be depth-arranged immediately, but rather
  will be arranged the next time Intuition receives an input event,
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.</p>
<p>
  Remember that <link id="WFLG_BACKDROP"/> windows cannot be depth-arranged.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="MoveWindow"/>
<link id="SizeWindow"/>
<link id="WindowToBack"/>
<link id="MoveWindowInFrontOf"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="WindowToFront.Window">
<short>A pointer to the structure of the window to be brought to front</short>
</element>

<!-- procedure Visibility: default -->
<element name="ZipWindow">
<short>Change window to "alternate" position and dimensions.</short>
<descr>
<p>Changes the position and dimension of a window to the values
  at the last occasion of ZipWindow being called (or invoked
  via the "zoom" gadget).</p>
<p>
  Typically this is used to snap between a normal, large, working
  dimension of the window to a smaller, more innocuous position
  and dimension.</p>
<p>
  Like <link id="MoveWindow">MoveWindow()</link>, <link id="SizeWindow">SizeWindow()</link>,
   and <link id="ChangeWindowBox">ChangeWindowBox()</link>, the action of
  this function is deferred to the Intuition input handler.</p>
<p>
  More tuning needs to be done to establish initial values for
  the first invocation of this function for a window.  You can
  provide initial values using the <link id="OpenWindowTagList">OpenWindowTagList()</link> tag item
  <link id="WA_Zoom"/>.</p>
<p>
  It could also use a new name, but "ZoomWindow" is misleading,
  since "Zoom" normally implies "scale."</p>
<p>
  The zoom gadget will appear (in the place of the old "toback"
  gadget) when you open your window if you either specify a
  sizing gadget or use <link id="WA_Zoom"/>.</p>
<p>
  You can detect that this function has taken effect by receiving
  an <link id="IDCMP_CHANGEWINDOW"/> IDCMP message.</p>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ZipWindow.Window">
<short>Window to be changed.</short>
</element>

<!-- function Visibility: default -->
<element name="SetAttrs">
<short>Varargs Version of <link id="SetAttrsA">SetAttrsA()</link> </short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="NewObject">
<short>Varargs version of <link id="NewObjectA">NewObjectA()</link></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetSuperAttrsA">
<short>Invoke <link id="OM_SET"/> method on superclass</short>
<descr>
<p>
  Boopsi support function which invokes the <link id="OM_SET"/> method on the
  superclass of the supplied class for the supplied object.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DoMethodA"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SetSuperAttrsA.Result">
<short>Class and message-specific result.</short>
</element>

<!-- argument Visibility: default -->
<element name="SetSuperAttrsA.cl">
<short>A pointer to boopsi class whose superclass is to
      receive the message</short>
</element>

<!-- argument Visibility: default -->
<element name="SetSuperAttrsA.Obj">
<short>A pointer to boopsi object</short>
</element>

<!-- argument Visibility: default -->
<element name="SetSuperAttrsA.TagList">
<short>A pointer to method-specific message to send</short>
</element>

<!-- function Visibility: default -->
<element name="DoMethod">
<short>VarArgs Version of <link id="DoMethodA">DoMethodA()</link> </short>
<descr>
Boopsi support function that invokes the supplied message
on the specified object.  The message is invoked on the
object's true class.
</descr>
<errors>
</errors>
<seealso>
<link id="DoMethodA"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DoMethodA">
<short>Perform method on object.</short>
<descr>
Boopsi support function that invokes the supplied message
  on the specified object.  The message is invoked on the
  object's true class.
</descr>
<errors>
</errors>
<seealso>
<link id="DoMethod"/>
<link id="DoSuperMethodA"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoMethodA.Result">
<short>Specific to the message and the object's class.</short>
</element>

<!-- argument Visibility: default -->
<element name="DoMethodA.Obj">
<short>A pointer to boopsi object</short>
</element>

<!-- argument Visibility: default -->
<element name="DoMethodA.Message">
<short>A pointer to method-specific message to send</short>
</element>

<!-- function Visibility: default -->
<element name="DoSuperMethodA">
<short>Perform method on object coerced to superclass.
</short>
<descr>
  Boopsi support function that invokes the supplied message
  on the specified object, as though it were the superclass
  of the specified class.
</descr>
<errors>
</errors>
<seealso>
<link id="DoMethodA"/>
<link id="DoSuperMethod"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DoSuperMethodA.Result">
<short>A class and message-specific result.</short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethodA.cl">
<short>A pointer to boopsi class whose superclass is to
      receive the message</short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethodA.Obj">
<short>A pointer to boopsi object</short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethodA.Message">
<short>A pointer to method-specific message to send
</short>
</element>

<!-- function Visibility: default -->
<element name="DoSuperMethod">
<short>VarArgs Version of <link id="DoSuperMethodA">DoSuperMethodA()</link> </short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<!-- function Visibility: default -->
<element name="INST_DATA">
<short>Finds Object local instance data</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="INST_DATA.Result">
<short>a pointer to the instance data
local to <i>Cl</i></short>
</element>

<!-- argument Visibility: default -->
<element name="INST_DATA.Cl">
<short>A pointer to a class</short>
</element>

<!-- argument Visibility: default -->
<element name="INST_DATA.O">
<short>A pointer to the object</short>
</element>

<!-- function Visibility: default -->
<element name="SIZEOF_INSTANCE">
<short>Sizeof the instance data for a given class</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SIZEOF_INSTANCE.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SIZEOF_INSTANCE.Cl">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="BASEOBJECT">
<short>Get "public" handle on baseclass instance from real beginning of obj data</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BASEOBJECT.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="BASEOBJECT.O">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="_OBJ">
<short>convenient typecast to <link id="P_Object"/></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="_OBJ.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="_OBJ.O">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="__OBJECT">
<short>Get back to object data struct from public handle</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="__OBJECT.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="__OBJECT.O">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="OCLASS">
<short>Get class pointer from an object handle</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="OCLASS.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="OCLASS.O">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="SHIFTITEM">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SHIFTITEM.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SHIFTITEM.N">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="SHIFTMENU">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SHIFTMENU.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SHIFTMENU.N">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="SHIFTSUB">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SHIFTSUB.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SHIFTSUB.N">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="FULLMENUNUM">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FULLMENUNUM.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FULLMENUNUM.Menu">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FULLMENUNUM.Item">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FULLMENUNUM.Sub">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="IM_BGPEN">
<short>Set Image Background Pen</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IM_BGPEN.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="IM_BGPEN.Im">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="IM_BOX">
<short>Get Image bounding rectangle</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IM_BOX.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="IM_BOX.Im">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="IM_FGPEN">
<short>Set Image Foreground pen</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IM_FGPEN.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="IM_FGPEN.Im">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="GADGET_BOX">
<short>Get bounding box of a gadget</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GADGET_BOX.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GADGET_BOX.G">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="CUSTOM_HOOK">
<short>Casts MutualExclude for easy assignment of a hook pointer to the unused MutualExclude field of a custom gadget</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CUSTOM_HOOK.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="CUSTOM_HOOK.Gadget">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="ITEMNUM">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ITEMNUM.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ITEMNUM.N">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="MENUNUM">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MENUNUM.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="MENUNUM.N">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="SUBNUM">
<short>Menu helper macro</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="SUBNUM.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SUBNUM.N">
<short></short>
</element>


<!-- uses unit Visibility: default -->
<element name="exec">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="agraphics">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="utility">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="inputevent">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="timer">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="layers">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.NextGadget">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.LeftEdge">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.TopEdge">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.Height">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.Flags">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.Activation">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.GadgetType">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.GadgetRender">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.SelectRender">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.GadgetText">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.MutualExclude">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.SpecialInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.GadgetID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tExtGadget.UserData">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_WUPFRONT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_SUPFRONT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_WDOWNBACK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GTYP_SDOWNBACK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="RI_VERSION">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tDrawInfo.dri_Resolution.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tDrawInfo.dri_Resolution.y">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="SA_Obsolete1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SDEPTH_CHILDONLY">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FANFOLD_PT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SINGLE_PT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tGadgetInfo.gi_Pens.DetailPen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tGadgetInfo.gi_Pens.BlockPen">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpHitTest.gpht_Mouse.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpHitTest.gpht_Mouse.y">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpInput.gpi_Mouse.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpInput.gpi_Mouse.y">
<short></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpDomain">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tgpDomain">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tgpDomain.MethodID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpDomain.gpd_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpDomain.gpd_RPort">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpDomain.gpd_Which">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpDomain.gpd_Domain">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpDomain.gpd_Attrs">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="GDOMAIN_MINIMUM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GDOMAIN_NOMINAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GDOMAIN_MAXIMUM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpKeyTest">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tgpKeyTest">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyTest.MethodID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyTest.gpkt_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyTest.gpkt_IMsg">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyTest.gpkt_VanillaKey">
<short></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpKeyInput">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tgpKeyInput">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyInput.MethodID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyInput.gpk_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyInput.gpk_IEvent">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyInput.gpk_Termination">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="GMR_KEYACTIVE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="GMR_KEYVERIFY">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PgpKeyGoInactive">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="tgpKeyGoInactive">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyGoInactive.MethodID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyGoInactive.gpki_GInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="tgpKeyGoInactive.gpki_Abort">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="SYSIA_Pens">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_ShadowPen">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_HighlightPen">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Underscore">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Scalable">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_ActivateKey">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Screen">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IA_Precision">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IM_DOMAINFRAME">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDS_INDETERMINANT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="timpDraw.imp_Offset.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDraw.imp_Offset.y">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDraw.imp_Dimensions.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDraw.imp_Dimensions.Height">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpErase.imp_Offset.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpErase.imp_Offset.y">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpErase.imp_Dimensions.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpErase.imp_Dimensions.Height">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpHitTest.imp_Point.x">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpHitTest.imp_Point.y">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpHitTest.imp_Dimensions.Width">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpHitTest.imp_Dimensions.Height">
<short></short>
</element>

<!-- pointer type Visibility: default -->
<element name="PimpDomainFrame">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="timpDomainFrame">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="timpDomainFrame.MethodID">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDomainFrame.imp_DrInfo">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDomainFrame.imp_RPort">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDomainFrame.imp_Which">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDomainFrame.imp_Domain">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="timpDomainFrame.imp_Attrs">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="IDOMAIN_MINIMUM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDOMAIN_NOMINAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="IDOMAIN_MAXIMUM">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ActivateGadget.gadgets">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocScreenBuffer.sc">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AllocScreenBuffer.bm">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeScreenBuffer.sc">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="ChangeScreenBuffer.sb">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DisposeObject.obj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoGadgetMethodA.message">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequestArgs.idcmpPtr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FreeClass.classPtr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FreeScreenBuffer.sc">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FreeScreenBuffer.sb">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GetAttr.obj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GetAttr.storage">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="HelpControl.win">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="LockIBase.dontknow">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetAttrsA.obj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetPrefs.preferences">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SysReqHandler.idcmpPtr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="UnlockIBase.ibLock">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="OpenScreenTags.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="OpenScreenTags.newScreen">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="OpenScreenTags.tagList">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="OpenWindowTags.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="OpenWindowTags.newWindow">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="OpenWindowTags.tagList">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="NewObject.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewObject.classPtr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewObject.classID">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="NewObject.argv">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="SetAttrs.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetAttrs.obj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetAttrs.tags">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="SetGadgetAttrs.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrs.gadget">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrs.window">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrs.requester">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetGadgetAttrs.argv">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="EasyRequest.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequest.window">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequest.easyStruct">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequest.idcmpPtr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="EasyRequest.args">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowPointer.win">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetWindowPointer.tags">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoMethodA.Msg">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethodA.Msg">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="SetSuperAttrsA.Msg">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="DoMethod.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoMethod.Obj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoMethod.Params">
<short></short>
</element>

<!-- function result Visibility: default -->
<element name="DoSuperMethod.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethod.Cl">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethod.Obj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DoSuperMethod.Params">
<short></short>
</element>

</module> <!-- Intuition -->

</package>
</fpdoc-descriptions>
