<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="amunits">

<!--
  ====================================================================
    icon
  ====================================================================
-->

<module name="icon">
<short>Icon handling routines (icon.library)</short>
<descr>Functions and structures to work with Icons.
</descr>

<!-- constant Visibility: default -->
<element name="ICONNAME">
<short>Icon library name</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Dummy">
<short>Start of icon.library tags</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_ErrorCode">
<short>Errorcode (PLongInt)</short>
<descr>Pointer to a LongWord variable to
      store error codes in. Note that this variable will be
      initialized regardless of whether an error occured or not.
      Thus, you can check for an error condition by comparing the
      variable contents against 0; 0 indicates success, all other
      values are error codes as defined by <link id="AmigaDos">dos.library</link>.
</descr>
<seealso>
<link id="ICONA_ErrorTagItem"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_ErrorTagItem">
<short>Points to the tag item that caused the error (^<link id="utility.PTagITem">PTagItem</link>)</short>
<descr>
</descr>
<seealso>
<link id="ICONA_ErrorCode"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalScreen">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Screen to use for remapping Workbench icons to (PScreen)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>,Pointer to the
      screen to remap palette mapped icons to. This is commonly
      used by <link id="Workbench">workbench.library</link> after it has initialized itself
      and before/after screen open/close transitions. If the
      screen is set to nil, the icon colour remapping strategy is
      changed: colours are no longer allocated from a screen
      and the colours to map to will come from a default colour
      colour table with four palette entries. Please note that
      once you select a screen to remap to, you cannot tell
      icon.library to use a different screen; you first need to
      tell icon.library to "let go" of the previously selected
      screen by passing a nil <var>ICONCTRLA_SetGlobalScreen</var> parameter.
      You can set a different screen only after this is done.
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalScreen"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalScreen">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get the Screen which is used icons (^PScreen)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalScreen"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalPrecision">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Icon color remapping precision (LongInt)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>,
Default is <link id="AGraphics.PRECISION_ICON">PRECISION_ICON</link>.
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalPrecision"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalPrecision">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Icon color remapping precision (PLongInt)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalPrecision"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalEmbossRect">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Icon frame size dimensions (PRectange)</short>
<descr><p>Global Option for <link id="IconControlA">IconControlA()</link></p>
<p>Set the frame sizes used for drawing icons. The Rectangle
must be initialized as follows:</p>
<dl>
<dt>Rectangle^.MinX</dt><dd>Width of left edge border (negative),
                           must be in the range [-255..-1]</dd>
<dt>Rectangle^.MinY</dt><dd>Height of top edge border (negative),
                           must be in the range [-255..-1]</dd>
<dt>Rectangle^.MaxX</dt><dd>Width of right edge border (positive),
                           must be in the range [1..255]</dd>
<dt>Rectangle^.MaxY</dt><dd>  Height of bottom edge border (positive),
                           must be in the range [1..255]</dd>
</dl>
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalEmbossRect"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalEmbossRect">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Icon frame size dimensions (PRectange)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalEmbossRect"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalFrameless">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Render image without frame (BOOL)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
This option defaults to False.
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalFrameless"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalFrameless">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get if images are rendered without frame (BOOL)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalFrameless"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalNewIconsSupport">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Enable NewIcons support (BOOL)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
This option defaults to True.
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalNewIconsSupport"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalNewIconsSupport">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Status of NewIcons support (BOOL)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalNewIconsSupport"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalColorIconSupport">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Enable color icon support (BOOL)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
This option defaults to True.
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalColorIconSupport"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalColorIconSupport">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Status of color icon support (BOOL)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalColorIconSupport"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalIdentifyHook">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set the hook to be called when identifying a file (<link id="Utility.PHook"/>)</short>
<descr><p>Global Option for <link id="IconControlA">IconControlA()</link></p>
<p>Set the
hook that is invoked when trying to find an icon
for a file/drawer/volume that does not have an
icon associated with it. If set to nil, no hook
will be called. The hook will be called with the
following parameters:</p>
<code>
  procedure HookFunc(Hook: Phook; reserved: APTR; IIMsg: PIconIdentifyMsg); cdecl;
</code>
<p>
The reserved parameter will be set to nil</p>
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalIdentifyHook"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalIdentifyHook">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get the hook to be called when identifying a file (<link id="Utility.PHook"/>)</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalIdentifyHook"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetGlobalMaxNameLength">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set the maximum length of a file/drawer name supported
  by icon.library (LONG).</short>
<descr><p>Global Option for <link id="IconControlA">IconControlA()</link></p>
<p> icon.library has
    a built-in file name length limit that affects whether
    icon files are read and written. Currently, the default
    for this value is 25 characters. This is sufficient for
    an icon file name acceptable with the ROM filing system.
    This limit has two effects: if an icon file is to be
    written whose name would be longer than the limit,
    icon.library will silently abort the write attempt and
    pretend that the icon file has been written; this is done
    in order to avoid overwriting the original data file with
    the icon file. If an icon file was read that turns out to
    contain invalid icon data, another test is done in order to
    find out whether the file name was longer than the limit. If
    this is the case, it is assumed that the data was read from
    the original file rather than from the icon file. The library
    then pretends that the icon file was not found.</p>
<p>
    This tag can be used to set this length limit. The limit
    must be in the range [8..255].</p>
</descr>
<seealso>
<link id="ICONCTRLA_GetGlobalMaxNameLength"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetGlobalMaxNameLength">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get the maximum length of a file/drawer name supported
  by icon.library (LONG).</short>
<descr>Global Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetGlobalMaxNameLength"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetImageMask1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get the icon rendering mask 1 (PLANEPTR)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Pointer to the mask plane
      for the regular icon image (Icon^.do_Gadget.GadgetRender).
      Note that this may be nil.
</descr>
<seealso>
<link id="ICONCTRLA_GetImageMask2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetImageMask2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get the icon rendering mask 2 (PLANEPTR)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Pointer to the mask plane
      for the alternate icon image (Icon^.do_Gadget.SelectRender).
      Note that this may be nil.
</descr>
<seealso>
<link id="ICONCTRLA_GetImageMask1"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetTransparentColor1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set first transparent image color; set to -1 if opaque (LongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the transparent
      colour for a palette mapped icon image, in this case the
      regular icon image (icon^.do_Gadget.GadgetRender). The
      colour must be among the valid palette entries, e.g. for
      a 16 colour image, the transparent colour may not be
      larger than 15. To make the icon image opaque, set its
      transparent colour to -1.
</descr>
<seealso>
<link id="ICONCTRLA_GetTransparentColor1"/>
<link id="ICONCTRLA_SetTransparentColor2"/>
<link id="ICONCTRLA_GetTransparentColor2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetTransparentColor1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get first transparent image color; -1 if opaque (PLongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
  Get the transparent
      colour for a palette mapped icon image, in this case the
      regular icon image (icon^.do_Gadget.GadgetRender). If
      the image is opaque, its "transparent colour" will be
      returned as -1. Note that this data is valid only for
      palette mapped icons; for other types, you may not
      receive any meaningful result.
</descr>
<seealso>
<link id="ICONCTRLA_SetTransparentColor1"/>
<link id="ICONCTRLA_SetTransparentColor2"/>
<link id="ICONCTRLA_GetTransparentColor2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetTransparentColor2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set second transparent image color; set to -1 if opaque</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the transparent
      colour for a palette mapped icon image, in this case the
      alternate icon image (icon^.do_Gadget.SelectRender). The
      colour must be among the valid palette entries, e.g. for
      a 16 colour image, the transparent colour may not be
      larger than 15. To make the icon image opaque, set its
      transparent colour to -1. Please note that you can set
      the alternate image transparent colour only if there is
      an alternate image.
</descr>
<seealso>
<link id="ICONCTRLA_SetTransparentColor1"/>
<link id="ICONCTRLA_GetTransparentColor1"/>
<link id="ICONCTRLA_GetTransparentColor2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetTransparentColor2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get second transparent image color; -1 if opaque</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the transparent
      colour for a palette mapped icon image, in this case the
      alternate icon image (icon^.do_Gadget.SelectRender). If
      the image is opaque, its "transparent colour" will be
      returned as -1. Note that this data is valid only for
      palette mapped icons; for other types, you may not
      receive any meaningful result. Likewise, if there is
      no alternate image, no information may be available.
</descr>
<seealso>
<link id="ICONCTRLA_SetTransparentColor1"/>
<link id="ICONCTRLA_GetTransparentColor1"/>
<link id="ICONCTRLA_SetTransparentColor2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetPalette1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Image color palette 1 (PColorRegister) </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the colour
      palette for a palette mapped icon image, in this case the
      regular icon image (icon^.do_Gadget.GadgetRender).
</descr>
<seealso>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette2"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetPalette1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Image color palette 1 (PPColorRegister) </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the colour
      palette for a palette mapped icon image, in this case the
      regular icon image (icon^.do_Gadget.GadgetRender). Note
      that this data is valid only for palette mapped icons; for
      other types, you may not receive any meaningful result.
      Note that the number of palette entries in this table
      matches the number of colours in use when the icon
      was first created.
</descr>
<seealso>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_SetPalette2"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetPalette2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Image color palette 2 (PColorRegister)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the colour
      palette for a palette mapped icon image, in this case the
      alternate icon image (icon^.do_Gadget.SelectRender).
</descr>
<seealso>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetPalette2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Image color palette 2 (PPColorRegister)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the colour
      palette for a palette mapped icon image, in this case the
      alternate icon image (icon^.do_Gadget.SelectRender). Note
      that this data is valid only for palette mapped icons; for
      other types, you may not receive any meaningful result.
      If there is no alternate image, no information may be
      available.
      Note that the number of palette entries in this table
      matches the number of colours in use when the icon
      was first created.
</descr>
<seealso>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_SetPalette2"/>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetPaletteSize1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Size of image color palette 1 (LongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the size of the colour
      palette to be used for a palette mapped icon image, in
      this case the regular icon image (icon^.do_Gadget.GadgetRender).
      This value must be in the range [1..256].
</descr>
<seealso>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPalette2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetPaletteSize1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Size of image color palette 1 (PLongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the size of the colour
      palette to be used for a palette mapped icon image, in
      this case the regular icon image (icon^.do_Gadget.GadgetRender).
      Note that this data is valid only for palette mapped icons; for
      other types, you may not receive any meaningful result.
</descr>
<seealso>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPalette2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetPaletteSize2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Size of image color palette 2 (LongInt) </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the size of the colour
      palette to be used for a palette mapped icon image, in
      this case the alternate icon image (icon^.do_Gadget.SelectRender).
      This value must be in the range [1..256].
</descr>
<seealso>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize2"/>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPalette2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetPaletteSize2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Size of image color palette 2 (PLongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the size of the colour
      palette to be used for a palette mapped icon image, in
      this case the alternate icon image (icon^.do_Gadget.SelectRender).
      Note that this data is valid only for palette mapped icons; for
      other types, you may not receive any meaningful result.
      If there is no alternate image, no information may be
      available.
</descr>
<seealso>
<link id="ICONCTRLA_SetPaletteSize1"/>
<link id="ICONCTRLA_GetPaletteSize1"/>
<link id="ICONCTRLA_SetPaletteSize2"/>
<link id="ICONCTRLA_GetPalette1"/>
<link id="ICONCTRLA_SetPalette1"/>
<link id="ICONCTRLA_GetPalette2"/>
<link id="ICONCTRLA_SetPalette2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetImageData1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Image 1 data; one by per pixel (PBYTE)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the image data to be used for
      a palette mapped icon image, in this case the regular icon
      image (icon^.do_Gadget.GadgetRender). There must be exactly
      as many bytes of image data as the image width multiplied
      by its height requires.

      To drop the palette mapped image data associated with an icon,
      use "ICONCTRLA_SetImageData1,nil".
</descr>
<seealso>
<link id="ICONCTRLA_GetImageData1"/>
<link id="ICONCTRLA_SetImageData2"/>
<link id="ICONCTRLA_GetImageData2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetImageData1">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Image 1 data; one by per pixel (PPBYTE)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the image data to be used for
      a palette mapped icon image, in this case the regular icon
      image (icon->do_Gadget.GadgetRender). Note that this data is
      valid only for palette mapped icons; for other types, you may
      not receive any meaningful result.
</descr>
<seealso>
<link id="ICONCTRLA_SetImageData1"/>
<link id="ICONCTRLA_SetImageData2"/>
<link id="ICONCTRLA_GetImageData2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetImageData2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Image 2 data; one by per pixel (PBYTE)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the image data to be used for
      a palette mapped icon image, in this case the alternate icon
      image (icon->do_Gadget.SelectRender). There must be exactly
      as many bytes of image data as the image width multiplied
      by its height requires.

      To drop the palette mapped image data associated with the alternate
      image of an icon, use "ICONCTRLA_SetImageData1,nil".
</descr>
<seealso>
<link id="ICONCTRLA_GetImageData1"/>
<link id="ICONCTRLA_SetImageData1"/>
<link id="ICONCTRLA_GetImageData2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetImageData2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Image 2 data; one by per pixel (PPBYTE)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the image data to be used for
      a palette mapped icon image, in this case the alternate icon
      image (icon->do_Gadget.SelectRender). Note that this data is
      valid only for palette mapped icons; for other types, you may
      not receive any meaningful result. If there is no alternate
      image, no information may be available.
</descr>
<seealso>
<link id="ICONCTRLA_GetImageData1"/>
<link id="ICONCTRLA_SetImageData1"/>
<link id="ICONCTRLA_SetImageData2"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetFrameless">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set if rendered without frame (BOOL) </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
This option defaults to False.
</descr>
<seealso>
<link id="ICONCTRLA_GetFrameless"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetFrameless">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get if rendered without frame (BOOL)  </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetFrameless"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetNewIconsSupport">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set if NewIcons support is enabled (BOOL) </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_GetNewIconsSupport"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetNewIconsSupport">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get if NewIcons support is enabled (BOOL) </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetNewIconsSupport"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetAspectRatio">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Icon aspect ratio (PBYTE)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Set the icon aspect ratio; this
      consists of a numerator and a denominator packed into a
      single byte (<link id="PACK_ICON_ASPECT_RATIO"/> can be used
      for encoding this parameter). If the icon aspect ratio is
      unknown, <link id="ICON_ASPECT_RATIO_UNKNOWN"/> should be used.
</descr>
<seealso>
<link id="ICONCTRLA_GetAspectRatio"/>
<link id="PACK_ICON_ASPECT_RATIO"/>
<link id="ICON_ASPECT_RATIO_UNKNOWN"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetAspectRatio">
<short>Tag for <link id="IconControlA">IconControlA()</link>, </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
Get the icon aspect ratio; this
      consists of a numerator and a denominator packed into a
      single byte. If the icon aspect ratio is unknown,
      <link id="ICON_ASPECT_RATIO_UNKNOWN"/> will be returned.
</descr>
<seealso>
<link id="ICONCTRLA_SetAspectRatio"/>
<link id="PACK_ICON_ASPECT_RATIO"/>
<link id="ICON_ASPECT_RATIO_UNKNOWN"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetWidth">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Icon Width, valid only for palette mapped icon images (LongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link> This value must be in the range [1..256].

</descr>
<seealso>
<link id="ICONCTRLA_GetWidth"/>
<link id="ICONCTRLA_SetHeight"/>
<link id="ICONCTRLA_GetHeight"/>
<link id="ICONCTRLA_IsPaletteMapped"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetWidth">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Icon Width, valid only for palette mapped icon images (LongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetWidth"/>
<link id="ICONCTRLA_SetHeight"/>
<link id="ICONCTRLA_GetHeight"/>
<link id="ICONCTRLA_IsPaletteMapped"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_SetHeight">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Set Icon Height, valid only for palette mapped icon images (LongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
 This value must be in the range [1..256].
</descr>
<seealso>
<link id="ICONCTRLA_SetWidth"/>
<link id="ICONCTRLA_GetWidth"/>
<link id="ICONCTRLA_GetHeight"/>
<link id="ICONCTRLA_IsPaletteMapped"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetHeight">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get Icon Height, valid only for palette mapped icon images (LongInt)</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
<link id="ICONCTRLA_SetWidth"/>
<link id="ICONCTRLA_GetWidth"/>
<link id="ICONCTRLA_SetHeight"/>
<link id="ICONCTRLA_IsPaletteMapped"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_IsPaletteMapped">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Check whether the icon is palette mapped (PLongInt). </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_GetScreen">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Get the screen the icon is attached to (^<link id="intuition.PScreen">PScreen</link>). </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_HasRealImage2">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Check whether the icon has a real select image (PLongInt). </short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_IsNewIcon">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Check whether the icon is of the NewIcon type (PLongInt).</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONCTRLA_IsNativeIcon">
<short>Tag for <link id="IconControlA">IconControlA()</link>, Check whether this icon was allocated by icon.library or if consists solely of a statically allocated struct DiskObject. (PLongInt).</short>
<descr>Per Icon Option for <link id="IconControlA">IconControlA()</link> There is an important difference
      between struct DiskObject icons allocated by icon.library itself
      (these are the so-called "native" icons) and statically initialized
      icons which consist solely of a simple struct DiskObject which may
      be part of a program's static data area. For example, you can
      attach a palette mapped icon image to a "native" icon, which is
      something you cannot do with a statically allocated icon. To help
      you tell the two types apart, you can use the <var>ICONCTRLA_IsNativeIcon</var>
      query tag.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICON_ASPECT_RATIO_UNKNOWN">
<short>Icon aspect ratio is not known.</short>
<descr>
</descr>
<seealso>
<link id="ICONCTRLA_SetAspectRatio"/>
<link id="ICONCTRLA_GetAspectRatio"/>
<link id="PACK_ICON_ASPECT_RATIO"/>
<link id="IconControlA"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_GetDefaultType">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Default icon type to retrieve (LongInt)</short>
<descr> Type of the default icon
      to retrieve; must be one of <link id="Workbench.WBDISK">WBDISK</link>,
      <link id="Workbench.WBDRAWER">WBDRAWER</link>, <link id="Workbench.WBTOOL">WBTOOL</link>,
      <link id="Workbench.WBPROJECT">WBPROJECT</link>, <link id="Workbench.WBGARBAGE">WBGARBAGE</link>,
      <link id="Workbench.WBDEVICE">WBDEVICE</link> or <link id="Workbench.WBKICK">WBKICK</link>.
      If this tag is used, the "name" parameter will be ignored.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_GetDefaultName">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Retrieve default icon for the given name (PChar)</short>
<descr>Query whether this icon is associated
      with a file/drawer/volume or is a "fake" icon that was constructed
      for an object that has no icon associated with it.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_FailIfUnavailable">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Return a default icon if the requested icon file cannot be found (BOOL).</short>
<descr>If there is no icon for
      the specified object, this tag will control how to
      proceed: if <var>ICONGETA_FailIfUnavailable</var> is set to True,
      NULL and an error code will be returned; if set to False,
      icon.library will first invoke the global identification
      hook (see <link id="IconControlA">IconControlA</link>) and then, if necessary,
      provide a default icon for the object in question.

      This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_GetPaletteMappedIcon">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, If possible, retrieve a palette mapped icon (BOOL).</short>
<descr>By default, icon.library
      will try to retrieve the palette mapped version of an icon. To
      change this, set the <var>ICONGETA_GetPaletteMappedIcon</var> tag to False.
      This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_IsDefaultIcon">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Set if the icon returned is a default icon (PLongBool).</short>
<descr>
When retrieving an icon with
      the <link id="ICONGETA_FailIfUnavailable"/> tag set to False, you may
      receive a default icon because there is no on-disk icon
      file for the object you wanted to retrieve it for. This
      type of default icon is also known as a "fake" icon.
      To find out whether you have received a fake icon, use the
      <var>ICONGETA_IsDefaultIcon</var> tag.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_RemapIcon">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Remap the icon to the default screen, if possible (BOOL). </short>
<descr>
Palette mapped icons will usually
      be automatically remapped for display on the screen
      selected using <link id="IconControlA">IconControlA</link>. If you do not want this to
      happen because, for example, you want to use <link id="LayoutIconA">LayoutIconA</link>
      instead, you can set the <var>ICONGETA_RemapIcon</var> tag to FALSE.
      Take care when doing this as the icon returned to you
      will have nil pointers in the do_Gadget.GadgetRender
      and do_Gadget.SelectRender members.

      This tag defaults to TRUE.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_GenerateImageMasks">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Generate icon image masks (BOOL).</short>
<descr>When loading icons with
      transparent colours or backfill imagery, bit plane masks
      will be generated for later use with <link id="DrawIconStateA">DrawIconStateA()</link>.
      If you do not need these masks, set this tag to FALSE.

      This tag defaults to TRUE.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_Label">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Label text to be assigned to the icon (PChar).</short>
<descr>The label text to be printed below
      the icon when it is put to use lateron. This parameter
      can be useful to figure out the type of the icon to
      be retrieved by the identification hook. For example,
      Workbench may label unreadable disk icons as "DF0:????".
      The identification hook could key on this and supply an
      appropriate icon for the disk.

      This tag defaults to NULL.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONGETA_Screen">
<short>Tag for <link id="GetIconTagList">GetIconTagList()</link>, Screen to remap the icon to (PScreen).</short>
<descr>Pointer to the screen
      to remap the icon to; if set to nil, this keeps the
      icon from getting remapped in the first place (see
      <link id="ICONGETA_RemapIcon"/> for the consequences).

      This tag defaults to the default screen to remap to, as
      preset by <link id="IconControlA">IconControlA()</link>.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_NotifyWorkbench">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Notify Workbench of the icon being written (BOOL)</short>
<descr>Set this to True to notify
      Workbench of the fact that an icon was changed.

      This tag defaults to False.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_PutDefaultType">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Store icon as the default for this type (LongInt)</short>
<descr>Type of the default icon
      to retrieve; must be one of <link id="Workbench.WBDISK">WBDISK</link>,
      <link id="Workbench.WBDRAWER">WBDRAWER</link>, <link id="Workbench.WBTOOL">WBTOOL</link>,
      <link id="Workbench.WBPROJECT">WBPROJECT</link>, <link id="Workbench.WBGARBAGE">WBGARBAGE</link>,
      <link id="Workbench.WBDEVICE">WBDEVICE</link> or <link id="Workbench.WBKICK">WBKICK</link>.
      If this tag is used, the "name" parameter will be ignored.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_PutDefaultName">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Store icon as a default for the given name (PChar)</short>
<descr>Name of the default object
      type this icon is to be stored as.

      If this tag is used, the "name" parameter will be ignored.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_DropPlanarIconImage">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Do not store planar icon image (BOOL) </short>
<descr>If you decide that the
      palette mapped icon imagery is sufficient to represent
      an icon, you can tell icon.library not to store the original,
      planar icon image data with the icon file. To do this,
      set this tag to True. Instead of the planar icon images,
      a single default image will be stored. This can result
      in space savings but may not look too pretty.

      This tag defaults to False.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_DropChunkyIconImage">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Don't write the chunky icon image data to disk. (BOOL) </short>
<descr>This tag can be used to
      keep the chunky icon image data from getting written
      to disk.

      This tag defaults to FALSE.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_DropNewIconToolTypes">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Don't write the NewIcons tool types to disk. (BOOL)</short>
<descr>This tag controls whether
      any NewIcon tool types will be omitted when writing the
      icon to disk. TRUE will omit the data.

      This tag defaults to FALSE.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_OptimizeImageSpace">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Try to compress image data (BOOL)</short>
<descr>A palette mapped icon
      image might not use the entire icon palette. By default,
      icon.library does not bother about this, it expects the
      creator of the icon to choose its palette efficiently.
      But just in case, you can tell icon.library to attempt
      to identify how many colours are really in use and to
      optimize its image compressor for them. This may take
      extra time and is not recommended for daily use.

      This tag defaults to False.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_OnlyUpdatePosition">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Write only new position. (Bool) </short>
<descr>This tag can be used to
      reduce the overhead in updating icon information on disk
      if the only information changed is the icon position.
      For this case, you can set this tag to TRUE. The icon
      to be modified will have only its do_CurrentX/do_CurrentY
      member values changed, the remainer will stay unmodified.
      Please note that this tag only takes effect if the
      <link id="ICONPUTA_PutDefaultType"/> and <link id="ICONPUTA_PutDefaultName"/> tags
      are omitted.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONPUTA_PreserveOldIconImages">
<short>Tag for <link id="PutIconTagList">PutIconTagList()</link>, Save old image before writing (BOOL) </short>
<descr>Before writing a palette mapped icon back to disk,
    icon.library will make sure that the original
    planar image data is stored in the file. If you
    don't want that to happen, set this option to
    False. This will allow you to change the planar icon
    image data written back to disk.
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PIconIdentifyMsg">
<short>Pointer to file identification structure</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIconIdentifyMsg">
<short>Tag for use with the file identification hook.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_SysBase">
<short>ExecBase already opened for your use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_DOSBase">
<short>DosBase already opened for your use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_UtilityBase">
<short>Utility Base already opened for your use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_IconBase">
<short>IconBase already opened for your use</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_FileLock">
<short>Lock on the object to return an icon for.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_ParentLock">
<short>Lock on the object's parent directory, if available.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_FIB">
<short>Already initialized for you.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_FileHandle">
<short>If non-NULL, pointer to the file to examine,
positioned right at the first byte, ready
for you to use.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TIconIdentifyMsg.iim_Tags">
<short>Tags passed to <link id="GetIconTagList">GetIconTagList()</link>.
</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_DuplicateDrawerData">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, Duplicate <link id="Workbench.TDrawerData">do_DrawerData</link></short>
<descr>This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_DuplicateImages">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, Duplicate the Image structures.</short>
<descr><p>Duplicate the icon images;
  note that this DOES NOT include the associated image
  data. To get the image data duplicated, too, also use
  the <link id="ICONDUPA_DuplicateImageData"/> tag.</p>
<p>
  This tag defaults to True.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_DuplicateImageData">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, Duplicate the image data (Image->ImageData) itself.</short>
<descr><p>Duplicate the icon image
  data; this tag works together with the <link id="ICONDUPA_DuplicateImages"/>
  tag. If <link id="ICONDUPA_DuplicateImageData"/> is set to True, you must
  also set <link id="ICONDUPA_DuplicateImages"/> to True.</p>
<p>
  This tag defaults to TRUE.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_DuplicateDefaultTool">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, Duplicate the default tool.</short>
<descr>This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_DuplicateToolTypes">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, Duplicate the tool types list.</short>
<descr>This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_DuplicateToolWindow">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, Duplicate the tool window.</short>
<descr>This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDUPA_ActivateImageData">
<short>Tag for <link id="DupDiskObjectA">DupDiskObjectA()</link>, If the icon to be duplicated is in fact a palette mapped
icon which has never been set up to be displayed on the screen,
turn the duplicate into that palette mapped icon.</short>
<descr><p>
If the source icon contains
      palette mapped image data that was never put to use (this
      happens if it is retrieved with the GetDiskObject() call rather
      than the new <link id="GetIconTagList">GetIconTagList()</link> call), this tag will cause the
      image data to be analyzed and an attempt to be made to use that
      image data in the duplicate. The resulting icon will be remapped
      for display on the default screen, such as the Workbench screen.</p>
<p>
      This tag defaults to False.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDRAWA_DrawInfo">
<short>Tag for <link id="DrawIconStateA">DrawIconStateA()</link> and <link id="GetIconRectangleA"></link>, Drawing information to use (<link id="intuition.PDrawInfo">PDrawInfo</link>).</short>
<descr>Drawing information data
      associated with the RastPort to draw into. The DrawInfo
      contents affect the colours of the border drawn around the
      icon image and also carry display aspect ratio information.
      If this tag is nil, the default rendering pens for the
      screen selected via <link id="IconControlA">IconControlA</link>(...,<link id="ICONCTRLA_SetGlobalScreen"/>,...); will be used instead. This tag defaults to nil.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDRAWA_Frameless">
<short>Tag for <link id="DrawIconStateA">DrawIconStateA()</link> and <link id="GetIconRectangleA"></link>, Draw the icon without the surrounding frame (BOOL).</short>
<descr>This tag defaults to False.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDRAWA_EraseBackground">
<short>Tag for <link id="DrawIconStateA">DrawIconStateA()</link> and <link id="GetIconRectangleA"></link>, Erase the background before drawing a frameless icon (BOOL).</short>
<descr>This tag defaults to True.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONDRAWA_Borderless">
<short>Tag for <link id="DrawIconStateA">DrawIconStateA()</link> and <link id="GetIconRectangleA"></link>, Draw the icon without the surrounding border and frame (BOOL).</short>
<descr>This tag defaults to False.
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved1">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved2">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved3">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved4">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved5">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved6">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved7">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_Reserved8">
<short>Reserved tag; don't use!</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ICONA_LAST_TAG">
<short>The last Tag of icon.library</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AddFreeList">
<short>Add memory to a free list.</short>
<descr><p>This routine adds the specified memory to the free list.
  The free list will be extended (if required).  If there
  is not enough memory to complete the call, NULL is returned.</p>
<p>
  Note that <var>AddFreeList()</var> does <b>not</b> allocate the requested memory.
  It only records the memory in the free list.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Exec.AllocEntry">AllocEntry</link>
<link id="Exec.AllocEntry">FreeEntry</link>
<link id="FreeFreeList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AddFreeList.Result">
<short>TRue if the call succeeded else False</short>
</element>

<!-- argument Visibility: default -->
<element name="AddFreeList.FreeList">
<short>A Pointer to freelist struct previously allocated by
        the programmer.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddFreeList.Mem">
<short>Memory to add to the freelist.</short>
</element>

<!-- argument Visibility: default -->
<element name="AddFreeList.Size">
<short>Size of memory chunk to add to the frelist.
</short>
</element>

<!-- function Visibility: default -->
<element name="BumpRevision">
<short>Reformat a name for a second copy.</short>
<descr><p>BumpRevision takes a name and turns it into a "copy_of_name".
  It knows how to deal with copies of copies.  The routine
  will truncate the new name to the maximum dos name size
  (currently 30 characters).</p>
<p>Examples:</p>
<table>
<th><td>OldName</td><td>NewName</td></th>
<tr>
  <td>'foo'</td>
  <td>'copy_of_foo'</td>
</tr>
<tr>
  <td>'copy_of_foo'</td>
  <td>'copy_2_of_foo'</td>
</tr>
<tr>
  <td>'copy foo'</td>
  <td>'copy_1_of_foo'</td>
</tr>
<tr>
  <td>'012345678901234567890123456789'</td>
  <td>'copy_of_0123456789012345678901'</td>
</tr>
</table>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="BumpRevision.Result">
<short>Pointer to <var>NewName</var></short>
</element>

<!-- argument Visibility: default -->
<element name="BumpRevision.NewName">
<short>The new buffer that will receive the name (it must be at least 31 characters long).</short>
</element>

<!-- argument Visibility: default -->
<element name="BumpRevision.OldName">
<short>The original name</short>
</element>

<!-- function Visibility: default -->
<element name="DeleteDiskObject">
<short>Delete a Workbench disk object from disk.</short>
<descr><p>
  This routine will try to delete a Workbench disk object from disk.
  The name parameter will have ".info" postpended to it, and the
  icon file of that name will be deleted.  If the call fails,
  it will return False. The reason for the failure may be obtained
  via <link id="amigados.IoErr">IoErr()</link>.</p>
<p>
  This call also updates the Workbench screen if needed.</p>
<p>
  Using this routine protects you from any future changes to
  the way icons are stored within the system.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="amigados.IoErr">IoErr()</link>
<link id="PutDiskObject"/>
<link id="GetDiskObject"/>
<link id="FreeDiskObject"/>
<link id="GetIconTagList"/>
<link id="PutIconTagList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DeleteDiskObject.Result">
<short>True if it worked, False if not, check <link id="amigados.IoErr">IoErr()</link> for details.</short>
</element>

<!-- argument Visibility: default -->
<element name="DeleteDiskObject.Name">
<short>Name of the icon file without the ".info"</short>
</element>

<!-- function Visibility: default -->
<element name="FindToolType">
<short>Find the value of a ToolType variable.</short>
<descr><p>This function searches a tool type array for a given entry,
  and returns a pointer to that entry.  This is useful for
  finding standard tool type variables.  The returned
  value is not a new copy of the string but is only
  a pointer to the part of the string after <var>TypeName</var>.</p>
<p>The ToolTypeArray can be get from <link id="workbench.TDiskObject">TDiskObject.do_Tooltypes</link> via <link id="GetDiskObject">GetDiskObject()</link></p>
<p><b>Example:</b></p>
<code>
//Assume the tool type array has two strings in it:
//    "FILETYPE=text"
//    "TEMPDIR=:t"
FindToolType(toolTypeArray, 'FILETYPE'); // returns 'text'
FindToolType(toolTypeArray, 'filetype'); // returns 'text'
FindToolType(toolTypeArray, 'TEMPDIR');  // returns ':t'
FindToolType(toolTypeArray, 'MAXSIZE');  // returns nil
FindToolType(toolTypeArray, 'text');     // returns nil
FindToolType(toolTypeArray, ':t');       // returns nil
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="FreeDiskObject"/>
<link id="GetDiskObject"/>
<link id="MatchToolValue"/>
<link id="Workbench.PDiskObject">PDiskObject</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindToolType.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="FindToolType.ToolTypeArray">
<short>A Pointer to an array of tool types.</short>
</element>

<!-- argument Visibility: default -->
<element name="FindToolType.TypeName">
<short>The name of the tooltype entry</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeDiskObject">
<short>Free all memory in a Workbench disk object.</short>
<descr><p>
  This routine frees all memory in a Workbench disk object, and the
  object itself.  It is implemented via <link id="FreeFreeList">FreeFreeList().</link></p>
<p>
  <link id="GetDiskObject">GetDiskObject()</link> takes care of all the initialization required
  to set up the object's free list.  This procedure may <b>only</b>
  be called on a DiskObject allocated via <link id="GetDiskObject">GetDiskObject()</link>.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetDiskObject"/>
<link id="PutDiskObject"/>
<link id="DeleteDiskObject"/>
<link id="FreeFreeList"/>
<link id="GetIconTagList"/>
<link id="PutIconTagList"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeDiskObject.DiskObj">
<short>A pointer to a DiskObject structure to free. <var>Nil</var> is allowed and does nothing.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeFreeList">
<short>Free all memory in a free list.</short>
<descr><p>This routine frees all memory in a free list, and the
  free list itself.  It is useful for easily getting
  rid of all memory in a series of structures.  There is
  a free list in a Workbench object, and this contains
  all the memory associated with that object.</p>
<p>
  A <link id="workbench.TFreeList">TFreeList</link> is a list of <link id="exec.TMemList">TMemList</link> structures.  See the
  <link id="exec.TMemList">TMemList</link> and <link id="exec.TMemEntry">TMemEntry</link> documentation for more information.</p>
<p>
  If the <link id="workbench.TFreeList">TFreeList</link> itself is in the free list, it must be
  in the first <link id="exec.TMemList">TMemList</link> in the <link id="workbench.TFreeList">TFreeList</link>.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="Exec.AllocEntry">AllocEntry</link>
<link id="Exec.FreeEntry">FreeEntry</link>
<link id="AddFreeList"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeFreeList.FreeList">
<short>A Pointer to FreeList struct. <var>Nil</var> is allowed and does nothing.</short>
</element>

<!-- function Visibility: default -->
<element name="GetDefDiskObject">
<short>Read default wb disk object from disk. </short>
<descr><p>This routine reads in a default Workbench disk object from disk.
  The valid def_types can be found in workbench/workbench.h and
  currently include WBDISK thru WBKICK. If the call fails,
  it will return NULL. The reason for the failure may be obtained
  via <link id="amigados.IOErr">IoErr()</link>.</p>
<p>
  Using this routine protects you from any future changes to
  the way default icons are stored within the system.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="amigados.IOErr">IoErr()</link>
<link id="PutDefDiskObject"/>
<link id="PutIconTagList"/>
<link id="Workbench.WBDISK">WBDISK</link>
<link id="Workbench.WBDRAWER">WBDRAWER</link>
<link id="Workbench.WBTOOL">WBTOOL</link>
<link id="Workbench.WBPROJECT">WBPROJECT</link>
<link id="Workbench.WBGARBAGE">WBGARBAGE</link>
<link id="Workbench.WBDEVICE">WBDEVICE</link>
<link id="Workbench.WBKICK">WBKICK</link>
<link id="Workbench.WBAPPICON">WBAPPICON</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetDefDiskObject.Result">
<short>The default Workbench disk object in question
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDefDiskObject.Typ">
<short>Default icon type (<link id="Workbench.WBDISK"/> thru <link id="Workbench.WBKICK"/> see links).</short>
</element>

<!-- function Visibility: default -->
<element name="GetDiskObject">
<short>Read in a Workbench disk object from disk.</short>
<descr><p>
  This routine reads in a Workbench disk object in from disk.  The
  name parameter will have ".info" postpended to it, and the
  icon file of that name will be read.  If the call fails,
  it will return <var>nil</var>.  The reason for the failure may be obtained
  via <link id="amigados.IOErr">IoErr()</link>.</p>
<p>
  Using this routine protects you from any future changes to
  the way icons are stored within the system.</p>
<p>
  A <link id="Workbench.TFreeList">TFreeList</link> structure is allocated just after the DiskObject
  structure; <link id="FreeDiskObject">FreeDiskObject()</link> makes use of this to get rid of the
  memory that was allocated.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDos.IoErr">IoErr()</link>
<link id="DeleteDiskObject"/>
<link id="FreeDiskObject"/>
<link id="GetDiskObjectNew"/>
<link id="GetIconTagList"/>
<link id="NewDiskObject"/>
<link id="PutDiskObject"/>
<link id="PutIconTagList"/>
<link id="Workbench.AddAppIconA">AddAppIconA</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetDiskObject.Result">
<short>The Workbench disk object in question
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDiskObject.Name">
<short>Name of the object or <var>nil</var> if you just want a
          DiskObject structure allocated for you (useful when
          calling <link id="Workbench.AddAppIcon">AddAppIcon()</link> in workbench.library).
</short>
</element>

<!-- function Visibility: default -->
<element name="GetDiskObjectNew">
<short>Read in a Workbench disk object from disk.</short>
<descr><p>This routine reads in a Workbench disk object in from disk.  The
  name parameter will have ".info" postpended to it, and the
  icon file of that name will be read.  If the call fails,
  it will return zero.  The reason for the failure may be obtained
  via IoErr().</p>
<p>
  Using this routine protects you from any future changes to
  the way icons are stored within the system.</p>
<p>
  A <link id="Workbench.TFreeList">TFreeList</link> structure is allocated just after the DiskObject
  structure; <link id="FreeDiskObject">FreeDiskObject()</link> makes use of this to get rid of the
  memory that was allocated.</p>
<p>
  This call is functionally identical to <link id="GetDiskObject">GetDiskObject()</link> with one
  exception. If its call to <link id="GetDiskObject">GetDiskObject()</link> fails, this function calls
  <link id="GetDefDiskObject">GetDefDiskObject()</link>. This is useful when there is no .info file for the
  icon you are trying to get a disk object for. Applications that use
  workbench application windows <b>must</b> use this call if they want to handle
  the user dropping an icon (that doesn't have a '.info' file) on their
  window.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDos.IoErr">IoErr()</link>
<link id="DeleteDiskObject"/>
<link id="FreeDiskObject"/>
<link id="GetDiskObject"/>
<link id="GetIconTagList"/>
<link id="NewDiskObject"/>
<link id="PutDiskObject"/>
<link id="PutIconTagList"/>
<link id="Workbench.AddAppIconA">AddAppIconA</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetDiskObjectNew.Result">
<short>The Workbench disk object in question
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetDiskObjectNew.Name">
<short>Name of the object or <var>nil</var> if you just want a
          DiskObject structure allocated for you (useful when
          calling <link id="Workbench.AddAppIcon">AddAppIcon()</link> in workbench.library).</short>
</element>

<!-- function Visibility: default -->
<element name="MatchToolValue">
<short>Check a tool type variable for a particular value.</short>
<descr><p>
  MatchToolValue is useful for parsing a tool type value for
  a known value.  It knows how to parse the syntax for a tool
  type value (in particular, it knows that '|' separates
  alternate values).  Note that the parsing is case insensitive.</p>
<p><b>Snippet</b></p>
<code>
//Assume there are two type strings:
type1 := 'text';
type2 := 'a|b|c';
MatchToolValue(type1, 'text'); // returns True
MatchToolValue(type1, 'TEXT'); // returns True
MatchToolValue(type1, 'data'); // returns False
MatchToolValue(type2, 'a');    // returns True
MatchToolValue(type2, 'b');    // returns True
MatchToolValue(type2, 'd');    // returns False
MatchToolValue(type2, 'a|b');  // returns False
</code>
</descr>
<errors>
</errors>
<seealso>
<link id="FindToolType"/>
<link id="Utility.Stricmp">Stricmp</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MatchToolValue.Result">
<short>True if the value was in <var>TypeString</var> else False.</short>
</element>

<!-- argument Visibility: default -->
<element name="MatchToolValue.TypeString">
<short>A ToolType value (as returned by <link id="FindToolType">FindToolType()</link>)</short>
</element>

<!-- argument Visibility: default -->
<element name="MatchToolValue.Value">
<short>You are interested if value appears in <var>TypeString</var></short>
</element>

<!-- function Visibility: default -->
<element name="PutDefDiskObject">
<short>Write disk object as the default for its type.</short>
<descr><p>This routine writes out a DiskObject structure, and its
  associated information.  If the call fails, False will
  be returned.  The reason for the failure may be obtained
  via <link id="amigados.IOErr">IoErr()</link>.</p>
<p>
  Note that this function calls <var>PutDiskObject()</var> internally which means
  that this call (if sucessful) notifies workbench than an icon has
  been created/modified.</p>
<p>
  Using this routine protects you from any future changes to
  the way default icons are stored within the system.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDos.IoErr">IoErr()</link>
<link id="GetDefDiskObject"/>
<link id="GetIconTagList"/>
<link id="PutDiskObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PutDefDiskObject.Result">
<short>True if the call succeeded else False
</short>
</element>

<!-- argument Visibility: default -->
<element name="PutDefDiskObject.Icon">
<short>A pointer to a DiskObject</short>
</element>

<!-- function Visibility: default -->
<element name="PutDiskObject">
<short>Write out a DiskObject to disk.</short>
<descr><p>This routine writes out a DiskObject structure, and its
  associated information.  The file name of the info
  file will be the name parameter with ".info" postpended
  to it.  If the call fails, False will be returned.  The
  reason for the failure may be obtained via <link id="amigados.IOErr">IoErr()</link>.</p>
<p>
  <var>PutDiskObject()</var> (if successful) notifies Workbench
  when an icon has been created/modified.</p>
<p>
  Using this routine protects you from any future changes to
  the way icons are stored within the system.
</p>
<p><b>Note:</b></p>
<p>
It is recommended that if you wish to copy an icon from one place
  to another than you use <link id="GetDiskObject">GetDiskObject()</link>
  and <var>PutDiskObject()</var>
  and do not copy them directly.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDos.IoErr">IoErr()</link>
<link id="DeleteDiskObject"/>
<link id="FreeDiskObject"/>
<link id="GetDiskObject"/>
<link id="GetIconTagList"/>
<link id="PutIconTagList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PutDiskObject.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="PutDiskObject.Name">
<short>Name of the object</short>
</element>

<!-- argument Visibility: default -->
<element name="PutDiskObject.Icon">
<short>A pointer to a DiskObject</short>
</element>

<!-- function Visibility: default -->
<element name="DupDiskObjectA">
<short>Duplicate an icon</short>
<descr>
  This function is used to create a duplicate of a DiskObject
  in memory. It can also be used to create an extended
  ("native") DiskObject data structure from an existing,
  traditional format DiskObject data structure.
</descr>
<errors>
</errors>
<seealso>
<link id="amigados.IOErr">IoErr()</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="DupDiskObjectA.Result">
<short>Pointer to a struct DiskObject or nil in case of error.
      You can use <link id="amigados.IOErr">IoErr()</link> to retrieve the error code or use the
      <link id="ICONA_ErrorCode"/> tag instead.</short>
</element>

<!-- argument Visibility: default -->
<element name="DupDiskObjectA.Icon">
<short>Pointer to the icon to be duplicated.</short>
</element>

<!-- argument Visibility: default -->
<element name="DupDiskObjectA.Tags">
<short>Control options. (ICONDUPA_*)</short>
</element>

<!-- function Visibility: default -->
<element name="IconControlA">
<short>Set and get icon and icon.library options</short>
<descr>This function is used to modify and query icon and icon.library
  options.
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDOS.IoErr">IoErr</link>
<link id="DupDiskObjectA"/>
<link id="GetIconTagList"/>
<link id="LayoutIconA"/>
<link id="NewDiskObject"/>
<link id="agraphics.BltMaskBitMapRastPort">BltMaskBitMapRastPort</link>
<link id="agraphics.ObtainBestPenA">ObtainBestPenA</link>
<link id="utility.CallHookPkt">CallHookPkt</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IconControlA.Result">
<short><p>
  Number of tags that were processed correctly, i.e.
  the number of tags whose parameters are in order, for which
  information could be returned, etc. If processing stops because of
  an error, the number returned by this function will be smaller
  than the number of tag items passed in. The same happens if
  the information you wanted to obtain is unavailable. In any
  case, check the error code this routine can set up for you.</p>
<p>Changing an icon's palette or image data does not automatically
  produce a different icon image you can use. To do this, you
  must re-layout it using <link id="LayoutIconA">LayoutIconA()</link>.</p>
<p>
  When querying parameters, make sure to always pass in a pointer
  to a LongWord variable to store the result in.</p>
<p>
  Some get/set operations may cause additional memory to be
  allocated. This may fail; be prepared.</p>
<p>
  IconControlA() processes the tag item list in sequential order.
  This has consequences for several tags, such as the palette size
  and the transparent colour. For example, if you want to make
  colour #14 of an icon image transparent, make sure to have the
  palette size set to at least 15 colours before you try to change
  the transparent colour. Otherwise, IconControlA() may refuse to
  set the transparent colour to #14 since it won't know that there
  should be more than 14 colours in that image at the time you try
  to set it. Therefore, if you wanted to change the palette size and
  the transparent colour in the same tag item list, make sure that the
  palette size change tag appears before the transparent colour change
  tag.</p>
<p>
  As described above, some of the operations on icons are not
  supported for DiskObjects not allocated through icon.library. In
  such cases you will receive an error code <link id="amigados.ERROR_ACTION_NOT_KNOWN">ERROR_ACTION_NOT_KNOWN</link>.</p>
</short>
</element>

<!-- argument Visibility: default -->
<element name="IconControlA.Icon">
<short>Pointer to a struct DiskObject, or NULL if global
    options are to be modified/queried.</short>
</element>

<!-- argument Visibility: default -->
<element name="IconControlA.Tags">
<short>Options to modify/query.</short>
</element>

<!-- procedure Visibility: default -->
<element name="DrawIconStateA">
<short>Draw an icon as if it were an image</short>
<descr>This function will draw an icon as if it were an image; if
  a label is provided, it will be printed below it.
</descr>
<errors>
</errors>
<seealso>
<link id="Intuition.DrawImageState">DrawImageState</link>
<link id="GetIconRectangleA"/>
<link id="IconControlA"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.Rp">
<short>Pointer to the RastPort to draw into; the RastPort clipping
      rules, font, style, text colours and drawing mode will be used.</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.Icon">
<short>Pointer to a struct DiskObject.</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.Label_">
<short>Label for the icon, if nil no label is printed</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.LeftEdge">
<short>Coordinates at which the icon image
      should be drawn, including its border; please note that the
      icon label may extend in whole or in part beyond the
      leftEdge you have specified.</short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.TopEdge">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.State">
<short>Select how and which icon image should be drawn; (<link id="Intuition">IDS_*</link>) </short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.Tags">
<short>Additional drawing options (ICONDRAWA_*)</short>
</element>

<!-- function Visibility: default -->
<element name="GetIconRectangleA">
<short>Query the size of the area an icon renders into</short>
<descr><p>This function will calculate the size of the area icon rendering
  would affect.</p>
<p><b>Notes:</b></p>
<p>This function can be used to optimize on-screen rendering by
  precalculating the area rendering would cover. To make sure that
  the precalculated area size matches the one covered by the actual
  drawing operation, the RastPorts you use for measuring and for
  drawing should share the same font and the same text styles.</p>
<p>
  The image size calculated by this function can be
  slightly larger than the data you will find in the icon's
  do_Gadget.GadgetRender Image structure since the icon border
  will be taken into account. This happens regardless of whether
  icon.library was switched into frameless icon rendering mode
  or whether the icon is frameless. To obtain the size of the
  icon without taking the border into account, use the
  <link id="ICONDRAWA_Borderless"/> tag.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="DrawIconStateA"/>
<link id="IconControlA"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetIconRectangleA.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconRectangleA.Rp">
<short>Pointer to the RastPort to use for calculating the
      the size of the label with respect to the font and
      style options currently in use; this parameter may be
      NULL if the label is NULL, too.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconRectangleA.Icon">
<short>True if the parameters were well-formed and
      the output data fits into the Rectangle data
      structure (which may not be the case if the image
      is too large for a signed 16 bit integer to hold).
</short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconRectangleA.Label_">
<short>Label for icon, if nil no text is calculated</short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconRectangleA.Rect">
<short>Pointer to a Rectangle to fill in. The
      contents will take the size of the icon image, the icon
      border size and -- if you provide RastPort and label
      text -- the icon label into account. Due to how labels
      are printed, the rectangle^.MinX and rectangle^.MinY
      members may be negative.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconRectangleA.Tags">
<short>Additional drawing options to be taken into account. (ICONDRAWA_*)</short>
</element>

<!-- function Visibility: default -->
<element name="NewDiskObject">
<short>Create an empty icon</short>
<descr><p>This function is used to create an "empty" DiskObject
  structure, which has no image data associated with it.
  Still, all the necessary structures are in place,
  you just have to fill them in.</p>
<p>
  The DiskObject returned by this function will have a zero
  width and height Image in the do_Gadget.GadgetRender member
  and the do_Gadget.Width/do_Gadget.Height members will both
  be 0, too.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDos.IoErr">IoErr()</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NewDiskObject.Result">
<short>Pointer to a struct DiskObject or nil in case of error.
      You can use <link id="AmigaDos.IoErr">IoErr()</link> to retrieve the error code.</short>
</element>

<!-- argument Visibility: default -->
<element name="NewDiskObject.Type_">
<short>Icon type to create, this must be one of <link id="Workbench.WBDISK">WBDISK</link>,
      <link id="Workbench.WBDRAWER">WBDRAWER</link>, <link id="Workbench.WBTOOL">WBTOOL</link>,
      <link id="Workbench.WBPROJECT">WBPROJECT</link>, <link id="Workbench.WBGARBAGE">WBGARBAGE</link>,
      <link id="Workbench.WBDEVICE">WBDEVICE</link> or <link id="Workbench.WBKICK">WBKICK</link>.</short>
</element>

<!-- function Visibility: default -->
<element name="GetIconTagList">
<short>Retrieve an icon</short>
<descr><p>
  This function is used to retrieve an icon; the icon can
  belong to a file/drawer/volume or it can be a default icon.</p>
<p>This function is a superset of <link id="GetDefDiskObject">GetDefDiskObject()</link>,
  <link id="GetDiskObject">GetDiskObject()</link> and <link id="GetDiskObjectNew">GetDiskObjectNew()</link>.</p>
<p>
  If a palette-mapped icon is set to allocate its colours from the
  default screen, such as the Workbench screen, icon.library may
  resort to remap its colours in the course of Workbench screen
  close/reopen transitions. This means that you cannot depend upon
  the icon's image bitmaps to stay the same size, shape or colour.
  If this is what you need, you should either create your own images
  from the palette mapped data or make copies of the icon image
  bitmaps and the associated colour table.</p>
<p>
  If during Workbench close/open transitions the global remap
  screen becomes nil, <var>GetIconTagList()</var> may refuse to return a
  remapped icon and return with an error (<link id="AmigaDOS.ERROR_REQUIRED_ARG_MISSING">ERROR_REQUIRED_ARG_MISSING</link>)
  instead.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetDiskObject"/>
<link id="GetDiskObjectNew"/>
<link id="GetDefDiskObject"/>
<link id="IconControlA"/>
<link id="PutIconTagList"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetIconTagList.Result">
<short>Pointer to a struct DiskObject or nil in case of error.
      You can use <link id="AmigaDos.IoErr">IoErr()</link> to retrieve the error code or use the
      <link id="ICONA_ErrorCode"/> tag instead.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconTagList.Name">
<short>Name of the object an icon is to be retrieved for,
      or nil if a default icon is to be retrieved.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetIconTagList.Tags">
<short>Retrieval options. (ICONGETA_*)</short>
</element>

<!-- function Visibility: default -->
<element name="PutIconTagList">
<short>Store an icon</short>
<descr><p>This function is used to store an icon; the icon can
  belong to a file/drawer/volume or it can be a default icon.</p>
<p>This function is a superset of <link id="PutDefDiskObject">PutDefDiskObject()</link> and
  <link id="PutDiskObject">PutDiskObject()</link>.</p>
<p>
  If the name of the icon file to be stored would be too long to fit
  (as set with <link id="IconControlA">IconControlA</link>(..., <link id="ICONCTRLA_SetGlobalMaxNameLength"/>, ...))
  then <var>PutIconTagList()</var> will silently pretend that the icon file has
  been written to disk. However, it will not store the icon file on the
  disk since there would a risk of accidentally overwriting the file the
  icon belongs to. If you want to know whether the icon you wrote was
  in fact written to disk, provide an error code pointer with the
  <link id="ICONA_ErrorCode"/> tag. If the name of the file was too long,
  <var>PutIconTagList()</var> will still pretend that the icon file was written
  successfully, but the error code <link id="AmigaDOS.ERROR_TOO_MANY_LEVELS">ERROR_TOO_MANY_LEVELS</link> will be stored
  in the variable you passed in with the <link id="ICONA_ErrorCode"/> tag.</p>
</descr>
<errors>
</errors>
<seealso>
<link id="GetIconTagList"/>
<link id="PutDefDiskObject"/>
<link id="PutDiskObject"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PutIconTagList.Result">
<short>True if the icon file could be stored, FALSE otherwise.
      You can use <link id="AmigaDOS.IoErr">IoErr()</link> to retrieve the error code or use the
      <link id="ICONA_ErrorCode"/> tag instead.</short>
</element>

<!-- argument Visibility: default -->
<element name="PutIconTagList.Name">
<short>Name of the object the icon is to be stored for,
      or nil if a default icon is to be stored.</short>
</element>

<!-- argument Visibility: default -->
<element name="PutIconTagList.Icon">
<short>The icon to be stored.</short>
</element>

<!-- argument Visibility: default -->
<element name="PutIconTagList.Tags">
<short>Storage options. (ICONPUTA_*)</short>
</element>

<!-- function Visibility: default -->
<element name="LayoutIconA">
<short>Adapt a palette-mapped icon for display</short>
<descr><p>This function will prepare an icon for display, either on a
  specific screen or using a default colour palette. It is
  useful only for palette mapped icons.
</p>
<p>You must make sure that the screen you remap to does not
  go away while there is an icon to use its colours. For
  a public screen, the easiest way to guarantee this is
  to keep it locked (see <link id="intuition.LockPubScreen">LockPubScreen()</link>).
  For custom screens, just don't close them! If you have to close
  the screen or need to keep your icon around until after a screen
  is closed, you should call <var>LayoutIconA()</var> with a nil screen
  parameter. This will release all pens the icon has allocated
  and remap the icon to a default set of colours. Alternatively,
  you can dispose of the icon via <link id="FreeDiskObject">FreeDiskObject()</link> which
  will also release all pens the icon has allocated, including
  the icon itself, of course.</p>
<p>
  Icons remapped to the global default screen (normally, that
  would be the Workbench screen) may get changed and remapped
  again during Workbench close/open transitions. To prevent
  this from taking place, just make sure that the Workbench
  screen does not close (e.g. via <link id="intuition.LockPubScreen">LockPubScreen()</link>("Workbench")).</p>
</descr>
<errors>
</errors>
<seealso>
<link id="AmigaDos.IoErr">IoErr</link>
<link id="agraphics.ObtainBestPenA">ObtainBestPenA</link>
<link id="agraphics.ReleasePen">ObtainBestPenA</link>
<link id="FreeDiskObject"/>
<link id="GetIconTagList"/>
<link id="IconControlA"/>
<link id="intuition.LockPubScreen">LockPubScreen</link>
<link id="intuition.UnLockPubScreen">UnLockPubScreen</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LayoutIconA.Result">
<short>True if the icon could be remapped, False if
      the remapping failed for some reason. In case of
      of failure, icon.library will try its best to keep
      the icon in a presentable state, but this may fail.
      In case of failure, the error code can be retrieved
      using <link id="AmigaDos.IoErr">IoErr()</link>.
</short>
</element>

<!-- argument Visibility: default -->
<element name="LayoutIconA.Icon">
<short>The icon to be remapped. This must be a palette mapped
      icon.</short>
</element>

<!-- argument Visibility: default -->
<element name="LayoutIconA.Screen">
<short>Pointer to a screen to remap the icon for or nil
      to remap the icon to use the system default colour palette
      or something very similar to it (this means: four colours
      only).</short>
</element>

<!-- argument Visibility: default -->
<element name="LayoutIconA.Tags">
<short>Additional rendering options. <link id="AGraphics.OBP_Precision">OBP_Precision</link></short>
</element>

<!-- procedure Visibility: default -->
<element name="ChangeToSelectedIconColor">
<short>Modify an RGB colour value for use in a selected icon image</short>
<descr>This function will change the provided RGB colour value to make it
  suitable for use in an icon's select image. This may involve darkening
  or toning the colour. Usually, icon.library calls this function
  when creating a select image for palette mapped icons which do not
  contain "real" select images.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="ChangeToSelectedIconColor.Cr">
<short>Pointer to a ColorRegister, containing the RGB colour value
      to be changed.</short>
</element>

<!-- function Visibility: default -->
<element name="PACK_ICON_ASPECT_RATIO">
<short>Pack Numerator and a denominator into a single byte as icon aspect</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
<link id="ICONCTRLA_SetAspectRatio"/>
<link id="ICONCTRLA_GetAspectRatio"/>
<link id="IconControlA"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="PACK_ICON_ASPECT_RATIO.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="PACK_ICON_ASPECT_RATIO.Num">
<short>Numerator</short>
</element>

<!-- argument Visibility: default -->
<element name="PACK_ICON_ASPECT_RATIO.Den">
<short>Denominator</short>
</element>


<!-- uses unit Visibility: default -->
<element name="exec">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="workbench">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="utility">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="amigados">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="agraphics">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="intuition">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="datatypes">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="ICONDRAWA_IsLink">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="IconBase">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="PutDefDiskObject.diskObject">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="PutDiskObject.diskobj">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DupDiskObjectA.diskObject">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.leftOffset">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="DrawIconStateA.topOffset">
<short></short>
</element>


</module> <!-- icon -->

</package>
</fpdoc-descriptions>
